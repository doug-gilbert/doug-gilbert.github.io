<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title>Linux SG driver version 4.0</title>
	<meta name="generator" content="LibreOffice 6.4.6.2 (Linux)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="2021-01-20T21:44:11.493973275"/>
	<meta name="keywords" content="Linux, SCSI, SG_IO, pass-through"/>
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<meta name="created" content="00:00:00">
	<style type="text/css">
		@page { size: 21.59cm 27.94cm; margin-left: 2cm; margin-right: 1cm; margin-top: 1cm; margin-bottom: 1cm }
		p { color: #000000; background: transparent }
		td p { margin-bottom: 0.1cm; color: #000000; background: transparent }
		h2 { margin-top: 0.35cm; margin-bottom: 0.21cm; color: #000000; background: transparent; page-break-after: avoid }
		h2.western { font-family: "Liberation Serif", serif; font-size: 18pt; font-weight: bold }
		h2.cjk { font-family: "Noto Sans CJK SC Regular"; font-size: 18pt; font-weight: bold }
		h2.ctl { font-family: "Lohit Devanagari"; font-size: 18pt; font-weight: bold }
		pre { color: #000000; background: transparent }
		pre.western { font-family: "Liberation Mono", monospace; font-size: 10pt }
		pre.cjk { font-family: "Courier New", monospace; font-size: 10pt }
		pre.ctl { font-family: "Liberation Mono", monospace; font-size: 10pt }
		h3 { margin-top: 0.25cm; margin-bottom: 0.21cm; color: #000000; background: transparent; page-break-after: avoid }
		h3.western { font-family: "Albany", sans-serif; font-size: 14pt; font-weight: bold }
		h3.cjk { font-family: "Noto Sans CJK SC Regular"; font-size: 14pt; font-weight: bold }
		h3.ctl { font-family: "Lohit Devanagari"; font-size: 14pt; font-weight: bold }
		th p { margin-bottom: 0.1cm; color: #000000; font-weight: bold; text-align: center; background: transparent }
		a:link { color: #0000ff; text-decoration: underline }
		code.western { font-family: "Liberation Mono", monospace }
		code.cjk { font-family: "Courier New", monospace }
		code.ctl { font-family: "Liberation Mono", monospace }
		a:visited { color: #000080; so-language: zxx; text-decoration: underline }
		strong { font-weight: bold }
	</style>
</head>
<body lang="en-CA" text="#000000" link="#0000ff" vlink="#000080" bgcolor="#eeeeee" dir="ltr">
<ol><p align="center" style="margin-top: 0.32cm; margin-bottom: 0.4cm; page-break-after: avoid">
	<font face="Albany, sans-serif"><font size="6" style="font-size: 28pt"><b>The
	Linux SG driver version 4.0</b></font></font></p>
</ol>
<div id="Table of Contents1" dir="ltr"><p style="margin-left: 0.5cm; margin-bottom: 0cm">
	<a href="#__RefHeading___Toc1534_4294551682">1 Introduction</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc7793_510494588">1.1
	Status</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1536_4294551682">2
	Changes to sg driver between version 3.5.36 and 4.0</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc8274_3647010070">2.1
	Deprecated or removed features in version 4.0 compared to earlier
	version</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1538_4294551682">3
	SCSI Generic versions 1, 2, 3 and 4 interfaces</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1540_4294551682">3.1
	Comparison of fields in the v4 and v3 interfaces</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1542_4294551682">3.2
	Flags in v3 and v4 interfaces</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1544_4294551682">3.3
	The info field</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1546_4294551682">4
	Architecture of the sg driver</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc18168_1671399770">4.1
	Command or request</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc8276_3647010070">4.2
	Direct, mmap()-ed IO and bio_s</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1548_4294551682">5
	Synchronous usage</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1550_4294551682">6
	Sharing file descriptors</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1552_4294551682">7
	Async usage in v4</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1554_4294551682">7.1
	ioctl(SG_IOABORT)</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1556_4294551682">8
	Request sharing</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc15431_608653543">8.1
	READ, WRITE, WRITE</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1560_4294551682">9
	Sharing design considerations</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1562_4294551682">10
	Multiple requests</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1564_4294551682">10.1
	Processing mrq responses</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1566_4294551682">10.2
	Aborting multiple requests</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1568_4294551682">10.3
	Single/multiple (non-)blocking requests</a></p>
	<p style="margin-left: 1cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc18199_72860742">10.4
	SGV4_FLAG_REC_ORDER flag</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1570_4294551682">11
	pack_id or tag</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc36099_3879977686">12
	iopoll/blk_poll() support</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1572_4294551682">13
	Bi-directional command support</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1574_4294551682">14
	SG interface support changes</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1576_4294551682">15
	IOCTLs</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc17996_3956569564">16
	System Calls</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1578_4294551682">17
	Downloads and testing</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1580_4294551682">18
	Other documents</a></p>
	<p style="margin-left: 0.5cm; margin-bottom: 0cm"><a href="#__RefHeading___Toc1582_4294551682">19
	Conclusion</a></p>
</div>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<h2 class="western"><a name="__RefHeading___Toc1534_4294551682"></a>1
Introduction</h2>
<p>The SCSI Generic (<b>sg</b>) driver in Linux passes SCSI commands,
optionally with data (known as <i>data-out)</i>, to a SCSI device,
and receives back from that device: SCSI status, sense data (if the
status is &quot;bad&quot;) and optionally data (known as <i>data-in</i>).
It is the <i>pass-through</i> driver of the Linux SCSI subsystem. The
<b>sg</b> driver does not <i><u>own</u></i> SCSI devices in the
normal fashion <font color="#000000">in which</font> many OS drivers
have <i>exclusive</i> control over a class of devices. In most cases
the <b>sg</b> driver <i><u>shares</u></i> control of SCSI devices
with other SCSI sub-system upper level drivers such as <b>sd</b> (for
disks), <b>st</b> (for tape drives), <b>sr</b> (for DVD/CDs) and <b>ses</b>
(for SCSI Enclosure Services devices). Some disk array drivers choose
to make their (physical) disks visible to the <b>sg</b> driver and
<i><u>not</u></i> visible to the <b>sd</b> driver; the reason is to
disallow <i>direct</i> data access to those disks while allowing
tools like smartmontools to monitor the <i>metadata </i>of those
disks (e.g. their temperature and endurance/lifetime metrics (for
SSDs)).</p>
<p>The <b>sg</b> driver has been present since version 1.0 of the
Linux kernel in 1992. In the 28 years since then the driver has had 3
interfaces to the user space and now a fourth is being added. The
first and second interfaces (v1 and v2) use the same header: 'struct
sg_header' with only v2 now fully supported. The &quot;v3&quot;
interface is based on 'struct sg_io_hdr'. Both these structures are
defined in include/scsi/sg.h the bulk of whose contents will move to
include/uapi/scsi/sg.h as part of this upgrade. Prior to the changes
now proposed, the &quot;v4&quot; interface is only implemented in the
block layer's <b>bsg</b> driver. The Block SCSI Generic (<b>bsg</b>)
driver has been present in Linux for around 15 years . The <b>bsg</b>
driver's user interface is found in include/uapi/linux/bsg.h . These
changes propose adding support for the &quot;v4&quot; interface via
<b>ioctl</b><span style="font-weight: normal">(SG_IO)</span> for
synchronous use, and the new <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font><span style="font-weight: normal">)</span>
and <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font><span style="font-weight: normal">)</span>
for asynchronous/non-blocking use. The plan is to deprecate and
finally remove (or severely restrict) the <b>write</b>(2)/<b>read</b>(2)
based asynchronous interface used currently by the v1, v2 and v3
interfaces. The v3 asynchronous interface is supported by the new
<font color="#0066b3"><span style="font-weight: normal">SG_IOSUBMIT_V3</span></font>
and <font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font><span style="font-weight: normal">
</span><b>ioctl</b><span style="font-weight: normal">(2)s .</span><br/>
<br/>
If
the driver changes are accepted, the driver version, which is visible
via an <b>ioctl</b><span style="font-weight: normal">(SG_GET_VERSION_NUM),</span>
will be bumped from 3.5.36 (in lk 5.9) to 4.0.x . The opportunity is
being taken to clean up the driver after 20 years of piecemeal
patches. Those patches have left the driver with misleading variable
names and comments that don't match the adjacent code. Plus there are
new kernel facilities that the driver can take advantage of. Also of
note is that much or the low level code once in the sg driver (and
remnants remain) have been moved to the block layer and the SCSI
mid-level. This upgrade has been done as a two stage process: first
clean the driver up, remove some restrictions and reinstate some
features that have been accidentally lost. The first stage also adds
basic v4 interface support using the <b>ioctl</b>(SG_IO) for
sync/blocking usage; and <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
and <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) for
async/non-blocking usage. 
</p>
<p>Note that the Linux block layer implements the synchronous sg v3
interface via <b>ioctl</b>(<span style="font-weight: normal">SG_IO</span>)
on <i>all</i> block devices that use the SCSI subsystem, directly or
via translation (e.g. SATA disks use libata which implements the T10
SAT standard; see <a href="https://www.t10.org/">https://www.t10.org/
</a>). In pseudocode an example like this: ' <b>ioctl</b>(<b>open</b>(&quot;/dev/sdc&quot;),
<span style="font-weight: normal">SG_IO</span>, ptr_to_sg_io_hdr)'
works as expected. This is <i>not</i> implemented by the sg driver so
it is important that the sg driver's implementation of <b>ioctl</b>(<span style="font-weight: normal">SG_IO</span>)
remains consistent with other driver implementations (mainly the one
found in block/scsi_ioctl.c kernel source code).</p>
<h3 class="western"><a name="__RefHeading___Toc7793_510494588"></a>1.1
Status</h3>
<p>A recent first stage patchset (containing 45 patches) was sent to
the linux-scsi list on 20210117. Its cover was titled: &quot;[PATCH
v13 00/45] sg: add v4 interface&quot;.  Patch 45 bumps the driver
version number to 4.0.12 . The sgv4_20210117 patchset below <font color="#000000">combines
the first and second stage patchsets.</font> Its first stage patchset
 contains 45 patches. Its second stage patchset adds the new features
such as file and request sharing, multiple requests (in one
invocation) and supports and the so-called <i>extended</i> <b>ioctl</b>(2).
The second patchset is only currently available from this page (as
patches 0046 to 0083 applied on top of the first stage). Its second
stage bumps the driver version number to 4.0.46 . See <a href="#15 Downloads and testing|outline">Downloads
and testing section</a> below.</p>
<p>In keeping with a new Linux kernel coding style directive, the
terms master and slave have been replaced by <span style="font-style: normal"><u>read-side</u></span><i>
</i>and <u>write side</u> respectively. These terms refer to the two
sides of a <a href="#8 Request sharing|outline">Request share</a>
which is explained in a later section. One aspect lost with this
changed terminology is that the <u>read-side</u> is the <i>leader</i>
(i.e. comes first) and the <u>write-side</u> is a <i>follower</i>.
And usually the <u>write-side</u> is dependent on the <u>read-side</u>
succeeding.</p>
<h2 class="western"><a name="__RefHeading___Toc1536_4294551682"></a>2
Changes to sg driver between version 3.5.36 and 4.0</h2>
<p>The sg driver <i>version number</i> is visible to the user space
via <b>ioctl</b>(SG_GET_VERSION_NUM) and in procfs via 'cat
/proc/scsi/sg/version'. The version number has been stable at 3.5.36
for the past 5 years, up to and including Linux kernel 5.5.0 . Since
the changes proposed in this page are large, they have been divided
into two patchsets. The first patchset has been sent to the
Linux-scsi development list in <font color="#000000">many </font>versions
during the last months. 
</p>
<p>The following set of bullet points corresponds to the <u>first</u>
patchset:</p>
<ul>
	<li><p>remove limit of 16 outstanding commands/requests per file
	descriptor. There is now a single xarray (&quot;extensible array&quot;))
	per sg file descriptor, with some requests marked as &quot;inactive&quot;
	which means they are ready for re-use in the future. In the updated
	driver there can be virtually an unlimited number of outstanding
	requests per file descriptor. To limit a badly programmed
	application from consuming all available memory, each request that
	uses data buffers bumps a byte counter which will reject further
	requests on that descriptor if a given count is exceeded. That
	defaults to 16 MiB and that value can be modified via an <b>ioctl</b>(2).</p>
	<li><p>defer freeing of resources (specifically memory) of all
	request objects on one file descriptor until the last copy (if any)
	of that file descriptor is closed. This includes waiting for the
	completion of all associated &quot;inflight&quot; requests. This
	allows re-use of resources when multiple SCSI commands are sent via
	the same file descriptor. Associated request block layer and SCSI
	mid-level objects are freed as soon as practical (same as they were
	in 3.5.36).</p>
	<li><p>extend the SG_IO <b>ioctl(2)</b> to accept the v4 interface
	based on struct sg_io_v4 found in <font face="Liberation Mono, monospace">&lt;linux/bsg.h&gt;</font></p>
	<li><p>add <font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>
	and <font color="#a3238e">SG_IORECEIVE</font> <b>ioctl(2)</b>s for
	asynchronous (non-blocking) usage with the v4 interface.</p>
	<li><p>add <font color="#0066b3">SG_IOSUBMIT_V3</font> and
	<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>
	<b>ioctl(2)</b>s for asynchronous (non-blocking) usage with the v3
	interface. These are designed to be replacements for the <b>write</b>()
	and <b>read</b>() system calls which have been used for this purpose
	in version 1, 2 and 3 of the sg driver.</p>
	<li><p>reinstate the original functionality of the SG_FLAG_NO_DXFER
	request flag. If given then it will bypass user data copies between
	the user space and kernel buffers. <font color="#000000">This flag</font>
	will <i><u>not</u></i> effect the user data transfers (usually DMA)
	between SCSI devices and kernel buffers controlled by this driver;
	they still take place. This level of control is needed for the
	&quot;sharing&quot; request feature discussed below.</p>
	<li><p>add support for blk_poll() and REQ_HIPRI with the
	SGV4_FLAG_HIPRI</p>
	<li><p>'re-purpose' previously unused 8 bytes at end of <i>struct
	sg_scsi_id</i> for the full SCSI LUN as an array of 8 bytes. Use
	anonymous union within the structure to avoid breaking existing
	code.</p>
	<li><p>copy output obtained by 'cat /proc/scsi/sg/debug' to 'cat
	/sys/kernel/debug/scsi_generic/snapshot'. This is the initial
	debugfs support. Add snapshot_devs read-write attribute that can be
	used to limit which sg devices are shown in the snapshot.</p>
	<li><p>add support for iopoll, also known as hipri and blk_poll.
	Currently both sync and async usage is supported but restrictions
	may need to be added for async usage. This feature is &quot;new
	ground&quot; for the SCSI subsystem.</p>
	<li><p>bump the driver version number to 4.0.12</p>
</ul>
<p>Probably the most important aspect of the first patchset not shown
in the above list, is <i>modernizing </i>the driver code. Much of
that driver code is over twenty years old and many things have
changed in the kernel since then, especially in the area of
multi-core machines and the code needed to handle the parallelism
that introduces. 
</p>
<p>The following list of features are added in the <u>second</u>
patchset:</p>
<ul>
	<li><p>add <i>file descriptor sharing</i> in which the user sets up
	a relationship between two sg driver file descriptors. This is used
	for two purposes: for request sharing (next bullet) and for allowing
	multiple requests submitted on a single file descriptor to be able
	to access another (shared) sg file descriptor.</p>
	<li><p>add <i>request sharing</i> to expedite copying. Large copies
	can be considered as a sequence of copy segments. Each copy segment
	is typically a READ from device X followed by a WRITE to device Y of
	the data just received from device X. Request sharing uses a single,
	&quot;in-kernel&quot; buffer shared by <i><u>both</u></i> the READ
	and the WRITE. There is an option to copy the READ data into the
	user space. Rather than copying, the same logic can be used for
	verifying one segment of data is the same as another segment of data
	(potentially on another disk). To do a verify, the SCSI WRITE
	command simply is replaced with the VERIFY command (with its BYTCHK
	field set to 1).</p>
	<li><p>add an extensible SG_SET_GET_EXTENDED <b>ioctl(2)</b> that
	takes a fixed size structure (96 byte). Some of that structure is
	currently not used to allow for later additions. It contains both
	integer (32 bit) and boolean fields. Multiple actions can be
	performed with a single call to <b>ioctl</b>( SG_SET_GET_EXTENDED).</p>
	<li><p>add single READ, multiple WRITE capability to the request
	sharing in the previous bullet. WRITEs may be to different devices
	(and are done sequentially and use the same in-kernel buffer). The
	WRITEs may be a subset of the read data and with the
	SGV4_FLAG_DOUT_OFFSET flag (value in sg_io_v4::<font color="#a3238e">spare_in</font>),
	it may start at any byte offset in the read buffer. Also <i>non</i><i>
	</i>data-moving SCSI commands may appear in this sequence. These
	commands may move data on the storage device, but <i>not</i> between
	the host computer and the storage device. Examples of potentially
	useful <i>non</i> data-moving SCSI commands are SYNCHRONIZE CACHE,
	PRE-FETCH and EXTENDED COPY.</p>
	<li><p>add multiple requests capability (<i>mrq</i>) in a single
	<b>ioctl</b>(SG_IO) or <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
	invocation. Can be combined with request sharing. Multiple
	<i>non-blocking</i> requests can use an <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
	call for submission while one or more <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
	calls can be used to receive the associated responses. Requests in
	the request array may use SGV4_FLAG_DO_ON_OTHER to take advantage of
	<i>file descriptor sharing</i>.</p>
	<li><p>add a SGV4_FLAG_IMMED flag for <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font><font color="#000000">)
	or </font><font color="#000000"><b>ioctl</b></font><font color="#000000">(</font>|<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>)
	[or <b>read</b>(2)] calls. This enables non-blocking mode making it
	equivalent to setting O_NONBLOCK on the associated file descriptor.
	May also be used on the control object given for multiple requests
	to either <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
	or <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>).</p>
	<li><p>add SGV4_FLAG_NO_WAITQ flag to skip using the wait queue. The
	<b>poll</b>(2) system command will not report such a request, but
	<b>ioctl</b>(SG_GET_NUM_WAITING) will. Signals, if armed, will still
	be produced.</p>
	<li><p>add bi-directional support with the sg V4 interface; async
	bidi uses new <b>ioctl</b>(2)s: <font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>
	and <font color="#a3238e">SG_IORECEIVE</font>, while sync bidi uses
	<b>ioctl</b>(<span style="font-weight: normal">SG_IO</span>).
	Unfortunately bidi SCSI command support has been removed from the
	Linux kernel in lk 5.1 so it has been removed from this driver to
	allow it to merge post lk 5.1 . It is still available as a patch on
	this driver when in kernels prior to that support being removed.</p>
	<li><p>use <b>ioctl</b>(SG_SET_GET_EXTENDED) to yield information
	that was previously &quot;hidden&quot; from the user space. For
	example return the sg device minor number (e.g. the &quot;3&quot; in
	/dev/sg3) of the sg device that owns the file descriptor the
	<b>ioctl</b>(2) is called on. 
	</p>
	<li><p>ioctl(SG_SET_GET_EXTENDED) can be used to change the segment
	size of scatter gather lists. In the v3 driver the segment size is
	fixed at 32 KB</p>
	<li><p>add <b>ioctl</b>(SG_IOABORT) to abort an inflight
	command/request using its pack-id or tag. Also allow a single call
	to abort all inflight and un-submitted requests associated wit a
	multiple requests invocation.</p>
	<li><p>add logic for tag handling and keep existing pack_id (packet
	id) logic which plays a similar role</p>
	<li><p>the <i>shared variable blocking</i> (svb) method of the
	multiple requests capability (<i>mrq</i>) is designed for large copy
	(and copy-like such as verify/compare) operations. While blocking
	the invoking user thread, it can issue a fixed number of READ
	commands (currently up to 8) asynchronously and as each read
	completes, its dependent WRITE command(s) is issued. <font color="#000000">There
	is a flag (SGV4_FLAG_ORDERED_</font><font color="#000000">WR</font><font color="#000000">)
	for additionally making sure that those WRITEs are issued in the
	same order as their READs, important </font><font color="#000000">when</font><font color="#000000">
	the destination of a copy is a ZBC (shingled) disk</font></p>
	<li><p>add support to pass a file descriptor generated by <b>eventfd</b>(2)
	to the driver via an <b>ioctl</b>(2). Another <b>ioctl</b>(2) can be
	used to remove the relationship between an eventfd and a sg file
	descriptor; this is optional and is needed, for example, if the user
	wants to associate a different eventfd to a sg file descriptor.
	Requests that have the SGV4_FLAG_EVENTFD in their flags increment
	the internal <i>count</i> maintained by the eventfd mechanism when
	that request reaches its internal completion point. See Figures 2
	and 4.</p>
	<li><p>while the order of responses (i.e. completions) picked up by
	a <i>mrq</i> <b>ioctl</b>(SG_IORECEIVE) can vary, the user can
	control <u>where</u> those responses are placed in response array.
	The user can also give a maximum number of responses that a <i>mrq</i>
	<b>ioctl</b>(SG_IORECEIVE) can receive.</p>
	<li><p>bump the driver version number to 4.0.46</p>
</ul>
<p>There are still some things to do:</p>
<ul>
	<li><p>allow some task management functions to be sent (when v4
	interface's subprotocol field is 1)</p>
	<li><p>extend debugfs support.</p>
</ul>
<h3 class="western"><a name="__RefHeading___Toc8274_3647010070"></a>2.1
Deprecated or removed features in version 4.0 compared to earlier
version</h3>
<p>Again these points are given in bullet form and overlap somewhat:</p>
<ul>
	<li><p>warn (once per kernel run in the log) that the sg version 1
	and version 2 interfaces are deprecated. Apart from version 3 and
	version 4 being better options, the version 1 and version 2
	interfaces rely solely on the <b>write</b>(2) and <b>read</b>(2)
	system calls sending a mix of user data and metadata which is
	frowned upon by security folks</p>
	<li><p>deprecate the use of  the <b>write</b>(2) and <b>read</b>(2)
	system calls in the version 3 interface. Again with a warning
	message  once per kernel run in the log. Using this driver upgrade
	supply <b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>) and
	<b>ioctl</b>(<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>)
	as &quot;drop in&quot; replacements.</p>
	<li><p>deprecate the use of 'echo 1 &gt; /proc/scsi/sg/allow_dio' as
	a prelude to doing <u>direct</u> IO with this driver. <u>Indirect</u>
	IO remains the default and the driver continues to require the
	SG_FLAG_DIRECT_IO flag on each request that the user wants to use
	<u>direct</u> IO.</p>
</ul>
<p>More to follow ....</p>
<h2 class="western"><a name="__RefHeading___Toc1538_4294551682"></a>3
SCSI Generic versions 1, 2, 3 and 4 interfaces</h2>
<p>SCSI and other storage related command sets send a lot of data to
storage devices and receive as much if not more data back from those
devices. That data can be subdivided into <i>metadata</i> and <i>user
data</i>. The SCSI metadata sent to the storage device is the <i>command</i>
which is sometimes referred to as the <i>cdb</i> (command descriptor
block). The metadata received back from the device is a SCSI <i>status</i>
byte and optionally a <i>sense</i> buffer of 18 or more bytes. More
generic terms for those transfers are the <i>request</i> and the
associated <i>response</i>. User data sent to the storage device is
termed as <i><u>data-out</u></i><u> </u>and user data received from
the device is called <i><u>data-in</u></i>. These two terms are
sometimes shorted to &quot;dout&quot; and &quot;din&quot;. A few SCSI
commands have both data-out and data-in transfers and are referred to
as <i>bi-directional</i> (or <i>bidi</i>) while the majority of SCSI
commands send user data either out or in, or transfer no user data.
The SCSI commands sets define where user data will be placed in, or
fetched from, the storage device but leave the details of where (and
how) that user data is placed in the initiator (i.e. at the computer
or local end) to the <i>transport</i>. Examples of transports are:
iSCSI, SAS, SATA, FCP, SRP (Infiniband) and USB (UASP).</p>
<p>Another aspect of a SCSI pass-through is whether to map the
sending of a request and receiving of the associated response onto a
<i>single</i> system call or divide it into <i>two</i> parts. The
single system call approach is termed here as <i>blocking</i> or
<i>synchronous</i>. The two part approach is termed as <i>non-blocking</i>
or <i>asynchronous</i>. Both approaches typically have an associated
timeout. It is assumed that any user data transfer associated with
the command will have taken place <i>before</i> a successful response
is sent by the storage device. As a general rule the blocking
approach is simpler to program while the non-blocking approach is
more flexible, allowing code to do other chores while waiting for
SCSI commands to complete.</p>
<p>Traditionally character device drivers in Unix have had a <b>open</b>(2),
<b>close</b>(2), <b>read</b>(2), <b>write</b>(2), <b>ioctl</b>(2)
interface to the user space. As well as those system calls this
driver supports <b>mmap</b>(2), <b>poll</b>(2) and fasync(). The
fasync() driver call is related to the <b>fcntl</b>(2) system call in
which the file descriptor flags may be changed to add O_AYSNC (e.g.
<b>fcntl</b>(SET_FL(flags | O_ASYNC)) ) . When considering how to
send SCSI commands and associated data to a pass-through driver such
as sg, it soon becomes evident that a structure will be needed to
hold all the components. This is the same approach used by other
operating systems that offer a SCSI pass-through interface. And in
the almost 30 years that Linux has been in existence, it has had
three (and a half) such structures.</p>
<p>The sg driver was present in Linux kernel 1.0.0 released in 1992.
It supported just two <b>ioctl</b>(2)s at the time: SG_SET_TIMEOUT
and SG_GET_TIMEOUT plus some &quot;pass-through&quot; <b>ioctl</b>(2)s
that started with &quot;SCSI_IOCTL_&quot; that were in common with
other ULDs (e.g. sd and st drivers) and implemented by the Linux SCSI
mid-level. The only method of sending a SCSI command by this driver
was with the async <b>write</b>(2) and <b>read</b>(2) system calls
(that neglects counting the synchronous &quot;pass-through&quot;
pass-through <b>ioctl</b>(2): SCSI_IOCTL_SEND_COMMAND implemented by
the SCSI mid-level). 
</p>
<p>The version 1 SCSI pass-through interface only supported the
asynchronous approach. This is its interface structure found in Linux
kernel 1.0.0 (1992):</p>
<pre class="western">struct sg_header
 {
  int pack_len;    /* length of incoming packet &lt;4096 (including header) */
  int reply_len;   /* maximum length &lt;4096 of expected reply */
  int pack_id;     /* id number of packet */
  int result;      /* 0==ok, otherwise refer to errno codes */
  /* command follows then data for command */
 };</pre><p>
Only the pack_id field is found in all versions of the sg driver
interface and its semantics remain the same. However there is an
issue with the pack_id and the <b>read</b>(2) system call: pack_id is
<i>out-going</i> data (to the driver in this case) while the rest of
the data in that structure (with possibly the data-in from the
storage device tacked onto the end) is <i>in-coming</i> data. This
bidirectional data flow is abnormal for a <b>read</b>(2) system call
which normally only expects in-coming data. It is of note that in the
version 4 driver the new <b>ioctl</b>(2) to replace <b>read</b>(2) is
<b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) and it is
defined with the __IOWR() macro indicating both a <i>write</i> (from
the user space) and a <i>read</i> (into the user space) data
transfer.</p>
<p>The version 2 SCSI pass-through interface structure is really just
a small extension of version 1:</p>
<pre class="western">struct sg_header {
        int pack_len;   /* [o] reply_len (ie useless), ignored as input */
        int reply_len;  /* [i] max length of expected reply (inc. sg_header) */
        int pack_id;    /* [io] id number of packet (use ints &gt;= 0) */
        int result;     /* [o] 0==ok, else (+ve) Unix errno (best ignored) */
        unsigned int twelve_byte:1;
            /* [i] Force 12 byte command length for group 6 &amp; 7 commands  */
        unsigned int target_status:5;   /* [o] scsi status from target */
        unsigned int host_status:8;     /* [o] host status (see &quot;DID&quot; codes) */
        unsigned int driver_status:8;   /* [o] driver status+suggestion */
        unsigned int other_flags:10;    /* unused */
        unsigned char sense_buffer[SG_MAX_SENSE];
};</pre><p>
There are various shortcoming of the version 2 (and hence version 1)
interface structure: the command (cdb), data-in, and/or data-out were
tacked onto the end of the interface structure. The command length
was not given explicitly but derived from the cdb making it difficult
to support vendor specific commands.</p>
<p>Since many of the field and constant names are the same or related
between the version 3 interface, the version 4 interface and the
control object use of the version 4 interface, three colours are used
to distinguish what is being referred to:</p>
<ul>
	<li><p><font color="#0066b3">blue</font>: associated with the
	version 3 interface</p>
	<li><p><font color="#a3238e">violet</font>: associated with the
	version 4 interface and, in the case of a multiple requests (<i>mrq</i>)
	invocation, associated with each element in the request (and
	response ) array</p>
	<li><p><font color="#006c3b">dark green</font>: associated with the
	<i>control object </i>of a multiple requests (<i>mrq</i>) invocation</p>
</ul>
<p>In some cases a field name is in two colours (two tone) to
indicate it applies to two of the above. Since very little reference
is made to the version 2 and version 1 interface fields, those names
are in the default text colour. The term flag (and as a verb) is used
often in a generic sense in which case it is not coloured; the same
applies to several other field names (e.g. timeout and duration).</p>
<p>The version 3 SCSI pass-through interface structure was introduced
around 2000 and was a departure from versions 1 and 2:</p>
<pre class="western">typedef struct sg_io_hdr {
        int <font color="#0066b3">interface_id</font>;       /* [i] 'S' for SCSI generic (required) */
        int <font color="#0066b3">dxfer_direction</font>;    /* [i] data transfer direction  */
        unsigned char <font color="#0066b3">cmd_len</font>;  /* [i] SCSI command length */
        unsigned char <font color="#0066b3">mx_sb_len</font>;/* [i] max length to write to sbp */
        unsigned short <font color="#0066b3">iovec_count</font>;     /* [i] 0 implies no sgat list */
        unsigned int <font color="#0066b3">dxfer_len</font>; /* [i] byte count of data transfer */
        /* dxferp points to data transfer memory or scatter gather list */
        void __user *<font color="#0066b3">dxferp</font>;    /* [i], [device -&gt; *i <i>or</i> *i -&gt; device] */
        unsigned char __user *<font color="#0066b3">cmdp</font>;/* [i], [*i] points to command to perform */
        void __user *<font color="#0066b3">sbp</font>;       /* [i], [*o] points to sense_buffer memory */
        unsigned int <font color="#0066b3">timeout</font>;   /* [i] MAX_UINT-&gt;no timeout (unit: millisec) */
        unsigned int <font color="#0066b3">flags</font>;     /* [i] 0 -&gt; default, see SG_FLAG... */
        int <font color="#0066b3">pack_id</font>;            /* [i-&gt;o] unused internally (normally) */
        void __user *<font color="#0066b3">usr_ptr</font>;   /* [i-&gt;o] unused internally */
        unsigned char <font color="#0066b3">status</font>;   /* [o] scsi status */
        unsigned char <font color="#0066b3">masked_status</font>;/* [o] shifted, masked scsi status */
        unsigned char <font color="#0066b3">msg_status</font>;/* [o] messaging level data (optional) */
        unsigned char <font color="#0066b3">sb_len_wr</font>; /* [o] byte count actually written to sbp */
        unsigned short <font color="#0066b3">host_status</font>; /* [o] errors from host adapter */
        unsigned short <font color="#0066b3">driver_status</font>;/* [o] errors from software driver */
        int <font color="#0066b3">resid</font>;              /* [o] dxfer_len - actual_transferred */
        /* unit may be nanoseconds after SG_SET_GET_EXTENDED ioctl use */
        unsigned int <font color="#0066b3">duration</font>;  /* [o] time taken by cmd (unit: millisec) */
        unsigned int <font color="#0066b3">info</font>;      /* [o] auxiliary information */
} sg_io_hdr_t;</pre><p>
Unused fields should be set to zero on input. It is recommended that
the whole sg v3 structure is zeroed (e.g. with memset()) prior to a
command request being built and submitted. Note that one of the
constants: SG_DXFER_NONE, SG_DXFER_TO_DEV or SG_DXFER_FROM_DEV should
be placed in the <font color="#0066b3">dxfer_direction</font> field
and they all have negative values (-1, -2 and -3 respectively). This
is used to differentiate between the v1/v2 interface (which has
reply_len in that position) and this (v3) interface.</p>
<p>The version 3 sg driver supported the version 1, 2 and 3 interface
structures. It introduced the blocking <b>ioctl</b>(SG_IO) while
keeping the <b>write</b>(2)/<b>read</b>(2) technique for asynchronous
usage. The blocking <b>ioctl</b>(SG_IO) has also been implemented in
the block layer for SCSI block devices (e.g. /dev/sdb) and in other
drivers such as the SCSI tape driver (st). So at this time the
version 3 interface structure together with <b>ioctl</b>(SG_IO) is
the most used SCSI pass-through in Linux. Over time there has been a
transfer of functionality from the <b>write</b>(2) and <b>read</b>(2)
system calls to various <b>ioctl</b>(2)s. Using the <b>write</b>(2)
and <b>read</b>(2) system calls in the way that this driver does is
frowned upon by the Linux kernel architects. Even though adding new
<b>ioctl</b>(2)s is also discouraged, two new <b>ioctl</b>(2)s were
proposed in this <a href="https://www.spinics.net/lists/linux-scsi/msg123031.html">post</a>
by Linux architect (L. Torvalds). Those two <b>ioctl</b>(2)s plus two
closely related <b>ioctl</b>(2)s have been implemented in this
upgrade.</p>
<p>Some weaknesses of the version 3 interface were that it had no
provision for bidirectional commands and that it included pointers.
Pointers in interface structures are problematic because they change
size when moving from 32 bit to 64 bit architectures (and that was a
big issue at the time). Also the version 3 interface was too SCSI
command set specific and could not easily pass related protocols such
as SCSI task management functions (TMFs) or the SAS Management
Protocol (SMP). So around 2005 the version 4 SCSI pass-through
interface structure was introduced:</p>
<pre class="western">struct sg_io_v4 {
        __s32 <font color="#a3238e">guard</font>;            /* [i] 'Q' to differentiate from v3 */
        __u32 <font color="#a3238e">protocol</font>;         /* [i] 0 -&gt; SCSI , .... */
        __u32 <font color="#a3238e">subprotocol</font>;      /* [i] 0 -&gt; SCSI command, 1 -&gt; SCSI task
                                   management function, .... */

        __u32 <font color="#a3238e">request_len</font>;      /* [i] in bytes */
        __u64 <font color="#a3238e">request</font>;          /* [i], [*i] {SCSI: cdb} */
        __u64 <font color="#a3238e">request_tag</font>;      /* [i] See <b>Table 1</b> entry */
        __u32 <font color="#a3238e">request_attr</font>;     /* [i] {SCSI: task attribute} */
        __u32 <font color="#a3238e">request_priority</font>; /* [i] {SCSI: task priority} */
        __u32 <font color="#a3238e">request_extra</font>;    /* [i-&gt;o] See <b>Table 1</b> entry */
        __u32 <font color="#a3238e">max_response_len</font>; /* [i] in bytes */
        __u64 <font color="#a3238e">response</font>;         /* [i], [*o] {SCSI: (auto)sense data} */

        /* &quot;dout_&quot;: data out (to device); &quot;din_&quot;: data in (from device) */
        __u32 <font color="#a3238e">dout_iovec_count</font>; /* [i] 0 -&gt; &quot;flat&quot; dout transfer else
                                   dout_xfer points to array of iovec */
        __u32 <font color="#a3238e">dout_xfer_len</font>;    /* [i] bytes to be transferred to device */
        __u32 <font color="#a3238e">din_iovec_count</font>;  /* [i] 0 -&gt; &quot;flat&quot; din transfer */
        __u32 <font color="#a3238e">din_xfer_len</font>;     /* [i] bytes to be transferred from device */
        __u64 <font color="#a3238e">dout_xferp</font>;       /* [i], [*i -&gt; device] */
        __u64 <font color="#a3238e">din_xferp</font>;        /* [i], [device -&gt; *i] */

        __u32 <font color="#a3238e">timeout</font>;          /* [i] units: millisecond */
        __u32 <font color="#a3238e">flags</font>;            /* [i] bit mask. See <b>Table 1</b> entry and <b>Table 2 </b>*/
        __u64 <font color="#a3238e">usr_ptr</font>;          /* [i-&gt;o] unused internally */
        __u32 <font color="#a3238e">spare_in</font>;         /* [i] See <b>Table 1</b> entry */

        __u32 <font color="#a3238e">driver_status</font>;    /* [o] 0 means ok */
        __u32 <font color="#a3238e">transport_status</font>; /* [o] 0 means ok */
        __u32 <font color="#a3238e">device_status</font>;    /* [o] {SCSI: command completion status} */
        __u32 <font color="#a3238e">retry_delay</font>;      /* [o] {SCSI: status auxiliary information} */
        __u32 <font color="#a3238e">info</font>;             /* [o] See <b>Table 1</b> entry and <b>Table 3</b> */
        __u32 <font color="#a3238e">duration</font>;         /* [o] time to complete, in milliseconds (or nanoseconds) */
        __u32 <font color="#a3238e">response_len</font>;     /* [o] bytes of response actually written */
        __s32 <font color="#a3238e">din_resid</font>;        /* [o] <font color="#a3238e">din_xfer_len</font> - actual_din_xfer_len */
        __s32 <font color="#a3238e">dout_resid</font>;       /* [o] <font color="#a3238e">dout_xfer_len</font> - actual_dout_xfer_len */
        __u64 <font color="#a3238e">generated_tag</font>;    /* [o] see <b>Table 1</b> entry */
        __u32 <font color="#a3238e">spare_out</font>;        /* [o] zero placed in this field */

        __u32 <font color="#a3238e">padding</font>;
};</pre><p>
Again, unused fields should be set to zero on input. The __s32 and
__u64 types could be replaced by the (more) standard int32_t and
uint64_t C types. The pointers are still there but are placed in
fixed length (64 bit) unsigned integers. All the other integer sizes
are fixed so that the structure is the same size on 32 and 64 bit
architectures. Between around 2005 and this upgrade, the version 4
interface structure was only used by the bsg driver which explains
why its interface structure is found in the &lt;linux/bsg.h&gt;
header file. The version 2 and version 3 interface structures are
found in the &lt;scsi/sg.h&gt; header file.</p>
<h3 class="western"><a name="__RefHeading___Toc1540_4294551682"></a>3.1
Comparison of fields in the v4 and v3 interfaces</h3>
<p>The following table has a row for each field in the version 4
interface structure. In the second column is the corresponding field
name from the version 3 interface structure. A field name in brackets
implies a close, but not exact match, see the notes in the third
column. No entry in the second column implies there is not matching
field in the version 3 interface structure.</p>
<table width="100%" cellpadding="4" cellspacing="0" style="background: transparent; page-break-after: avoid">
	<col width="30*"/>

	<col width="27*"/>

	<col width="199*"/>

	<thead>
		<tr bgcolor="#b3cac7" style="background: #b3cac7" valign="top">
			<th width="12%" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				v4 interface field</p>
			</th>
			<th width="11%" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				corresponding to in v3 interface</p>
			</th>
			<th width="78%" style="border: 1px solid #000000; padding: 0.1cm"><p>
				Notes</p>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">guard <font color="#000000">[io]</font></font></p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				[<font color="#0066b3">interface_id]</font> 
				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Both fields are the first in their respective structures and are
				assumed to be 32 bits each. The <font color="#a3238e">guard</font>
				for v4 is an ASCII 'Q' stored as an unsigned 32 bit integer. The
				<font color="#0066b3">interface_id</font> is an ASCII 'S' stored
				as a 32 bit integer. The difference between signed and unsigned
				is not important in this case.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">protocol <font color="#000000">[io]</font></font></p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				A value of '0' (a 32 bit integer) is used for all SCSI protocols</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">subprotocol <font color="#000000">[io]</font></font></p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				A value of '0' for SCSI commands sets based on SPC. The value '1'
				is reserved for SCSI Task Management Functions [TMFs] which are
				not implemented at this time.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">request_len <font color="#000000">[i]</font></font></p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">cmd_len</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Number of bytes in SCSI command. Since <font color="#0066b3">cmd_len</font>
				is an unsigned char (i.e. an 8 bit byte) the largest number it
				can represent is 255 in the v3 interface.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">request </font>[i, *o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">cmdp</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Like all pointers in the v4 interface, <font color="#a3238e">request</font>
				is a pointer value placed in a 64 bit unsigned integer. This is
				done to make the size of v4 interface constant (as long as
				pointers (by C definition able to fit in <font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">unsigned
				long</font></font>) fit in 64 bits). Conversely, <font color="#0066b3">cmdp</font>
				is a <i>pointer</i> so its size will very between 32 and 64 bit
				systems.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">request_tag </font>[i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Used if <b>ioctl</b>(SG_SET_FORCE_PACK_ID) third argument points
				to non-zero integer <u>and</u> SG_CTL_FLAGM_TAG_FOR_PACK_ID is
				set via the extended <b>ioctl</b>(2) on this file descriptor.
				This value is acted upon by <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
				and <b>ioctl</b>(SG_IOABORT).</p>
				<p>The <font color="#a3238e">generated_tag</font> is only written
				when <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
				completes. So the user space code needs to copy the contents of
				<font color="#a3238e">generated_tag</font> to this field to match
				by that tag value in a call to <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>).</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">request_attr </font>[i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				not currently used</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">request_priority </font>[i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				when the <font color="#006c3b"><b>SGV4_FLAG_</b></font><font color="#006c3b"><b>REC_ORDER</b></font>
				flag is set then the value in this field on submission is held
				with the request internally. If after completion <font color="#000000">this
				request</font> is read using ioctl(SG_IORECEIVE) with the
				<font color="#006c3b"><b>SGV4_FLAG_MULTIPLE_REQS</b></font> flag
				set then the value is used as an index into the response array to
				place its response.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">request_extra </font>[io]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">pack_id</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				A packet identifier of -1 is taken as a wildcard (i.e. match
				any). Twos complement is assumed for the 32 bit unsigned
				<font color="#a3238e">request_extra</font> so -1 becomes
				0xffffFFFF . Also used by <b>ioctl</b>(SG_IOABORT) for
				identification. In the v3 interface the submitted <font color="#0066b3">pack_id</font>
				is <font color="#000000">placed</font> in the async completion
				object. In the v4 interface the submitted <font color="#a3238e">request_extra</font>
				is placed in the async completion object. Both of these fields
				only <font color="#000000">change</font> the behaviour <font color="#000000">of
				a request</font> if <b>ioctl</b>(<b>SG_SET_FORCE_PACK_ID</b>) is
				active, otherwise they are just carried through to the completion
				object which is useful (along with <font color="#a3238e">usr_</font><font color="#0066b3">ptr</font>)
				in async usage.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">max_response_len </font>[i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">mx_sb_len</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				No more than this number of sense bytes will be written out
				starting at where <font color="#a3238e">response</font> points.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">response </font>[i, {*i},o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">sbp</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				A pointer to the sense buffer. Only used when the SCSI device
				yields sense data for the associated command. In the non-blocking
				case, the pointer value given to <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
				is used and any value given to <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
				is ignored and when that <b>ioctl</b>(2) returns this field will
				contain the original value in it. The note given for <font color="#a3238e">request</font>
				applies here also.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">dout_iovec_count </font>[i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				[<font color="#0066b3">iovec_count</font>]</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				If this field is zero then <font color="#a3238e">dout_xferp</font>
				(or <font color="#0066b3">dxferp</font>) points to user data to
				be written from the host to the storage device. If this field is
				non-zero, then it's the number of elements in the scatter gather
				list pointed to by <font color="#a3238e">dout_xferp</font> (or
				<font color="#0066b3">dxferp</font>). Kernels around lk 5.10
				limit this value to UIO_MAXIOV which is 1024.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">dout_xfer_len</font> [io]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				[<font color="#0066b3">dxfer_len</font>]</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This field is the number of bytes pointed to by <font color="#a3238e">dout_xferp</font>
				(or <font color="#0066b3">dxferp</font>). The data is (or will
				be) moved from the host to the SCSI device (e.g. a SCSI WRITE
				command)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">din_iovec_count </font>[i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				[<font color="#0066b3">iovec_count</font>]</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				If this field is <i>zero</i> then <font color="#a3238e">din_xferp</font>
				(or <font color="#0066b3">dxferp</font>) points to user data to
				be written from the host to the storage device. If this field is
				<i>non-zero</i>, then it's the number of elements in the scatter
				gather list pointed to by <font color="#a3238e">din_xferp</font>
				(or <font color="#0066b3">dxferp</font>). Kernels around lk 5.10
				limit this value to UIO_MAXIOV which is 1024.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">din_xfer_len</font> [io]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				[<font color="#0066b3">dxfer_len</font>]</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This field is the number of bytes pointed to by <font color="#a3238e">din_xferp</font>
				(or <font color="#0066b3">dxferp</font>). The data is (or will
				be) moved from the SCSI device to the host (e.g. a SCSI READ
				command).</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">dout_xferp </font>[i, *o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				[<font color="#0066b3">dxferp</font>]</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				If the <font color="#a3238e">dout_iovec_count</font> field is
				zero then this field points to the first byte to be transferred
				from the user space memory to the storage device. All the other
				bytes (indicated by <font color="#a3238e">dout_xfer_le</font><font color="#a3238e">n</font>)
				should follow the first byte with no gaps. If the
				<font color="#a3238e">dout_iovec_count</font> field is non-zero
				then this field points to a scatter gather list which the driver
				will use to output data from the user space to the storage
				device. The note given for <font color="#a3238e">request</font>
				applies here also.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">din_xferp </font>[i, *i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				[<font color="#0066b3">dxferp</font>]</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				If the <font color="#a3238e">din_iovec_count</font> field is zero
				then this field points to the first byte to be transferred from
				the storage device to the user space memory. All the other bytes
				(indicated by <font color="#a3238e">din_xfer_len</font>) should
				follow the first byte with no gaps. If the <font color="#a3238e">din_iovec_count</font>
				field is non-zero then this field points to a scatter gather list
				which the driver will use to read data from the storage device to
				the user space. The note given for <font color="#a3238e">request</font>
				applies here also.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">timeout </font>[i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">timeout</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p style="background: transparent">
				This is the number of milliseconds the SCSI mid level will wait
				for a command to finish before it attempts to abort that command.
				If zero is given, a driver default of SG_DEFAULT_TIMEOUT (60,000
				or 60 seconds) is chosen. Several SCSI commands (e.g. FORMAT UNIT
				with the IMMED bit cleared on a 10 Terabyte disk (hard disk or
				SSD)) take a lot longer than that. User manuals for disks often
				indicate how long such commands will take.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">flags </font>[io]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">flags</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This is a 32 bit integer in which the lower numbered bit
				positions are boolean flags. The available settings are listed in
				the &lt;include/uapi/scsi/sg.h&gt; header file. They start with
				SG_FLAG_ or SGV4_FLAG_ . See <b>Table 2</b> below. The two tone
				<font color="#0066b3">fla</font><font color="#a3238e">gs</font>
				field indicates either the v3 <font color="#0066b3">flags</font>
				field or the v4 <font color="#a3238e">flags</font> field.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">usr_ptr </font>[io]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">usr_ptr</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				The driver does not use this value. Whatever pointer value that
				is placed in <font color="#a3238e">usr_ptr</font> will be sent
				back to the user space after the command has completed. This may
				be useful in async (non-blocking) code when the submission and
				completion are separated (e.g. in different threads). Whenever
				multiple submissions are outstanding, the order of completion is
				up to the storage device. The note given for <font color="#a3238e">request</font>
				applies here also.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">spare_in</font> [i]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				when the <b>SGV4_FLAG_DOUT_OFFSET</b><span style="font-weight: normal">
				flag is set, this field holds the data-out (dout) byte offset. It
				is </span><span style="font-weight: normal">main</span><span style="font-weight: normal">ly
				used on the </span><font color="#000000"><u><span style="font-weight: normal">write-</span></u></font><u><span style="font-weight: normal">side</span></u><span style="font-weight: normal">
				(typically a WRITE command) of a share request.</span><span style="font-weight: normal">
				This byte offset is applied to the in-kernel buffer from the
				preceding </span><font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font><span style="font-weight: normal">
				command</span><span style="font-weight: normal"> </span><span style="font-weight: normal">and
				the copy (DMA) out to the </span><font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font><span style="font-weight: normal">
				device will be </span><font color="#a3238e"><span style="font-weight: normal">dout_xfer_len</span></font><span style="font-weight: normal">
				bytes long. </span><span style="font-weight: normal">If this
				offset plus  </span><font color="#a3238e"><span style="font-weight: normal">dout_xfer_len</span></font><font color="#a3238e"><span style="font-weight: normal">
				</span></font><span style="font-weight: normal">will exceed</span><span style="font-weight: normal">
				the in-kernel buffer</span><span style="font-weight: normal">
				size then the request will fail with an errno of E2BIG</span><span style="font-weight: normal">.</span></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">driver_status </font>[o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">driver_status</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. Zero indicates no errors.
				These are not so much sg driver errors as errors from the SCSI
				mid-level. The possible values are listed in the
				&lt;include/scsi/scsi.h&gt; header and they start with DRIVER_ .
				If <font color="#a3238e">driver_status</font> is non-zero then
				SG_INFO_CHECK is set in the <font color="#0066b3">in</font><font color="#a3238e">fo</font>
				field.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">transport_status </font>[o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">host_status</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. Zero indicates no errors.
				These are not so much sg driver errors as errors from a SCSI Low
				Level Driver (LLD) typically controlling a Host Bus Adapter
				(HBA). The possible values are listed in the
				&lt;include/scsi/scsi.h&gt; header and they start with DID_ . If
				<font color="#a3238e">transport_status</font> is non-zero then
				SG_INFO_CHECK is set in the <font color="#0066b3">in</font><font color="#a3238e">fo</font>
				field.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">device_status </font>[o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">status</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. Zero indicates no errors.
				This is the 8 bit SCSI Status returned in response to all SCSI
				commands (unless they time out). The possible values are listed
				in the &lt;include/scsi/scsi_proto.h&gt; header and they start
				with SAM_STAT_ . The SCSI status SAM_STAT_CONDITION_MET is
				non-zero but is not an error; any other non-zero value is an
				error and will cause SG_INFO_CHECK to be set in the <font color="#0066b3">in</font><font color="#a3238e">fo</font>
				field.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">retry_delay</font> [o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				not currently used. Zero is output by the driver in this field.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">info </font>[o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">info</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. This value contains boolean
				flags OR-ed together. The possible flags are listed in the
				&lt;include/uapi/scsi/sg.h&gt; and they start with SG_INFO_ . See
				<b>Table 3</b>.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">duration </font>[o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">duration</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. It is the time between when a
				command is issued to the block layer until the <i>internal
				completion point</i> occurs. By default the unit is milliseconds,
				however if SG_CTL_FLAGM_TIME_IN_NS is set in the extended
				<b>ioctl</b>(2) on this file descriptor then the unit is
				nanoseconds.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">response_len </font>[o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">sb_len_wr</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. This is the length of the
				sense buffer (i.e. the response) that is returned from the
				storage device. This usually indicates something has gone wrong
				with the command. A value of 0 indicates there is no sense buffer
				and the storage device has most likely successfully completed the
				command. Due to caches in storage devices WRITEs may initially
				report success and later report a &quot;deferred error&quot;. If
				<font color="#a3238e">response_len</font> is greater than zero
				then SG_INFO_CHECK is set in the <font color="#0066b3">in</font><font color="#a3238e">fo</font>
				field.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">din_resid</font> [o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3">resid</font></p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. The value is <font color="#a3238e">din_xfer_len</font>
				less the number of bytes actually transferred in from the storage
				device.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">dout_resid</font> [o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. The value is <font color="#a3238e">dout_xfer_len</font>
				less the number of bytes actually transferred out to the storage
				device.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">generated_tag</font> [o ***]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This value is output by the driver. Zero will be placed in this
				field unless the SGV4_FLAG_YIELD_TAG flag is one of the flags set
				in the <font color="#0066b3">fla</font><font color="#a3238e">gs</font>
				field in a call to <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>).
				In this case, the block layer's tag value is placed there. 
				</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="12%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e">spare_out</font> [o]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="78%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Zero is placed in this field except for the control object of 
				multiple requests (see below).</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 1: sg v4 interface
structure compared with v3</b></font></p>
<p><span style="text-decoration: none">Unused fields should be set to
zero on input</span>. It is recommended that the whole sg_io_v4
structure is zeroed (e.g. with memset() ) prior to a command request
being built and submitted. In the first column of the above table,
the &quot;i&quot; and &quot;o&quot; indications within the square
brackets are in some cases expansions on what is shown in the
sg_io_v4 structure definition comments above the table. Those with
&quot;i&quot; should be set (or left as zero) <i>before</i> a call to
<b>ioctl</b>(SG_IO) or <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>),
Those with &quot;o&quot; will in some cases be set by this driver and
can be <i>checked after</i> a call to <b>ioctl</b>(SG_IO) or
<b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>). The &quot;*o&quot;
indicates a pointer being used as the source starting address to copy
data from the user space to the driver and often on to a storage
device. The &quot;*i&quot; indicates a pointer being used as the
destination starting address to copy data from a storage device into
the user space. This level of detail becomes more important when a
request is split between a <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
and a <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>). Some
input values (e.g. <font color="#a3238e">din_xfer_len</font>) are
copied to the output as a convenience (e.g. to help in this
calculation: (<font color="#a3238e">din_xfer_len</font> - <font color="#a3238e">din_resid</font>)
which is the number of bytes actually read). The &quot;[o ***]&quot;
indication notes the special case of <font color="#a3238e">generated_tag</font>
whose value is output after <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>),
all other output values (and <font color="#a3238e">generated_tag</font>
itself) are output after <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
has completed.</p>
<p>The square brackets in the second column of the above table
implies the v3 interface field is similar to, but not exactly the
same as, the v4 interface field.</p>
<p>Note that multiple requests (in one invocation) use an instance of
the same sg_io_v4 structure as its <i>control object</i>. Most fields
have a different, but related, meaning when they are in a control
object. A control object is distinguished by having the
SGV4_FLAG_MULTIPLE_REQS flag set. Multiple requests are described in
a later <a href="#10 Multiple requests|outline">section</a>.</p>
<h3 class="western"><a name="__RefHeading___Toc1542_4294551682"></a>3.2
Flags in v3 and v4 interfaces</h3>
<p>The following table lists the flag values that can be OR-ed
together and placed in the <font color="#0066b3">fla</font><font color="#a3238e">gs</font>
field. The are listed in numerical order of their values (shown in
hex within square brackets). Where two names map to the same value,
the preferred name is in boldface. The older flags (i.e. inherited
from the version 3 driver) tend to have lower values.</p>
<table width="100%" cellpadding="4" cellspacing="0" style="background: transparent; page-break-after: avoid">
	<col width="63*"/>

	<col width="193*"/>

	<thead>
		<tr bgcolor="#81aca6" style="background: #81aca6" valign="top">
			<th width="25%" style="background: transparent" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<span style="background: transparent">Flag name [hex_value]</span></p>
			</th>
			<th width="75%" style="background: transparent" style="border: 1px solid #000000; padding: 0.1cm"><p>
				<span style="background: transparent">Description</span></p>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				SG_FLAG_DIRECT_IO [0x1]</p>
				<p><b>SGV4_FLAG_DIRECT_IO</b></p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				The default action of this driver is to &quot;bounce&quot; data
				through kernel buffers en route to or from the user space. This
				is sometimes referred to as &quot;indirect&quot; IO. This is
				obviously inefficient but is very flexible. Among other reasons,
				memory in a user space needs to be &quot;pinned&quot; during a
				direct IO data transfer because a user space process can be
				killed at any time (e.g. by a superuser or the OOM killer) seen
				from the driver's perspective. Another issue with direct IO is
				that the user space buffer must meet whatever alignment
				requirements the storage HBA imposes. Most alignment problems can
				avoided by the user allocating buffers with
				memalign(_SC_PAGESIZE, num_blks * lbs) where lbs is the logical
				block size (in bytes) of the storage device.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				SG_FLAG_UNUSED_LUN_INHIBIT [0x2]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<b>Ignored</b>. This is a remnant from SCSI-2 in which bits 7, 6
				and 5 of byte 1 of many cdb_s carried the 3 bit LUN value. If
				SCSI 2 equipment is being used, the cdb can be altered explicitly
				to carry the LUN address.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				SG_FLAG_MMAP_IO [0x4]</p>
				<p><b>SGV4_FLAG_MMAP_IO</b></p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This is another &quot;direct&quot; IO capability in which the
				user space buffers are obtained by <b>mmap</b>(2) system calls.
				The driver arranges for user data to be transferred directly
				between the user space and the storage device. Since the driver
				provides the buffer pointer returned by mmap(2), then it is
				guaranteed to meet any alignment (and page pinning) requirements.
				This flag cannot be given with <b>SGV4_FLAG_DIRECT_IO</b> <span style="font-weight: normal">as
				they are basically different ways of doing the same thing. Note
				that request sharing is a faster way of doing a disk-to-disk copy
				compared to using this flag for several reasons, one being that
				with this flag two &quot;mmap-ed&quot; buffers must be used (for
				the source and destination of the copy) and the user code must
				copy the data between those two buffers.</span><span style="font-weight: normal">
				See section on <a href="#4.2 Direct, mmap()-ed IO and bio_s|outline">mmap</a>
				below.</span></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_YIELD_TAG</b> [0x8]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag may be used with <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>).
				If that <b>ioctl</b>(2) does not return an error then a tag value
				will be placed in the <font color="#a3238e">generated_tag</font>
				field of the object pointed to by the <b>ioctl's</b> third
				argument. If the tag value (obtained from the block subsystem) is
				not available then -1 (or 0xffffFFFF) is placed in the
				<font color="#a3238e">generated_tag</font> field.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				SG_FLAG_Q_AT_TAIL [0x10]</p>
				<p><b>SGV4_FLAG_Q_AT_TAIL</b></p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This will place the current request/command at the tail (end) of
				the block system's queue of commands for the current device. For
				historical reasons, the driver default is to place the current
				request/command at the head (start) of the block system's queue.
				One rationale for this as that admin commands (e.g. INQUIRY and
				MODE SELECT) show take precedence over normal (data moving)
				commands. The driver default can first be overridden on a per
				file descriptor basis with the extended
				<b>ioctl</b>(SG_CTL_FLAGM_Q_TAIL). Then the per device setting
				can be overridden on a per request/command setting with this or
				the following flag.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				SG_FLAG_Q_AT_HEAD [0x20]</p>
				<p><b>SGV4_FLAG_Q_AT_HEAD</b></p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This will place the current request/command at the head (start)
				of the block system's queue of commands for the current device.
				See the <b>SGV4_FLAG_Q_AT_TAIL </b><span style="font-weight: normal">flag
				for more details.</span></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_NO_WAITQ</b> <span style="font-weight: normal">[0x40]</span></p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<span style="font-weight: normal">With this flag, t</span><span style="font-weight: normal">he
				</span><i><span style="font-weight: normal">internal completion
				point</span></i> <span style="font-weight: normal">of a request
				does </span><u><span style="font-weight: normal">not</span></u>
				<span style="font-weight: normal">invoke wake_up() on the file
				descriptor's wait_queue (hence this flag's name). This means that
				it is pointless </span><i><span style="font-weight: normal">waiting</span></i>
				<span style="font-weight: normal">for this request's completion</span><span style="font-weight: normal">
				using standard Linux system calls</span><span style="font-weight: normal">.
				</span><span style="font-weight: normal">These include</span> <span style="font-weight: normal">the
				</span><b>poll</b><span style="font-weight: normal">(2) </span><span style="font-weight: normal">
				and </span><b>select</b><span style="font-weight: normal">(2)
				</span><span style="font-weight: normal">system command</span><span style="font-weight: normal">s</span><span style="font-weight: normal">;</span><span style="font-weight: normal">
				</span><span style="font-weight: normal">the same applies to the
				</span><b>epoll</b><span style="font-weight: normal">(7)
				mechanism since they all rely on the wait_queue</span><span style="font-weight: normal">.
				</span><span style="font-weight: normal">So the user space is
				restricted to using</span><span style="font-weight: normal"> sg
				driver facilities:</span><span style="font-weight: normal">
				</span><b>ioctl</b><span style="font-weight: normal">(SG_GET_NUM_WAITING),
				</span><b>ioctl</b><span style="font-weight: normal">(SG_GET_PACK_ID)
				and </span><b>ioctl</b><span style="font-weight: normal">(</span><font color="#a3238e"><span style="font-weight: normal">SG_IORECEIVE</span></font><span style="font-weight: normal">)</span>
				<span style="font-weight: normal">with the </span><b>SGV4_FLAG_</b><b>IMMED</b><span style="font-weight: normal">
				flag set.</span><span style="font-weight: normal"> When
				</span><b>SGV4_FLAG_</b><font color="#000000"><b>HIPRI</b></font><span style="font-weight: normal">
				is used there is no need to use this flag as it is implied. For
				async usage this flag should cause the application to &quot;poll&quot;
				with </span><b>ioctl</b><span style="font-weight: normal">(SG_GET_NUM_WAITING)
				for completion.</span></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_DOUT_OFFSET</b> [0x80]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this flag is only active with the v4 interface and reads the
				&quot;dout&quot; (typically a WRITE command) byte offset from
				sg_io_v4::<font color="#a3238e">spare_in</font> . The request
				with this flag is assumed to be the <font color="#000000"><u>write-side</u></font>
				request (e.g. a WRITE command) following a <font color="#000000"><u>read-side</u></font>
				request that has populated an in-kernel buffer maintained by the
				driver. That byte offset will become the starting address within
				that in-kernel buffer for the DMA out to the <font color="#000000"><u>write-side</u></font>
				device.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_COMPLETE_B4</b> [0x100] ^^</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag is only permitted within an array of requests given
				with a multiple request invocation (<i>mrq</i>). It instructs the
				driver to wait for the completion of the current request <i>before</i>
				(&quot;B4&quot;) submitting the next request in the array of
				requests.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_SIG</b><b>NAL</b> [0x200] ^^</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				For v3 headers, this flag is ignored. For version 4 this flag is
				only permitted within an array of requests given with a multiple
				request invocation.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_IMMED</b> [0x400]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag uses &quot;IMMED&quot; in the same <font color="#000000">fashion</font>
				as various SCSI commands (e.g. FORMAT UNIT) do, where it means:
				check the request and if it is good, start whatever and then
				return as promptly as possible. The significant part here is that
				it doesn't wait for whatever to c<i>omplete</i>. It can be used
				with the version 3 and 4 interfaces, including the <i>mrq</i>
				<i>control object</i>.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_</b><font color="#000000"><b>HIPRI</b></font> 
				[0x800]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				The associated request will have REQ_HIPRI set when issued to the
				block layer. The completion handling will use blk_poll() instead
				of waiting for an event or classic polling (i.e. via the Unix
				<b>poll</b>(2) or Linux <b>epoll</b>(2) system calls). See the
				section on <a href="#12 iopoll/blk_poll() support|outline">iopoll/blkpoll</a>
				below.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b"><b>SGV4_FLAG_STOP_IF</b></font> [0x1000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag is only permitted in the <i>control object</i> with
				some methods of multiple request invocation. Basically if an
				<i>internal completion point</i> reports an error then further
				submissions will not occur. All submissions prior to the one with
				the detected error will be processed as normal and that may
				require action by the user space code. In the response array, all
				requests that have been processed at the <i>internal completion
				point</i> have SG_INFO_MRQ_FINI OR-ed into their <font color="#a3238e">info</font>
				field</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_DEV_SCOPE</b> [0x2000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this flag is currently only used by <b>ioctl</b>(SG_IOABORT).
				Without this flag that <b>ioctl</b>(2) will only look at the
				<i>given</i> file descriptor for a match on pack_id or tag. In
				practice a request may need to be aborted when a call like
				<b>ioctl</b>(SG_IO) takes an unreasonable amount of time to
				finish, suggesting that something is wrong. Often the file
				descriptor associated with the <b>ioctl</b>(SG_IO) is locked up
				in a process that is not responding. When this flag is given,
				after the <b>ioctl</b>(SG_IOABORT)'s own file descriptor is
				checked first and if no match is found, then all other sg file
				descriptors belonging to the <u>same</u> sg device (hence &quot;device
				scope&quot;) are checked and the first request found matching the
				given pack_id or tag is aborted. Also has the same action with a
				<i>mrq</i> abort. Use with care.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_SHARE</b> [0x4000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag indicates <i>request sharing</i>. Such requests usually
				occur in pairs. It can only be used with a file descriptor which
				is either the <font color="#000000"><u>read-side</u></font>, or
				the <font color="#000000"><u>write-</u></font><u>side</u> of a
				<i>file share</i> which has already been set up. If it is the
				<font color="#000000"><u>read-</u></font><u>side</u> then the
				command must be a READ or READ-like SCSI command (i.e. gets
				data-in from the storage device). If it is the <font color="#000000"><u>write-</u></font><u>side</u>
				then the command must be a WRITE or WRITE-like SCSI command (i.e.
				sends data-out to the storage device).</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_DO_ON_OTHER</b> 0x8000 ^^</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag is <i>only</i> permitted within an array of requests
				given with a <i>mrq</i> invocation.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				SG_FLAG_NO_DXFER [0x10000]</p>
				<p><b>SGV4_FLAG_NO_DXFER</b></p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				With indirect IO, data is &quot;bounced&quot; through a kernel
				buffer as it passes from user space memory to the storage device
				(or vice versa). This flag instructs the driver <u>not</u> to do
				the portion of the copy between the kernel buffers and user
				memory. There are several cases where this is useful. It is used
				on WRITE side of request sharing because the data to be written
				is already sitting in that kernel buffer (placed there by the
				preceding READ). Another case is when data is mirrored on two
				disks, it only needs to be actually read back from one of the
				disks, but it may be a good idea to read it back from the other
				disk at the same time to see if a MEDIUM ERROR is reported (which
				would indicate the mirror is no longer safe). If the data is not
				going to be compared, then the second READ could use this flag.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_KEEP_SHARE</b> [0x20000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				the default action of this driver is to &quot;free up&quot; a
				reserve request buffer after the <font color="#000000"><u>write-side</u></font>
				request (typically a WRITE command) in a <font color="#000000">read-write</font>
				request share. When this flag is applied to a <font color="#000000"><u>write-side</u></font>
				request, than it can be followed by another <font color="#000000"><u>write-side</u></font><u>
				</u>request which will use the same in-kernel buffer from the
				preceding <font color="#000000"><u>read-side</u></font> request.
				The last <font color="#000000"><u>write-side</u></font> request
				(e.g. in a READ-WRITE-WRITE-WRITE sequence) should not have this
				flag set. The last request in a multiple request array must not
				have this flag set (or an -ERANGE error will result).</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b"><b>SGV4_FLAG_MULTIPLE_REQS</b></font>
				[0x40000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag can only be used on a sg v4 interface object and
				indicates that this object is a <i>control object</i> for
				multiple requests (<i>mrq</i>).</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SGV4_FLAG_EVENTFD</b>  [0x80000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Assuming the eventfd has been set up on this file descriptor,
				then at the completion of the associated request that eventfd is
				signalled. This increments the internal count that can be
				accessed with <b>read</b>(eventfd, buff, 8). See <b>ioctl</b>(sg_fd,
				SG_SET_GET_EXTENDED( <span style="font-weight: normal">SG_SEIM_</span><span style="font-weight: normal">EVENTFD</span><span style="font-weight: normal">),
				...) below, for how the user space passes a</span><span style="font-weight: normal">n</span><span style="font-weight: normal">
				eventfd </span><span style="font-weight: normal">to this driver.</span></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b"><b>SGV4_FLAG_</b></font><font color="#006c3b"><b>ORDERED_</b></font><font color="#006c3b"><b>WR</b></font>
				[0x100000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Only used by <i>shared variable blocking</i> method. Requires
				that <font color="#000000"><u>write-side</u></font> commands are
				issued in the same order as the <font color="#000000"><u>read-side</u></font>
				commands they are paired with. <font color="#000000"><u>Read-side</u></font>
				commands are issued in the order they appear in the command array
				which is supplied by the user.</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="25%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b"><b>SGV4_FLAG_</b></font><font color="#000000"><b>REC_ORDER</b></font>
				[0x200000]</p>
			</td>
			<td width="75%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				This flag can be used either on a <i>control object</i> or a
				normal sg v4 object (hence the two colours). Allows the order in
				the response array to be specified. There is a later subsection
				on the use of this flag.</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 2: The <font color="#0066b3">fla</font><font color="#a3238e">gs</font>
field in the v3 and v4 interface structures</b></font></p>
<p>The constants marked with &quot;^^&quot; can only be used within
the request array given to a multiple requests (<i>mrq</i>)
invocation. Further, those constants ending with &quot;_ON_OTHER&quot;
are only valid if a file share has already be set up which contains
the file descriptor in the first argument of the <b>ioctl</b>(2). The
<font color="#0066b3">fla</font><font color="#a3238e">gs</font> field
is always an input to the driver; the corresponding field used by the
driver to communicate with the user space when an <b>ioctl</b>(2) is
finished is the <font color="#0066b3">in</font><font color="#a3238e">fo</font>
field.</p>
<h3 class="western"><a name="__RefHeading___Toc1544_4294551682"></a>3.3
The info field</h3>
<p>The driver writes the <font color="#0066b3">in</font><font color="#a3238e">fo</font>
field to the user space as part of the sg version 3 and 4 interface
objects. This occurs after <b>ioctl</b>(SG_IO), <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
and <b>ioctl</b>(<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>).
The <font color="#0066b3">in</font><font color="#a3238e">fo</font>
field conveys additional information back to the user space not
necessarily associated with error conditions . Like the <font color="#0066b3">fla</font><font color="#a3238e">gs</font>
field, the <font color="#0066b3">in</font><font color="#a3238e">fo</font>
field contains flag values that may be OR-ed together. They are
listed in the table below in numerical order.</p>
<table width="100%" cellpadding="4" cellspacing="0" style="background: transparent; page-break-after: avoid">
	<col width="67*"/>

	<col width="189*"/>

	<tr bgcolor="#81aca6" style="background: #81aca6" valign="top">
		<th width="26%" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			info field [hex value]</p>
		</th>
		<th width="74%" style="border: 1px solid #000000; padding: 0.1cm"><p>
			Notes</p>
		</th>
	</tr>
	<tr valign="top">
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>SG_INFO_CHECK</b> [0x1]</p>
		</td>
		<td width="74%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			an error has probably occurred, check the other error fields and
			the sense buffer (if its returned length &gt; 0)</p>
		</td>
	</tr>
	<tr valign="top">
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>SG_INFO_DIRECT_IO</b> [0x2]</p>
		</td>
		<td width="74%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			even when the SGV4_FLAG_DIRECT_IO flag is given, if certain
			condition are not met then the simpler indirect IO may be
			performed instead. When this info field is received it's a case
			of: you asked for it, you got it. If this flag is not present then
			indirect (or mmap-ed) IO took place.</p>
		</td>
	</tr>
	<tr valign="top">
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>SG_INFO_DEVICE_DETACHING</b> [0x8]</p>
		</td>
		<td width="74%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			This should not happen very often but when it does, it means what
			it says.</p>
		</td>
	</tr>
	<tr valign="top">
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>SG_INFO_ABORTED</b> [0x10]</p>
		</td>
		<td width="74%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			This request/command has been aborted. If it was a data-in type
			command then no data is returned to the user space. Seen from the
			driver's perspective it is indeterminate whether the device
			executed the command or not. If the aborted command changed the
			state of the SCSI device (e.g. with MODE SELECT) then the user
			should issue further commands to check what happened on the
			device.</p>
		</td>
	</tr>
	<tr valign="top">
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>SG_INFO_MRQ_FINI</b> [0x20]</p>
		</td>
		<td width="74%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			this command, which is assumed to be one of an array of sg_io_v4
			objects given in a multiple requests invocation (<i>mrq</i>), has
			completed processing. This is important to know when there are
			errors or <i>mrq</i> abort is called.</p>
		</td>
	</tr>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 3: The <font color="#0066b3">in</font><font color="#a3238e">fo</font>
field in the v3 and v4 interface structures</b></font></p>
<p>The last three <font color="#0066b3">in</font><font color="#a3238e">fo</font>
values are new in this driver update.</p>
<h2 class="western"><a name="__RefHeading___Toc1546_4294551682"></a>4
Architecture of the sg driver</h2>
<p>The Linux SCSI subsystem is made up of three parts: several upper
level drivers (ULDs), one mid level, and multiple low level drivers
(LLDs). The upper level drivers are divided up by the type of SCSI
device: for disks the ULD is <b>sd</b>, for tape (drives) the ULD is
<b>st</b>, for DVD/CDROMs the ULD is <b>sr</b>, for enclosures the
ULD is <b>ses</b>. In most contexts the <b>sg</b> driver is
considered a ULD, however in one context: when a LLD or user sets the
no_uld_attach flag (see include/scsi/scsi_device.h), then that device
<u>is</u> attached (i.e. receives an sg device node of the form
/dev/sg&lt;n&gt; (where &lt;n&gt; is an integer starting at 0)) to
the <b>sg</b> driver but to no <u>other</u> ULD. The SCSI devices
attached to the sg driver may be thought of as the union of the
devices from all the other ULDs plus any devices that don't have a
type specific ULD supported such as a PROCESSOR DEVICE type used for
managing enclosures using the SAFTE protocol. The mid-level maintains
interfaces for both ULDs and LLDs and provides services such as
device discovery, device teardown (e.g. at shutdown or suspend) and
error processing. LLDs typically manage SCSI hardware (often call
Host Bus Adapters (HBAs)) or bridge to another protocol stack (e.g.
USB attached SCSI (<font color="#000000">UAS</font>, also known as
UASP in USB standards)).</p>
<p>One difficulty faced when using this driver is knowing what is the
mapping between the type-specific ULD (e.g. /dev/sdc) on the
corresponding sg driver device name (e.g. /dev/sg2). The information
to solve this can be found in sysfs (under the /sys/class directory)
but can be a little tedious to follow. The lsscsi utility shows this
information in tabular form but does not show sg devices by default.
To see the type specific ULD device name and the corresponding sg
device name on the same lines use 'lsscsi -g'. The author often uses
'lsscsi -gs' which additionally shows the device size (if it has a
storage size). For mapping between the primary ULD device name and
the sg device name with the least clutter 'lsscsi -gb' may help. Note
that there is no ioctl() provided by this driver to show that
mapping; it has been proposed but rejected as an encapsulation
violation. In the following example /dev/sg3 and /dev/sg4 are
actually enclosures but the ULD module to support them (i.e. <b>ses</b>)
has not been built into the kernel; the last entry is a NVMe
namespace which does not have a corresponding sg device name hence
the trailing &quot;-&quot;.</p>
<pre class="western"># lsscsi -gb
[4:0:0:0]    /dev/sda   /dev/sg0 
[6:0:0:0]    /dev/sdb   /dev/sg1 
[6:0:1:0]    /dev/sdc   /dev/sg2 
[6:0:2:0]    -          /dev/sg3 
[6:0:3:0]    -          /dev/sg4 
[7:0:0:0]    /dev/sdd   /dev/sg5 
[7:0:0:1]    /dev/sde   /dev/sg6
[N:0:1:1]    /dev/nvme0n1  -</pre><p>
<br/>
<br/>

</p>
<p>One can verify the equivalence between a primary ULD device and a
sg device by issuing a SCSI INQUIRY command for the Device
Identification VPD page [0x83] to both and comparing the results. All
SCSI devices (and those that translate the SCSI command set) support
<b>ioctl</b>(SG_IO) version 3 interface. For example
<b>ioctl</b>(<b>open</b>(&quot;/dev/sdd&quot;, O_RDWR), SG_IO,
&amp;a_sg_io_hdr)) and <b>ioctl</b>(<b>open</b>(&quot;/dev/sg5&quot;,
O_RDWR), SG_IO, &amp;b_sg_io_hdr)) can be issued with appropriate 
a_sg_io_hdr and  b_sg_io_hdr objects; then the standard library
<b>memcmp</b>() function can be used to compare the data-in buffers
returned by those <b>ioctl</b>()s.</p>
<p>Moving onto the sg driver itself: nothing much has changed in the
overall architecture of the sg driver between version 3 (v3)
documented earlier, and version 4 (v4). Having a pictorial summary of
the driver's object tree may help later explanations:</p>
<img src="sg_v40_html_3b11aa447de06759.png" name="Image9" align="left" width="794" height="559">
  <br clear="left"/>
</img>

<p align="left" style="margin-left: 7.5cm; font-style: normal"><b>Figure
1: sg driver object tree</b></p>
<p>The sg driver is shown with a laptop icon at the top of the object
tree. The arrow end of <i>solid</i> lines shows objects that are
created automatically or by actions <i>outside</i> the user interface
to the sg driver. So the disk-like <font color="#000000">icons</font>
created at the second level come from the device scanning logic
undertaken by the SCSI mid-level driver in Linux. Note that there are
SCSI devices other than disks such as tape units and SCSI enclosures.
Also note that not all storage devices in Linux use the SCSI
subsystem, examples of these are NVME SSDs and SD cards that are <i>not</i>
attached via USB. The type of SCSI device objects is <font color="#6b6400">sg_device</font>
(and in the driver code they appear as objects of C type 'struct
sg_device'). Even though the sg driver's implementation is closely
associated with the block subsystem, the sg driver's device nodes are
<i>character devices</i> in Linux (e.g. /dev/sg1). The nodes are also
known as <i>character special devices</i>.</p>
<p>At the third level are file descriptors which the user creates via
the <b>open</b>(2) system call (e.g. 'sg_fd = <b>open</b>(&quot;/dev/sg1&quot;,
O_RDWR);') . Various other system calls such as <b>close</b>(2),
<b>write</b>(2), <b>read</b>(2), <b>ioctl</b>(2) and <b>mmap</b>(2)
can use that file descriptor made by <b>open</b>(2). The file
descriptor will stay in existence until the process containing the
code that opened it exits or the user closes it (e.g.
'<b>close</b>(sg_fd);'). A <i>dotted</i> line is shown from the
&quot;owning&quot; device to each file descriptor in order to
indicate that it was created by <i>direct</i> user action via the sg
interface. The type of file descriptor objects is <font color="#6b6400">sg_fd</font>.
BTW most system calls have &quot;man pages&quot; and the form <b>open</b>(2)
indicates that there is a manpage in section 2 describing the open
system call. Common manpage sections are &quot;1&quot; for commands
and utilities (e.g. 'man 1 cp' explaining the copy command); &quot;2&quot;
for system calls; &quot;3&quot; for functions found in system
libraries (e.g. 'man 3 snprintf') and &quot;8&quot; for system
administration commands.</p>
<p>At the lowest level are the <font color="#6b6400">sg_request</font>
objects each of which may carry a user provided SCSI command to the
target device which is its <i>grandparent</i> in the object tree.
These requests are then sent via the block and SCSI mid-level to a
Low Level Driver (LLD) and then across a transport (with iSCSI that
can be a long way) to the target device (e.g. a SSD). User data that
moves in the same direction as the request is termed as &quot;data-out&quot;
and the SCSI WRITE command is an example. In nearly all cases (one
exception is a command timeout) a response traverses the same route
as the request, but in the reverse direction. Optionally it may be
accompanied by user data which is termed as &quot;data-in&quot; and
the SCSI READ command is an example. Notice that a <i><span style="font-weight: normal">heavy</span></i>
(thicker) line is associated with the <i>first</i> request of each
file descriptor; it points to a <font color="#bc312e">reserve request</font>
(in version 3 (and earlier) sg documentation this was referred to as
the <i>reserve buffer</i>). That <font color="#bc312e">reserve
request</font> is built after each file descriptor is created and
before the user has a chance to send a SCSI command/request on that
file descriptor. This <font color="#bc312e">reserve request</font>
was originally created to make sure CD writing programs didn't run
out of kernel memory in the middle of a &quot;burn&quot;. That is no
longer a major concern but the <font color="#bc312e">reserve request</font>
(and its associated buffer) has found other uses: for <span style="font-weight: normal">mmap</span>-ed
and direct IO. So when the <b>mmap</b>(2) system call is used on a sg
device, it is the associated file descriptor's <font color="#bc312e">reserve
request</font> buffer that is being mapped into the user space.</p>
<p>The lifetime of <font color="#6b6400">sg_request</font> objects is
worth noting. When a <font color="#6b6400">sg_request</font> object
is <i>active</i> (<i>inflight</i> is the term used in this driver) it
has both an associated block request object and a SCSI mid-level
object. They have similar roles and overlap somewhat. However once
the response is received (i.e. the <i>internal completion point</i>
in the next diagram) then the block request and the SCSI mid-level
objects are freed up. The <font color="#6b6400">sg_request </font>object
lives on, along with the data carrying part of the block request
called the <i>bio</i> as that may be carrying &quot;data-in&quot;
that has yet to be delivered to the user space. The process being
described here is <i>indirect</i> IO and is a two stage process. For
<i>data-in</i> that will be first DMA-ed from the target device into
kernel memory, typically under the control of the LLD; the second
stage is copying from that kernel memory to the user space, under the
control of this driver. Even after the user has fetched the response
and any <i>data-in</i>, the <font color="#6b6400">sg_request</font>
continues to live. [However once any data-in has been fetched the
block request <i>bio</i> is freed.] The <font color="#6b6400">sg_request</font>
object is then marked <i>inactive</i>. There is one xarray per sg
file descriptor. That xarray contains references (pointers) to
sg_request objects. The next time a user tries to send a SCSI command
through that file descriptor, its xarray will be checked to see if
any inactive <font color="#6b6400">sg_request</font> objects has a
large enough data buffer suitable for the new request; if so that
<font color="#6b6400">sg_request</font> object will be (re-)used for
the new request. Only when the user calls <b>close</b>(2) on that
file descriptor will all the requests in the fd's xarray be truly
freed. Note that in Unix, and thus Linux, the OS guarantees that it
will call the <b>close</b>(2) command (called release() in the kernel
and sg_release() in this driver) in this driver for every file
descriptor that the user has opened, irrespective of what the user
code does. This is important because processes can be shut down by
signals from other processes or drivers, segmentation violations
(i.e. bad code) or the kernel's OOM (out-of-memory) <i>killer</i>.
Immediately after a successful <b>open</b>(&lt;a_sg_device&gt;)
system call, the new file descriptor has a xarray with one entry
marked as inactive which is a <font color="#bc312e">reserve request</font>.</p>
<p>The above description is setting the stage for a newly added
feature called <i>request sharing</i> introduced in the sg v4 driver.
It also uses the <font color="#bc312e">reserve request</font>.</p>
<h3 class="western"><a name="__RefHeading___Toc18168_1671399770"></a>4.1
Command or request</h3>
<p>The terms <i>command</i> and <i>request</i> are used
interchangeably in this driver and its documentation. Strictly
speaking a <i>command</i> refers to a SCSI command (or more precisely
a SCSI Command Descriptor Block (cdb)) as documented in the various
SCSI command set standards available from <a href="http://www.t10.org/">T10</a>
. An example of an important one of these is the &quot;SCSI Primary
Commands - 4&quot; (usually known as: SPC-4). Quite often when a
document refers to a SCSI command it implicitly also means the
response (from the storage device) to that command.</p>
<p>The term <i>request</i> comes from the opposite direction: from
the Linux kernel and its block layer. One of the fundamental
structures in the Linux storage subsystem is 'struct request' which
in the SCSI (sub-)subsystem is specialized to struct scsi_request
which in turn is further specialized to struct sg_request by this
driver. Why have so many structures representing basically the same
thing? Two reasons: context (i.e. scsi_request and sg_request bind
more information than struct request) and lifetime (e.g. sg_request
&quot;lives&quot; longer than the other two).</p>
<p>One significant difference between the SCSI command sets and some
other storage command sets is that is that SCSI command sets say
nothing about near-end storage (e.g. where and how the response from
a READ command will be placed in the computer's memory). The <i>details</i>
are left to lower layers which in the case of SCSI may be SAS, SPI,
iSCSI, SRP, USB (UAS(P) or block) and SATA (via SAT). This lack of
near-end data management information in the command sets is
especially useful when considering disk to disk copies. With <a href="#8 Request sharing|outline"><i>request
sharing</i></a>, the user can still have maximum control over the
copy while leaving the management of the associated data buffers
returned from each READ and required for each paired WRITE, to be
managed by this driver at the kernel level. An example of &quot;maximum
control&quot; is the ability of the user to change the WRITE commands
to WRITE AND VERIFY or WRITE ATOMIC commands. The driver can also
maintain the timing relationship between each READ-WRITE pair while
running many such pairs asynchronously (i.e. several pairs started at
the same time). With <a href="#10 Multiple requests|outline">multiple
requests</a> using the <i>shared variable blocking</i> method this
can all seem like a single blocking synchronous call to the user. So
the user is getting something approaching maximum performance with
reduced complexity and reduced system overhead. The complexity of
buffer management and maintaining the timing relationships is
transferred to this driver. The reduction of system overhead is due
to minimizing the copying of user data and the removal of complexity
associated with techniques like using mmap() which needs to pin or
<i>fault</i> pages in the computer's main memory.</p>
<h3 class="western"><a name="__RefHeading___Toc8276_3647010070"></a><a name="4.2 Direct, mmap()-ed IO and bio_s|outline"></a>
4.2 Direct, mmap()-ed IO and bio_s</h3>
<p>This section is about <i>user</i> data: what starts inside blocks
within a disk or SSD, and ends up in a user space application,
typically via the <b>read</b>(2) system call or, vice versa, via the
<b>write</b>(2) system call. The simplest and most common way to
accomplish this is to utilize two buffers and two copies. The first
buffer is inside the kernel and the second buffer is in the user
space, allocated by an application to meet its needs. Why have two
buffers? Block storage by its nature is arranged in logical blocks,
typically 51 or 4096 bytes long. The kernel likes memory aligned to
specific boundaries and allocated in units of pages. Pages are
typically 4096 bytes long and the kernel prefers copies to be page
aligned. for a <b>read</b>(2) the first copy is typically done with
hardware assist (i.e. pushed by the device or its controller) using
&quot;Direct Memory Access&quot; (DMA). The second copy can be
thought of as like the C library's memcpy() call with the added
complexity of crossing the kernel/user_space boundary. What is being
described here, the author calls <span style="font-style: normal"><u>indirect</u></span>
IO, and it is the default for Unix, Linux and this sg driver.</p>
<p>Within the kernel, the SCSI subsystem is consider a child of the
block subsystem. The sg driver can be thought of as interfacing to
the user space <i>above</i> while interfacing to both the block
subsystem and the SCSI mid-level <i>below</i>. The SCSI mid-level is
the unifying component of the SCSI subsystem. One of the more
important structures in the block subsystem has the (way too general)
name 'struct request'. Objects of that structure carry SCSI commands
(cdb_s) to the storage device (i.e. <i>the request</i>) and convey
back the SCSI status, and optionally a sense buffer (i.e. <i>the
response</i>). Not all SCSI commands carry user data (e.g. the SCSI
TEST UNIT READY command), but those that do have either a data-in
buffer (i.e. from storage device to the user space) or a data-out
buffer. The block layer's 'struct bio' is the template for creating
objects that carry the user data associated with a 'struct request'
object, if that request carries user data. An important aspect of
these two objects, is that they can have <i>different</i> lifetimes.
A struct request object can be freed up (more likely: re-used) as
soon as a driver is unformed about the response of the associated
request. And especially in the case of a <b>read</b>(2) like
operation the associated bio object needs to stay &quot;alive&quot;
until the data it is carrying is conveyed (copied) back to the user
space.</p>
<p>Now returning to those two buffers and two copies, this almost
begs to be improved upon. That may lead to the following
observations:</p>
<ol>
	<li><p>Couldn't the user space allocate its buffers used by <b>read</b>(2)
	and <b>write</b>(2) to meet  storage and the kernel's alignment and
	size requirements?</p>
	<li><p>Alternatively, couldn't there be a system call that returns
	address of the bio object to the user space (and maps the associated
	bio controlled pages into the user space as needed)?</p>
	<li><p>Umm, what if the user space doesn't really need that data at
	all!? For example: a <b>read</b>(2) or <b>write</b>(2) being
	performed, might just be one side of a copy operation</p>
</ol>
<p>The answer to point 1 is yes it can, and that is called <u><span style="font-weight: normal">direct</span></u>
IO, indicated generally in Unix with the O_DIRECT flag on an <b>open</b>(2)
system call, or with the SGV4_FLAG_DIRECT_IO flag in this driver (on
a request-by-request basis). Relating this back to the bio discussion
above, the &quot;backing store&quot; to each bio object is the user
space allocated buffers (and drivers like sg don't need to allocate
any backing store for such <u>direct</u> IO operations). The answer
to point 2 is yes it can, and this is what the <b>mmap</b>(2) system
call does. In the case of the sg driver, it allocates the backing
store for the bio objects, then via the <b>mmap</b>(2) system call
returns the address of that backing store to the user space. And this
<u>mmap()-ed</u> IO can be invoked on a request-by-request basis in
the sg driver with the SG_FLAG_MMAP_IO flag.</p>
<p>That leaves point 3. In this case, no copies to the user space are
required. Ideally the copy can be &quot;thrown over the wall&quot;
(offloaded) to a disk array where both the source and destination
reside. Ultimately something has to do the actual copy, so lets
consider its situation. The computer inside the disk array probably
has multiple disk controllers (HBAs) so the copy could be reduced to
one DMA copy: from source to destination (disk(s)). Typically disk
controllers are not set up to do that, they usually DMA between
storage and main memory. Given that constraint then lets reduce the
copy to two DMAs and one buffer: a DMA to and from a struct bio
object controlled by this driver. To do that a single struct bio
object needs to kept alive from the start of a READ operation until
the corresponding WRITE command is finished. That is not easy to do
with the block layer's API, but there is a simple work around. The sg
driver provides (and manages) the backing store when struct bio
objects are constructed, so it can use the <i>same</i> backing store
for each pair of READ and WRITE  commands. Also note how well this
approach suits the SCSI command sets which don't bother themselves
with &quot;near-end&quot; data management (e.g. scatter gather lists)
but give a high level of control at the meta-data level  (e.g. 'force
unit access' and group number (categorizing the IO)). IOWs the
command sets concentrate more on <i>what</i> is to be done rather
than <i>how</i> to do it, compared to some other storage command
sets. Specifically this driver can take care of the important detail:
how the data gets from that READ to its paired WRITE. This is the
theory behind request sharing outlined in several following sections.</p>
<h2 class="western"><a name="__RefHeading___Toc1548_4294551682"></a><a name="5 Synchronous usage|outline"></a>
5 Synchronous usage</h2>
<p>These two forms: <b>ioctl</b>(sg_fd, SG_IO, ptr_to_v3_obj) and
<b>ioctl</b>(sg_fd, SG_IO, ptr_to_v4_obj) can be used for submitting
SCSI commands (requests) <span style="font-variant: normal"><span style="font-style: normal">and</span></span>
<i>waiting</i> for the response <i>before</i> returning to the
calling thread. This action is termed as <i>synchronous</i> or
<i>blocking</i> in this driver. In Linux most block devices that use
or can translate the SCSI command set also support the first form
(i.e. the <b>ioctl</b>(2) that takes a pointer to a v3 interface
object as its third argument). So this pseudo code will work:
<b>ioctl</b>(<b>open</b>(&quot;/dev/sdc&quot;), SG_IO, ptr_to_v3_obj)
but not if the third argument is a ptr_to_v4_obj. Some storage
related character devices (e.g. /dev/st2 and /dev/ses3) will also
accept the first form.</p>
<p>Only two drivers currently support the second form (i.e. whose
third argument is a ptr_to_v4_obj): this driver and the bsg driver.</p>
<p>It is important to understand that the use of <b>ioctl</b>(SG_IO)
is only <i>synchronous</i> seen from the perspective of the calling
thread/task/process. It is only the calling thread that waits for
completion of the request. Any other thread or process submitting
requests to the same or other devices associated with the sg driver
will not be impeded by that wait. This assumes that the underlying
devices can queue SCSI commands which most current SCSI devices are
capable of doing. As an example: a large copy between two storage
devices can be broken down into multiple copy segments, with each
copy segment copying a <i>comfortable</i> amount of data (say 1
MByte) between source and destination; then multiple threads can each
take a copy segment from a pool and fulfil them by doing a READ then
a WRITE SCSI command. Each READ/WRITE pair of commands seems
synchronous but overall the threads are doing asynchronous READs and
WRITEs with respect to one another. 
</p>
<p>Apart from some special cases (one shown below), it isn't
generally useful to mix <i>synchronous</i> and <i>asynchronous</i>
commands/requests on the same thread. An asynchronous command/request
(i.e. non-blocking) could be submitted followed by a second
synchronous command which will go through to completion before it
returns; then the first command's completion can be fetched. Care is
taken within the driver so that an asynchronous completion, even if
it is pending will <i>not</i> be incorrectly supplied as the result
of a synchronous command.</p>
<p>The simplest way to issue SCSI commands to any device is with a
synchronous <b>ioctl</b>(SG_IO). Asynchronous commands have some
advantages (mainly performance) but that comes at the expense of more
complexity for the user application. When a program is juggling
multiple asynchronous submissions and completions it needs to track
either pack_id, tag or a user pointer to correctly match completions
with submissions. Since the sg driver maintains strong per file
descriptor context, one way to simplify the matching problem is to
have one file descriptor per submission/completion. However then
multiple file descriptors need to be juggled, which is not so
onerous.</p>
<img src="sg_v40_html_608e4c59abf04538.png" name="Image10" align="left" width="794" height="559">
  <br clear="left"/>
</img>

<p align="left" style="margin-left: 5cm; margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Figure 2: Synchronous
(blocking) interface</b></font></p>
<p>In the diagram above a synchronous (i.e. blocking) <b>ioctl</b>(SG_IO)
is shown. As a general rule the <b>ioctl</b>(2) will return -1 with a
positive errno value if there is a problem creating the object of
type <font color="#6b6400">sg_request</font> in the top left of the
diagram. Examples of this are syntax or contradictory information in
the v3 or v4 interface object. Another cause could be lack of
resources. Once the <font color="#6b6400">sg_request</font> object is
&quot;inflight&quot; any errors will be reported via the v3 or v4
interface object. As noted in the diagram the user thread is placed
in a interruptible wait state, awaiting command/request completion.
If the command takes some time the user may use a keyboard interrupt
(e.g. control-C) to &quot;kill&quot; the containing process from
another terminal (e.g. with <b>kill</b>(1)). This will cause the
shown <font color="#6b6400">sg_request</font> object to become an
<i>orphan</i>. The default action is to remove orphan <font color="#6b6400">sg_request</font>
objects as soon as practical. However if the file descriptor has the
&quot;keep orphan&quot; flag set (see <b>ioctl</b>(SG_SET_KEEP_ORPHAN)
below) a further <b>read</b>(2) or <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
will fetch the response information from the orphan which will then
be marked as inactive and available for re-use.</p>
<p>The main context that a user space application controls in this
driver is the file descriptor, shown as a <font color="#6b6400">sg_fd</font>
object in the earlier object tree diagram. Roughly speaking a file
descriptor object is created when sg_fd=<b>open</b>(&lt;sg_device_name&gt;)
succeeds and is destroyed by a <b>close</b>(sg_fd). Again, roughly
speaking a file descriptor is confined to a user process. In
multi-threaded programs it is often a good idea to have separate sg
file descriptors in each thread. Some exceptions to these
generalizations are discussed on the next section.</p>
<p>Another feature of the file descriptor object in the sg driver is
that each one has a <font color="#bc312e">reserve request</font>
created at the same time as the file descriptor. Any new
command/request on that file descriptor will use that <font color="#bc312e">reserve
request </font>if :</p>
<ul>
	<li><p>the <font color="#bc312e">reserve request </font>is not
	already is use, and</p>
	<li><p>the new command/request's data-in or data-out buffer size is
	non-zero, and</p>
	<li><p>the file descriptor is not the <font color="#000000"><u>read-</u></font><u>side</u>
	of a share (discussed in a later section)</p>
</ul>
<p>When a command request is completed, its <font color="#6b6400">sg_request</font>
object is marked as inactive. So no <font color="#6b6400">sg_request</font>
objects are actually deleted (i.e. the memory they use being freed
up) until the owning file descriptor is <b>close</b>(2)-d. In the
case where there are multiple copies of the file descriptor (e.g. a
forked process or due to <b>dup</b>(2)) then is the last <b>close</b>(2)
that frees up all associated <font color="#6b6400">sg_request</font>
objects.</p>
<p>A sg_request object is long-lived and may handle multiple commands
between when it is first created and <font color="#000000">its
destruction</font> when its owning file descriptor is <b>close</b>(2)-d.
To manage this ,each sg_request object has a state machine with these
states:</p>
<ul>
	<li><p>SG_RQ_INACTIVE: doing nothing, awaiting its next assignment</p>
	<li><p>SG_RQ_INFLIGHT: command/request has been sent to the block
	layer, expecting to indication from lower layers that the command is
	complete.</p>
	<li><p>SG_AWAIT_RCV: that indication of completion has arrived but
	it is in the context of an interrupt or other event, unlikely to be
	the context of the issuing thread (in the user space)</p>
	<li><p>SG_RQ_BUSY: transitory state, used to <i>protect</i>
	transitions between the first three states being usurped by other
	pesky threads and kernel mechanisms such as an interrupt.</p>
</ul>
<p align="left">Comparatively speaking, there is a lot of work
involved in going from the INACTIVE to the INFLIGHT state, only some
of which is locked (or similarly sequentially processed). This means
another thread could try and pick up the same INACTIVE thread and
that would be bad. So we want to move out of INACTIVE state. But
there are bad things that can happen if we say that the request is in
INFLIGHT state before it has been handed off to the block layer. The
solution to this dilemma is to use BUSY state:
INACTIVE-&gt;BUSY-&gt;INFLIGHT . The BUSY state is also used in
INFLIGHT-&gt;BUSY-&gt;AWAIT_RCV . So if another thread looking for a
sg_request object to own or process, then BUSY state means: &quot;go
away, I'm BUSY&quot;. The &quot;internal completion point&quot; first
shown in Figure 2 above represents the  INFLIGHT-&gt;BUSY-&gt;AWAIT_RCV
transition.</p>
<h2 class="western"><a name="__RefHeading___Toc1550_4294551682"></a><a name="6 Sharing file descriptors|outline"></a><a name="6 Sharing file descriptors|outline"></a>
6 Sharing file descriptors</h2>
<p>First a rationale. Copying data between storage devices is a
relatively common operation. It can be both time and resource
consuming. The best approach is to avoid copying all together.
Another approach is to defer copies (or part of them) until they are
really necessary which is the basis of COW (i.e. copy on write). Then
there are offloaded copies, for example where the source and
destination are disks in the same storage array, then a &quot;third
party copy&quot; program (e.g. based on SCSI EXTENDED COPY and its
related commands) can tell the array to do the copy itself and inform
you if it finishes successfully or not. However in many cases copies
are unavoidable.</p>
<p>If the <b>dd</b><span style="font-weight: normal">(1)</span>
program is considered, copying one part of a normal block storage
device to another storage device involves a surprising number of
copies. Copies of large amounts of data are typically done in a
staggered fashion to lessen the impact on other things the system may
be doing. So typically 1 MegaByte (say) is read from the source
device into a buffer, followed by a write of that buffer to the
destination device; if no error occurs, repeat until finished. Copies
between a target device and kernel memory are typically done by DMA
(direct memory access) controlled by the LLDs owning the storage
devices. So another copy is needed on each side of the copy to get
the data in and out of kernel buffers to the user space. Moving data
between a user space process and the kernel space has a little extra
overhead to deal with the situations like the process being killed
while data is being copied to and from it. So a reasonable
implementation of <b>dd</b>(1) has three buffers (2 in the kernel
space) and performs 2 DMAs then 2 copies between the user space and
the kernel space. As storage devices and transports get quicker, the
time taken to do those copies may become significant compared to the
device access time.</p>
<p>Another aspect of the sharing being proposed is security. Often a
user has the right to copy data but not see it. This is usually
accomplished by encrypting the data. Another approach might be to
make sure the copy's data is kept in kernel buffers and thus hidden
from the user who is copying it. While the v4 sg driver can do this,
the sg driver is not written with a view to security, since it offers
a pass-through interface which, by definition, is a method to
circumvent an Operating System and its security mechanisms. Those
building a highly secure computer systems might consider removing the
sg driver or restricting its access to highly privileged users.</p>
<p>Sharing is a new technique added to the sg v4 driver to speed copy
operations. The user first sets up a sharing relationship between two
sg file descriptors, one that will be used for doing SCSI READ
commands (more generally any data-in SCSI command), and the other
that will be used for doing SCSI WRITE commands using the data
received by the previous READ. Any data-out command can be used so,
for example, the SCSI WRITE command could be replaced by WRITE AND
VERIFY or WRITE SCATTERED. The file descriptor that does the READ is
called the <font color="#000000"><u><span style="font-weight: normal">read-</span></u></font><u>side</u>
by the driver and the file descriptor that does the WRITE is called
the <font color="#000000"><u><span style="font-weight: normal">write-</span></u></font><u>side</u>.
The following diagram shows how one share between two file
descriptors is set up.</p>
<img src="sg_v40_html_7cafdb061ec7568f.png" name="Image11" align="left" width="794" height="559">
  <br clear="left"/>
</img>

<p style="margin-left: 6.25cm"> <span style="font-style: normal"><b>Figure
3: Setting up a file share</b></span></p>
<p>Here the <font color="#000000"><u><span style="font-weight: normal">read-</span></u></font><u>side</u>
is /dev/sg1 and has 4 open file descriptors (fd_s 1 through 4). The
<font color="#000000"><u><span style="font-weight: normal">write-</span></u></font><u>side</u>
is /dev/sg2 has 3 open file descriptors (fd_s 5 through 7). The share
shown is set up when the thread or process containing fd5 calls the
&quot;EXTENDED&quot; <b>ioctl</b> on the fd5 file descriptor (i.e.
the <b>ioctl</b>'s first parameter) with a pointer to an <font color="#000000">object
</font>containing fd1 as the <b>ioctl</b>'s third parameter. The C
code is a little more complicated than that.</p>
<p>How does the thread or process containing fd5 know about fd1? That
is up to the design of the user space application. If they are both
in the same thread then it should be obvious. If they are in
different threads within the same process then it should be
relatively simple to find out. The interesting case is when they are
in <i>different</i> processes. A child process inherits all open file
descriptors (including those belonging to the sg driver) from its
parent in the Linux fork() system call. For processes that don't have
a parent child relationship, UNIX domain sockets can be used to
&quot;send&quot; an open file descriptor from one process to another.
Note that in this case the file descriptor number might differ (e.g.
because the receiver side already is using the same file descriptor
number as the sender's number) but they will still logically refer to
the same thing. Also that statement above about process termination
leading to sg_release() being called for any sg file descriptors
<b>open</b>(2)-ed in that process needs qualification: in this case
the last process to hold an open file descriptor being terminated
causes the driver's sg_release() to be called. In short the <i>last</i>
<b>close</b>(2) on a file descriptor causes sg_release() to be
called.</p>
<p>The sg driver's file descriptors can only be part of one share
(pair). Given this restriction, in the above diagram, fd5 cannot also
be in a share with fd4. fd6 may be in a share with fd7; that would
imply that the share could be used for a copy from /dev/sg2 to
/dev/sg2 . The <font color="#000000"><u><span style="font-weight: normal">read-</span></u></font><u>side</u>
of the share monopolizes that file descriptor's <font color="#bc312e">reserve
request</font> hence there can only be one outstanding share request
per pair of shared file descriptors. Given this restriction one way
to do a copy using queued command is to use POSIX threads. As an
example from the above diagram, if 3 copy worker threads were used
then the first thread could utilize fd1 and fd5, the second thread
could utilize fd3 and fd6 while the last thread could utilize fd4 and
fd7. This is what the <b>sgh_dd</b> test utility does (see below).</p>
<p>After a share of two file descriptors is established command
requests can still be sent to both file descriptors in the normal
fashion. Only when the new flag SGV4_FLAG_SHARE is given, or OR-ed in
with other <font color="#0066b3">fla</font><font color="#a3238e">gs</font>,
is request sharing performed. See the <a href="#8 Request sharing|outline">Request
sharing</a> section below.</p>
<h2 class="western"><a name="__RefHeading___Toc1552_4294551682"></a>7
Async usage in v4</h2>
<p>The terms <i>asynchronous</i> and <i>non</i>-<i>blocking</i> are
generally used as synonyms in this description. Those terms are
related to the Unix file descriptor flags O_ASYNC and O_NONBLOCK
which have more precise meanings and are set in either the <b>open</b>(2)
or <b>fcntl</b>(2) system calls. In Unix the O_NONBLOCK flag on a
regular file descriptor causes <b>read</b>(2) to return promptly with
an EAGAIN errno if there is <u>no</u> data available to be read. This
driver's <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) and
<b>read</b>(2) will react in the same fashion. However this driver's
<b>ioctl</b>(SG_IO) ignores the O_NONBLOCK flag. The O_ASYNC file
descriptor flag causes signals to be sent to process owning the file
descriptor whenever something 'interesting' happens (e.g. data
arriving) to that file descriptor. When the term <i>asynchronous</i>
is used in this description it is more likely referring to
non-blocking behaviour rather than enabling signals.</p>
<p>The asynchronous interface in the context of the sg driver means
issuing a SCSI command in one operation then at some later time a
second operation retrieves the status of that SCSI command. Any data
being transferred associated with the SCSI command is guaranteed to
have occurred <i>before</i> that second operation succeeds. The
synchronous interface can be viewed as combining these two operations
into a single system call (e.g. <b>ioctl</b>(SG_IO) ).</p>
<p>The asynchronous interface starts with a call to
<b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
which takes a pointer to the sg v4 interface object. This object
includes the SCSI command with data transfer information for either
data-in (from device) or data-out (to device). Depending on the
storage device accessed (identified by the sg file descriptor given
as the first argument to the <b>ioctl</b>() system call) the SCSI
command will take milliseconds or microseconds to complete. Chances
are the <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
will complete in a sub-microsecond timescale (on a modern processor)
and that will be done <i>before</i> the SCSI command completes. If
further processing depends on the result of that SCSI command then
the program must wait until that SCSI command is complete. When that
completion occurs, the data-out is guaranteed to be on the nominated
storage device (or in its cache). And if a data-in transfer was
specified, that data is guaranteed to be in the user space as
directed. How does the program find out when that SCSI command has
completed?</p>
<p>The exact timing of the data-out and data-in transfers can be
thought of as a negotiation between the HBA (Host Bus Adapter
controlled by the LLD) and the storage device. The essential point is
that the data transfer and the completion are asynchronous to the
program that requested the SCSI command. Since the completion is
guaranteed to follow any associated data transfer then the completion
event is what we will concentrate on. Detecting asynchronous events
depends on Operating System features such as signals and polling.
Polling is the simpler technique. However the simplest approach is to
call the final step in the process which is <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
as soon as possible. In the likely case that the SCSI command
completion has not occurred, then the <b>ioctl</b>(2) can do one of
two things: it can wait until the completion does occur or yield an
&quot;error&quot; called EAGAIN. Similar to SCSI sense data, a UNIX
errno doesn't always imply a hard error. So EAGAIN is not a hard
error, but it tells the program that the operation didn't occur but
may happen later, so try again, but preferably don't retry
immediately. What determines whether the <b>ioctl</b>() waits or
returns EAGAIN is the presence of the O_NONBLOCK flag on the file
descriptor.</p>
<p>Two file descriptor flags are important to the asynchronous
interface of the sg driver: O_NONBLOCK and O_ASYNC. The file
descriptor flags are defined in such a way that they can be OR-ed
together. The normal place to define flags is in the <b>open</b>(2)
system call (its second argument) but they can be changed (and added
to) later with the <b>fcntl</b>(2) system call. If the O_NONBLOCK is
given then it will typically be given in the <b>open</b>(2). The
O_ASYNC flag is a bit more difficult to handle because it <i>arms</i>
the SIGIO (also known as SIGPOLL) signal which if it occurs before a
program has set up a handler for it, then the program will exit.
Actually Linux ignores O_ASYNC is the <b>open</b>(2) call (see 'man 2
open' in the BUGS section), so <b>fcntl</b>(2) is the only way to set
it. Below is a simplified example of adding the O_ASYNC flag to a
file descriptor (sg_fd) that is already open:</p>
<p style="margin-bottom: 0.2cm"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">flags
= fcntl(sg_fd, F_GETFL, NULL);</font></font></p>
<p style="margin-bottom: 0.2cm"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">fcntl(sg_fd,
F_SETFL, flags | O_ASYNC);</font></font></p>
<p>It is possible to replace the classic Unix SIGIO signal with a
POSIX real-time signal by making an additional call:</p>
<p><font face="Liberation Mono, monospace"><font size="2" style="font-size: 10pt">fcntl(sg_fd,
F_SETSIG, SIGRTMIN + 1);</font></font></p>
<p>After that call the SIGRTMIN+1 real time signal will be used
instead of SIGIO. Even though you could use hard numbers for the
real-time signals the advice is to always use and offset from
SIGRTMIN or SIGRTMAX (negative offset in the MAX case) because the
library can (and does for its POSIX threads implementation) steal
some of the lower real time signals and adjusts the SIGRTMIN value
that the application program sees. Real time signals have improved
semantic compared to the classic Unix signals (e.g. multiple
instances of the same real time signal can be queued against a
process where Unix signals would meld into one signal event in a
similar situation). The process of making these calls is referred to
as <i>arming</i> signals in the following description.</p>
<p>In the diagram below the lifetime of an active <font color="#6b6400">sg_request</font>
object is shown from when it is created, or is a re-used inactive
request, in the top left to when the SCSI command has completed and
the user space has been informed on the bottom right. It assumes that
either the O_NONBLOCK flag is set on the file descriptor (assumed to
be the same in all the system call boxes shown with the blue band at
the top), or <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
has SGV4_FLAG_IMMED OR-ed into its <font color="#0066b3">fla</font><font color="#a3238e">gs</font>.
When the first <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
is called the SCSI command has not completed so it gets rejected with
EAGAIN. The first <b>poll</b>(2) system call indicates with POLLOUT
that another SCSI command can be issued but there are no SCSI
commands waiting for an <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
on this file descriptor. Note that <b>poll</b>(2) description refers
to a file descriptor, <i>not</i> this particular <font color="#6b6400">sg_request</font>
object but for simplicity we will assume there is only one
outstanding SCSI command on <i>this</i> file descriptor. At some
future time, preferably long before the command approaches its
timeout (often 60 seconds or more) the storage device via its LLD
informs the sg driver that a SCSI command belonging to this file
descriptor has completed. If O_ASYNC has been set on this file
descriptor then the sg driver will issue a SIGIO signal to the owning
process. A <b>poll</b>(2) system call after the <i>internal
completion point</i> yields (POLLIN | POLLOUT) [IOWs both POLLIN and
POLLOUT] unless the SGV4_FLAG_NO_WAITQ flag is given. That tells us
that the next <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
will be successful as is indicated in the diagram.</p>
<img src="sg_v40_html_6b5c569fc7f74794.png" name="Image12" align="left" width="794" height="559">
  <br clear="left"/>
</img>

<p style="margin-left: 6.25cm"> <span style="font-style: normal"><b>Figure
4: Async (non-blocking) interface flow</b></span></p>
<p>While it is useful to think and illustrate the above mentioned
<b>ioctl</b>(2)s and <b>poll</b>(2)s as being in reference to a
single <font color="#6b6400">sg_request</font> object, they are all
actually against the file descriptor that is the parent of that
<font color="#6b6400">sg_request</font> object. This distinction
matters when multiple <font color="#6b6400">sg_request</font> objects
are outstanding. In the absence of any selection information (e.g. a
pack_id or a tag) the <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
will fetch the oldest <font color="#6b6400">sg_request</font> object
since the active (and completed) command list acts as a FIFO. Instead
of <b>poll</b>(2) the user may call the <b>ioctl</b>(SG_GET_NUM_WAITING)
which yields the number of <font color="#6b6400">sg_request</font>
objects belonging to a file descriptor that have completed internally
but are yet to have <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
[or <b>read</b>(2) for the async v3 interface] called on them.</p>
<p>Also, please take note of where the <i>internal completion point</i>
(it is marked with &quot;<font color="#bf0041">***</font>&quot;) is,
as it will be referred to several times in this document.</p>
<h3 class="western"><a name="__RefHeading___Toc1554_4294551682"></a>7.1
ioctl(SG_IOABORT)</h3>
<p>After starting an asynchronous request with <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
the user may decide to abort the SCSI command associated with that
request. This can be a bit tricky in practice and may not succeed
because internal processing is beyond the <i>internal completion
point</i> shown in the above diagram. In that case the user must
complete the normal processing (e.g. by using ioctl(<font color="#a3238e">SG_IORECEIVE</font>))
and the call to ioctl(SG_IOABORT) will most likely yield ENODATA.
When the request to be aborted is inflight blk_abort_request() is
called in which case normal processing should still be done. The user
code should expect a driver_status of DRIVER_HARD or DRIVER_SOFT or a
transport status of DID_TIMEOUT if the abort &quot;catches&quot; the
request it is after.</p>
<p>The request to abort needs to be identified, preferably uniquely.
The default case (i.e. when the extended <b>ioctl</b>(2) has <i>not</i>
been used on the current file descriptor to set
SG_CTL_FLAGM_TAG_FOR_PACK_ID) is to use the pack_id. The user code
provides that pack_id input via the <font color="#a3238e">request_extra</font>
field in the call to <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>).
To abort that request the user code needs to build a empty v4
interface object (with 'Q' in the first 32 bit integer and place the
pack_id in the <font color="#a3238e">request_extra</font> field. A
pointer to that object can then be given as the third argument of the
ioctl(SG_IOABORT).</p>
<p>Alternatively a tag may be used to identify a request to be
aborted. This is a little more involved. The
SG_CTL_FLAGM_TAG_FOR_PACK_ID flag needs to be set in the extended
<b>ioctl</b>(2) on current file descriptor. Then the
SGV4_FLAG_YIELD_TAG flag needs to be set in the <font color="#a3238e">flags</font>
field in the <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>).
On the completion of that <b>ioctl</b>(2), the tag can be read from
the generated_tag field. Then that tag value needs to be placed in
the <font color="#a3238e">request_tag</font> field of v4 object
pointed to in the third argument of <b>ioctl</b>(SG_IOABORT).</p>
<p>By default the scope of the search to find the request is
restricted the file descriptor given as the first argument of
<b>ioctl</b>(SG_IOABORT). The SGV4_FLAG_DEV_SCOPE flag may be set in
the <font color="#a3238e">flags</font> field of the v4 interface
object and in this case, if no match is found using the current file
descriptor then the search continues on the other sg file descriptors
belonging to that device (e.g. /dev/sg2) stopping with the first
match found. The abort is then sent to that request. The user code
should make no assumptions about the order those other file
descriptors are searched (but &quot;oldest first&quot; would be a
good guess). The importance of having unique (failing that, random)
pack_id or tag values should be apparent. Setting them always to zero
(for example) could lead to unpleasant surprises when the DEV_SCOPE
flag is used. If all searches (or a single one) find no match then
<b>ioctl</b>(SG_IOABORT) fails with errno set to ENODATA.</p>
<p>An asynchronous request started with <b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>)
can also be aborted, but only via its pack_id. In this case, even
though the submit uses the v3 interface, the <b>ioctl</b>(SG_IOABORT)
must use the v4 interface, with the pack_id placed in its
<font color="#a3238e">request_extra</font> field.</p>
<h2 class="western"><a name="__RefHeading___Toc1556_4294551682"></a><a name="8 Request sharing|outline"></a><a name="8 Request sharing|outline"></a><a name="8 Request sharing|outline"></a><a name="8 Request sharing|outline"></a>
8 Request sharing</h2>
<p style="margin-top: 0.3cm; margin-bottom: 0.3cm">Request sharing
refers to two requests, usually belonging to different storage
devices (e.g. two disks), sharing the same in-kernel data buffer.
Before request sharing can take place a share of two file descriptors
belonging to those two storage devices needs to be set up. This is
discussed in the previous <a href="#6 Sharing file descriptors|outline">Sharing
file descriptors</a> section. 
</p>
<p style="margin-top: 0.3cm; margin-bottom: 0.3cm">The diagram below
shows the synchronous sg driver interface using <b>ioctl</b>(SG_IO)
which can take either the v3 or v4 interface. The synchronous
interface can be seen as the combination of the various calls that
make up the asynchronous interface discussed in the previous section.
The time that the synchronous <b>ioctl</b>(SG_IO) takes is directly
related to the access time of the underlying storage device. To
stress that point the system call rectangles (with a blue band at the
top) in the diagram below are shown as elongated rectangles with a
beginning component to the left and a completion component to the
right. The elongated system call boxes span the access time of the
associated storage device.</p>
<p style="margin-top: 0.3cm; margin-bottom: 0.3cm">A request share
only takes place when a command request is issued and a
SGV4_FLAG_SHARE flag is used (OR-ed with any other <font color="#0066b3">fla</font><font color="#a3238e">gs</font>).
This should be done first on the <font color="#000000"><u><span style="font-weight: normal">read-</span></u></font><u>side</u>
request. Other flags that might be combined with this are
SG_FLAG_NO_DXFER or SG_FLAG_<span style="font-weight: normal">MMAP</span>_IO
flags (but not both). The SG_FLAG_NO_DXFER flag stops the copy from
the in-kernel data buffer to user space. The SG_FLAG_<span style="font-weight: normal">MMAP</span>_IO
flag maps the in-kernel data buffer into the user space; that user
space area is made available via a <b>mmap</b>(2) system call
preceding the command request being sent. The diagram below shows the
simpler case where the minimum number of <font color="#0066b3">fla</font><font color="#a3238e">gs</font>
are set. For brevity the leading SGV4_ is removed from the flag
values in the following diagrams.</p>
<img src="sg_v40_html_dd4e67e70a2cef2b.png" name="Image13" align="left" width="794" height="559">
  <br clear="left"/>
</img>

<p style="margin-left: 7.5cm; margin-top: 0.1cm"> <span style="font-style: normal"><b>Figure
5: Request sharing flow</b></span></p>
<p style="margin-top: 0.1cm">The <u>read-side</u> and <u>write-side</u>
file descriptors must be different (i.e. each <font color="#000000">created
by</font> their own <b>open</b>(2) system command) but could refer to
the <i>same</i> sg device (e.g. /dev/sg3). The command associated
with the <u>read-side</u> will almost always be a READ command, but
it only needs to be a command that uses the data-in part of a SCSI
command to populate a kernel buffer. So for example the READ BUFFER
command could be used on the <u>read-side</u>.  The command
associated with the <u>write</u><u>-side</u><span style="text-decoration: none">
</span><span style="text-decoration: none">needs to be a command that
uses the data-</span><span style="text-decoration: none">out</span><span style="text-decoration: none">
part of a SCSI command </span><font color="#000000"><span style="text-decoration: none">the
fetches data from</span></font><span style="text-decoration: none"> a
kernel buffer</span><span style="text-decoration: none"> to send to
the device</span><span style="text-decoration: none">.</span><span style="text-decoration: none">
Quite a few SCSI commands met the </span><u>write-side</u><span style="text-decoration: none">
requirement apart from WRITE itself, some of those are VERIFY, WRITE
AND VERIFY, WRITE ATOMIC and WRITE SCATTERED commands.</span></p>
<p style="margin-top: 0.1cm">The <font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
may continue to send normal command requests but at some stage it
should send the corresponding WRITE (like) command request with both
the SGV4_FLAG_SHARE <u>and</u> SG_FLAG_NO_DXFER <font color="#0066b3">fla</font><font color="#a3238e">gs</font>
set. That will use the in-kernel data buffer from the preceding
<font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
share command request and send that data (i.e. data-out) to the
<font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>'s
device. So a single, in-kernel data buffer is used for a <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
share request followed by a <font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
<span style="font-weight: normal">share</span> request.</p>
<p style="margin-top: 0.1cm">In the terminology of the block
subsystem both the <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
and <font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
share requests have their own <i>request</i> object, each with their
own <i>bio</i> object. However the sg driver provides the data
storage for those <i>bio</i><i>_</i><i>s</i> and arranges for the
<font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
share request to use the same data buffer as the preceding <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
request's bio. And this is the reason that the <font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
request must use the SG_FLAG_NO_DXFER flag, otherwise a transfer from
the user space usually associated with a WRITE (like) command would
overwrite the in-kernel data buffer.</p>
<p style="margin-top: 0.1cm">Once the <font color="#000000"><u>write-side</u></font>
request has successfully completed another <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
share request may be issued. Sanity checks ensure that using the
SG_FLAG_SHARE flag on <i>non-shared</i> file descriptor will cause an
error, as will trying to send a <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
share request before a prior <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
share request is complete (which means its matching <font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
request has finished). Once a pair of file descriptors are shared,
the <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>'s
<font color="#bc312e">reserve request</font> will only be used for
command requests that have the SGV4_FLAG_SHARE flag set.</p>
<p>If the <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
share request fails (i.e. gives back any non zero status, or fails or
warns at some other level) then the <font color="#000000"><u><span style="font-weight: normal">read-s</span></u></font><font color="#000000"><u><span style="font-weight: normal">i</span></u></font><font color="#000000"><u><span style="font-weight: normal">de</span></u></font>
request on completion will go to state &quot;rq_inactive&quot; (i.e.
not &quot;rq_swap&quot;). Even if the <font color="#000000"><u>read-side</u></font>
request succeeds, it is also possible that the application wants to
stop the copy (e.g. because the user wants to abort the copy or there
is something wrong with the data copied to the user space near the
location marked &quot;***&quot; in the above diagram). This call:
<b>ioctl</b><span style="font-weight: normal">(</span><font color="#000000"><span style="font-weight: normal">read_side</span></font><span style="font-weight: normal">_fd,
EXTENDED{</span><span style="font-weight: normal">READ_SIDE</span><span style="font-weight: normal">_FINI})</span>
manipulates a boolean which can be used to finish a share request
after the <font color="#000000"><u>read-side</u></font> request has
completed. What is needed here is setting this boolean to 1 (true)
which changes the &quot;rq_swap&quot; to &quot;rq_inactive&quot;
state. The inverse operation: setting that boolean to 0 (false)
changes &quot;rq_inactive&quot; to &quot;rq_swap&quot; state which is
used in the single read, multi write case below.</p>
<p>The brown arrow-ed lines in the above diagram show the movement of
the &quot;dataset&quot; which is usually an integral number of
logical blocks (e.g. each containing 512 or 4096 bytes). The brown
arrow-ed lines that are vertical and horizontal do not involve
copying (or DMA-ing) of that dataset. That leaves three brown
arrow-ed lines at an angle: the DMA from the device being read, the
DMA to the device being written, and an optional in-kernel to user
space copy (annotated with &quot;***&quot;).</p>
<p>Returning to the discussion of the sg_request object state
machine. Request sharing adds two more states:</p>
<ul>
	<li><p>SG_RQ_SHR_SWAP:  the <font color="#000000"><u><span style="font-weight: normal">read-s</span></u></font><font color="#000000"><u><span style="font-weight: normal">i</span></u></font><font color="#000000"><u><span style="font-weight: normal">de</span></u></font>
	request only: completed request, <i>awaiting</i> hand-off (swap)
	starting the <u>write-side</u><span style="text-decoration: none">
	requ</span><span style="text-decoration: none">est</span></p>
	<li><p><span style="text-decoration: none">SG_RQ_SHR_IN_WS:  the
	</span><font color="#000000"><u><span style="font-weight: normal">read-s</span></u></font><font color="#000000"><u><span style="font-weight: normal">i</span></u></font><font color="#000000"><u><span style="font-weight: normal">de</span></u></font><span style="text-decoration: none">
	request only: completed request, the </span><u>write-side</u><span style="text-decoration: none">
	requ</span><span style="text-decoration: none">est has started,
	</span><i><span style="text-decoration: none">awaiting</span></i><span style="font-style: normal"><span style="text-decoration: none">
	its completion</span></span></p>
</ul>
<p><span style="font-style: normal"><span style="text-decoration: none">Note
that the </span></span><span style="font-style: normal"><u>write-side</u></span><span style="font-style: normal"><span style="text-decoration: none">
requ</span></span><span style="font-style: normal"><span style="text-decoration: none">est
still only uses the original four states document</span></span><span style="font-style: normal"><span style="text-decoration: none">ed</span></span><span style="font-style: normal"><span style="text-decoration: none">
in</span></span><span style="font-style: normal"><span style="text-decoration: none">
an</span></span><span style="font-style: normal"><span style="text-decoration: none">
</span></span><a href="#5 Synchronous usage|outline">above</a><span style="font-style: normal"><span style="text-decoration: none">
section. </span></span><span style="font-style: normal"><span style="text-decoration: none">Now
the </span></span><font color="#000000"><span style="font-style: normal"><u><span style="font-weight: normal">read-s</span></u></span></font><font color="#000000"><span style="font-style: normal"><u><span style="font-weight: normal">i</span></u></span></font><font color="#000000"><span style="font-style: normal"><u><span style="font-weight: normal">de</span></u></span></font><span style="font-style: normal"><span style="text-decoration: none">
request </span></span><span style="font-style: normal"><span style="text-decoration: none">has
six possible states: it is important that it does </span></span><i><u>not</u></i><span style="font-style: normal"><span style="text-decoration: none">
return to INACTIVE state before its associated </span></span><span style="font-style: normal"><u>write-side</u></span><span style="font-style: normal"><span style="text-decoration: none">
requ</span></span><span style="font-style: normal"><span style="text-decoration: none">est</span></span><span style="font-style: normal"><span style="text-decoration: none">
has completed. </span></span><span style="font-style: normal"><span style="text-decoration: none">T</span></span><span style="font-style: normal"><span style="text-decoration: none">he
reason is that the read data (in a bio) must persist until the
</span></span><span style="font-style: normal"><u>write-side</u></span><span style="font-style: normal"><span style="text-decoration: none">
requ</span></span><span style="font-style: normal"><span style="text-decoration: none">est</span></span><span style="font-style: normal"><span style="text-decoration: none">
has completed. The user space and especially the sg driver can make
</span></span><i><span style="text-decoration: none">no assumptions</span></i><span style="font-style: normal"><span style="text-decoration: none">
about </span></span><span style="font-style: normal"><span style="text-decoration: none">when
</span></span><span style="font-style: normal"><span style="text-decoration: none">data
to be written is fetched from </span></span><span style="font-style: normal"><span style="text-decoration: none">the
given buffer (bio). More often than not it is the device (e.g. a hard
disk or SSD) that determines exactly when data (i.e. &quot;data-out&quot;)
 is moved to the storage device. Atomicity of write operations can be
involved here because for large write operations the storage devices
will move the data in &quot;bites&quot; and the question arises: what
if the transport (or disk) fails after the first &quot;bite&quot; and
before the last &quot;bite&quot;. Happily this is not the sg driver's
problem.</span></span></p>
<h3 class="western"><a name="__RefHeading___Toc15431_608653543"></a>8.1
READ, WRITE, WRITE</h3>
<p>The data-in, data-out pair in request sharing (usually a READ
followed by a WRITE) can be extended where one or more extra data-out
requests is added to the sequence. This is done by using the
SGV4_FLAG_KEEP_SHARE flag on all but the last data-out command. Two
forms are discussed in this section: the first is where all the
data-out commands use the file <i>same </i>descriptor, the second is
where they use <i>different</i> file descriptors.</p>
<p>The first form can be useful when subsets of the read buffer are
written out. Those subsets that don't start at offset 0 need use the
<b>SGV4_FLAG_DOUT_OFFSET</b> flag with the offset placed in <font color="#a3238e">spare_in</font>.
There is no restriction on those subsets overlapping. Another use
case is writing the same dataset into two or more zones on the same
ZBC disk.</p>
<p>The first form below shows a READ on the <font color="#000000"><u>read-side</u></font>
file descriptor followed by two WRITEs on the <font color="#000000"><u>write-side</u></font>
file descriptor (associated with /dev/sg2). The size of the two
WRITEs is not shown but they can differ, as long as the size from the
<font color="#000000"><u>read-side</u></font> is not exceeded.
Further, either or both of the WRITEs may use the
SGV4_FLAG_DOUT_OFFSET flag to start their WRITEs at a byte offset
(given in sg_io_v4::<font color="#a3238e">spare_in</font>) to the
start of the buffer returned by the <font color="#000000"><u>read-side</u></font>.</p>
<img src="sg_v40_html_7447e88d37941a0e.png" name="Image14" align="left" width="794" height="559">
  <br clear="left"/>
</img>

<p align="left" style="margin-left: 6.25cm; margin-top: 0.21cm; margin-bottom: 0.21cm">
<font size="3" style="font-size: 12pt"><span style="font-style: normal"><b>Figure
6: </b></span><span style="font-style: normal"><b>request </b></span><span style="font-style: normal"><b>share
with two writes</b></span></font></p>
<p>Comparing Figure 5 with Figure 6 the significant change is at
Sequence Point 2 (SQ2)  where in Figure 6 the <font color="#000000"><u>read-side</u></font>
transitions from rq_in_ws state back to rq_swap state. This is due to
the presence of the SGV4_FLAG_KEEP_SHARE flag in the first WRITE.
Since the second WRITE in Figure 6 does <i>not </i>have that flag,
then at Sequence Point 4 (SQ4) it transitions from rq_in_ws state to
rq_inactive which makes that <font color="#000000"><u>read-side</u></font>
reserve request (and its buffer) available for re-use by later
requests.</p>
<p>The second form of READ, WRITE, WRITE has the WRITEs associated
with different sg devices (e.g. different disks). This would occur
when trying to do a large copy from one disk to two or more other
disks. This requires a different approach. Two things need to happen
to the <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>:
it needs to <i>adopt</i> a new <font color="#000000"><u>write_side</u></font>
and it needs to get back into rq_swap state. A variant of the
above-mentioned <b>ioctl</b>(<font color="#000000">write_side</font>_fd,
EXTENDED{SHARE_FD},) called <b>ioctl</b>(<font color="#000000">read_side</font>_fd,
EXTENDED{CHG_SHARE_FD},) has been added to change the <font color="#000000"><u>write-side</u></font>
file descriptor. As long as the <i>new</i> <font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
file descriptor meets requirements (e.g. it is not part of a file
descriptor share already) then it will replace the <i>existing</i>
<font color="#000000"><u><span style="font-weight: normal">write-side</span></u></font>
file descriptor. To get back into rq_swap state all but the last
WRITE should use the SGV4_FLAG_KEEP_SHARE  flag as shown in Figure 6.</p>
<p>Here is a sequence of user space system calls to READ from
/dev/sg1 (i.e. the <font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>)
and WRITE that same data to /dev/sg5, /dev/sg6 and /dev/sg7 (i.e. the
<font color="#000000"><u><span style="font-weight: normal">write-sides</span></u></font>).
Assume that fd1 is a file descriptor associated with /dev/sg1, fd5
with /dev/sg5, etc. In pseudo-code that might be: 
</p>
<pre class="western">    <b>ioctl</b>(fd5, EXTENDED{SHARE_FD}, fd1);
    <b>ioctl</b>(fd1, SG_IO, FLAG_SHARE + READ);
    <b>ioctl</b>(fd5, SG_IO, FLAG_SHARE|NO_DXFER|KEEP_SHARE + WRITE);
    <b>ioctl</b>(fd1, EXTENDED{CHG_SHARE_FD=fd6});
    <b>ioctl</b>(fd6, SG_IO, FLAG_SHARE|NO_DXFER|KEEP_SHARE + WRITE); 
    <b>ioctl</b>(fd1, EXTENDED{CHG_SHARE_FD=fd7}); 
    <b>ioctl</b>(fd7, SG_IO, FLAG_SHARE|NO_DXFER + WRITE);
</pre><p>
So there are four <b>ioctl</b>s to move data (one READ and three
WRITEs) and three &quot;housekeeping&quot; <b>ioctl</b>s. Notice that
the WRITEs are done sequentially, they could theoretically be done in
parallel but that would add complexity. Also note that a new READ
cannot be done until the final WRITE (indicated by <u>not</u> having
the KEEP_SHARE flag set) from the previous sequence has completed. If
another READ is attempted prior to that, it will fail with errno set
to EADDRINUSE.  To make this sequence slightly faster (and hide the
data from the user space) the flag in the second <b>ioctl</b> (the
READ) can be expanded to FLAG_SHARE|NO_DXFER .</p>
<p>If the <font color="#000000"><u>write-side</u></font> command is
issued <i>before</i> the <font color="#000000"><u>read-</u></font><u>side</u>
has reached its internal completion point, then the <font color="#000000"><u>write-side</u></font>
gets an EBUSY errno. Even though the <font color="#000000"><u>write-</u></font><u>side</u>
<i>should</i> wait until its associated <font color="#000000"><u>read-side</u></font>
is finished, <font color="#000000"><u>write-side</u></font> commands
will be accepted after their associated <font color="#000000"><u>read-side</u></font>'s
internal completion point. The risk is that the <font color="#000000"><u>read-</u></font><u>side</u>
command could have failed and thus returned no data, so the
<font color="#000000"><u>write-</u></font><u>side</u> will be writing
unknown data (probably using the previous WRITE's data).</p>
<p>Only the first form can be used with multiple requests (in one
invocation). Further if the <i>shared variable blocking</i> method of
<i>mrq</i> is used then all the WRITEs associated with a single READ
are issued at the same time.</p>
<p>The <span style="text-decoration: none"><b>sgh_dd</b></span>
utility in the sg3_utils testing directory (rev 803 or later) has
been expanded to test the single READ, multiple WRITE feature. It has
two extra &quot;of&quot; (output file) parameters: &quot;of2=&quot;
and &quot;ofreg=&quot;. The &quot;of2=&quot; is for a second WRITE sg
device and the &quot;ofreg=&quot; takes a regular file or a pipe and
will use the data that comes from the READ operation marked with
&quot;***&quot; in the above diagram. If &quot;ofreg=&quot; is
present among <span style="text-decoration: none"><b>sgh_dd</b></span>'s
operands then the READ's flag will be FLAG_SHARE, if &quot;ofreg=&quot;
is not present its flags will be FLAG_SHARE|NO_DXFER . The latter
should be slightly faster, and that difference can be reduced with
&quot;iflag=<b>mmap</b>&quot;. The &quot;of2=&quot; operand shares
&quot;oflag=&quot; and &quot;seek=&quot; with &quot;of=&quot;.</p>
<p>The <b>sgh_dd</b> utility has a variant invoked by the --verify
command line option. In this case the SCSI WRITE command is replaced
with the VERIFY command with the BYTCHK field set to one and that
causes the VERIFY to transfer data towards the device (i.e.
data-out). The difference is that transferred data is <i>not </i>written
to the output device but instead is compared to the data that is
already there. If the comparison fails that is indicated in the SCSI
status with the MISCOMPARE sense key. So this is a different dataflow
to how an operating system usually does compares (e.g. the Unix <b>cmp</b>
command) and that is with two read operations into separate buffers
followed by a in memory compare (e.g. with the C library memcmp()
function). It is not obvious which approach is faster. For the simple
case of checking if a lot of consecutive  blocks on a storage device
are all zeros (or 0xff_s) then another variant of the VERIFY command
(with the BYTCHK field set to 3) will be a clear win over a 'cmp
/dev/zero &lt;block_dev&gt;'. type solution. The <b>sg_verify</b>
utility in the sg3_utils package can be used in this latter case.</p>
<p>When doing a large disk to disk verify using request sharing, the
performance of this sequence:</p>
<ul>
	<li><p>READ from A</p>
	<li><p>VERIFY on B with the data returned from the preceding READ</p>
</ul>
<p>may be improved by prepending a PRE-FETCH on B with the IMMED
field (bit) set to the above sequence. That should speed the final
VERIFY as the data on B that it wishes to compare against is already
in disk B's cache, due to the PRE-FETCH command.</p>
<h2 class="western"><a name="__RefHeading___Toc1560_4294551682"></a>9
Sharing design considerations</h2>
<p>The primary application of sharing is likely to be copying from
one storage device to another storage device where both are SCSI
devices (or translate the SCSI command set such as SATA disks do in
Linux). Lets assume the copy is large enough so that it needs to be
cut up into segments, implemented by READ (from source), WRITE (to
destination) commands, each pair of which share the same data. Even
with modern SSDs, maximum performance is usually obtained by queuing
commands to storage devices. However the design of request sharing in
the sg driver precludes queuing using those two file descriptors.
Worse still, the storage device that does the READ (i.e. the
<font color="#000000"><u><span style="font-weight: normal">read-side</span></u></font>
of the share) must wait, effectively doing nothing while its paired
WRITE command is being done; it could be doing the <i>next</i> READ
while it's waiting.</p>
<p>One relatively simple solution is to take advantage of threading
which is well supported by the Linux kernel. Multi-threaded programs
are typically multiple threads of execution running in a single
process. All threads within a process share the same memory and other
resources such as file descriptors. In the case of a copy using
request sharing in the sg driver, <font color="#000000">one </font>approach
would be to have one management thread and multiple worker threads.
Each worker thread would go to a <i>distribution centre</i> in the
management thread where information about the next segment offsets to
be copied would be fetched; then the worker thread could go and do
that copy segment using those offsets and return to the <i>distribution
centre</i> for information on the next segment offsets to be copied,
or be told there is nothing more to do in which case the thread could
exit. The <i>distribution centre</i> needs to be <i>stateful</i>
which in this context means that it needs to remember when it has
given out copy segment offsets and not give them out again (unless
the original thread reports an error). One way to protect this
<i>distribution centre</i> from two worker threads accessing it at
the same time is with a mutex shared between all worker threads.
Finer grained threading mechanisms such as atomic integers may be
able provide this protection in the place of a mutex.</p>
<p>With the sg driver there is no limit (in the driver, modulo memory
availability) to the number of file descriptors that there can be
referring to a single storage device. So for this segmented copy
using sg driver sharing, another approach would be to do a separate
<b>open(2)</b> system call on the source and another on the
destination in <i>each</i> worker thread. Then each worker thread
could set up a file descriptor share with the <font color="#000000"><u>read-side</u></font>
being the copy source file descriptor and the <font color="#000000"><u>write-side</u></font>
which will be the copy destination file descriptor. The number of
worker threads should be no more than the maximum queue depth the two
devices can comfortably handle. That said, having hundreds of worker
threads may consume a lot of the machine's resources. An advantage of
this approach is that each worker thread can use the sg driver's
simpler synchronous interface (i.e. <b>ioctl</b>(SG_IO) ). Then the
reader might wonder, is there any command queuing taking place? The
answer is yes, because one way of viewing the sg driver is that under
the covers it is always asynchronously accessing the SCSI devices. So
even when one thread is blocked on a <b>ioctl</b>(SG_IO) another
thread can call <b>ioctl</b>(SG_IO) and that command will be
forwarded to the device.</p>
<p>There is a big &quot;gotcha&quot; with this design (and almost any
other design for segmented copy that isn't completely single
threaded). The gotcha does <u>not</u> apply when the destination
device is a SCSI device, or uses the <b>pwrite(2)</b> or <b>writev(2)</b>
system calls but <u>does</u> apply to the <b>write(2)</b> system
call, often used to write to a pipe or socket. The problem is that if
a read is issued by one thread (or any asynchronous mechanism) called
R1 and before it completes another thread issues a read called R2,
then there is no guarantee that R1 will complete <i>before</i> R2.
And if R2 does complete before R1 and the <b>write(2)</b> system call
is called for W2 (i.e. the pair of R2) <i>before</i> W1 then those
writes will be <i>out of order.</i> Detecting out-of-order writes
when gigabytes are being copied can be painful. If the source and
shuffled destination are available as files then a utility like
<b>sha1sum</b> will show them as different (because they are) but an
old school utility like <b>sum</b>(1) (like from '<b>sum -s</b>')
will give the same value for both. There is a related issue
associated with the atomicity of the Linux <b>write</b>(2) command.
There is no corresponding atomicity issue with the SCSI WRITE command
if the target holding the storage device has one active port. If the
target has multiple active ports (potentially allowing writes from
other machines) then the WRITE ATOMIC command may be needed to
guarantee atomicity.</p>
<p>To save time and resources the <font color="#000000"><span style="font-style: normal"><u>read-</u></span></font><span style="font-style: normal"><u>side</u></span>
shared READ request should be issued with SG_FLAG_NO_DXFER flag OR-ed
with its other <font color="#0066b3">fla</font><font color="#a3238e">gs</font>.
That is assuming that the copy program does not need to &quot;see&quot;
the data as it <i>flies</i> past. As a counter example, a copy
program might want to do a <b>sha256sum</b><span style="font-weight: normal">(1)</span>
on the data being copied in which case that program needs to &quot;see&quot;
the inflight data.</p>
<p>The above design can be extended to the single reader, multiple
writer case. In other words each worker thread would open file
descriptors to the READ storage device and every WRITE storage
device. Code to demonstrate these techniques can be found in the
sg3_utils package's testing/sgh_dd.cpp utility. That code uses
<b>ioctl</b>(SG_SET_GET_EXTENDED, {SG_SEIM_CHG_SHARE_FD}) to change
the <font color="#000000"><u>write-</u></font><u>side</u> of an
existing share to the next writer.</p>
<p>SCSI storage devices optionally report a &quot;Block limits&quot;
Vital Product Data (VPD) page which contains a field called &quot;Optimal
transfer length&quot; whose units are Logical blocks (e.g. usually
either 512 or 4096 bytes). There is also a &quot;Maximum transfer
length&quot; whose units are the same. If that VPD page is present
(fetched via the SCSI INQUIRY command) but those fields are 0 then no
guidance is provided. Otherwise the segment size chosen for a copy
should probably be the minimum of the source and destination Optimal
transfer length fields. However if that implies a segment size in the
Megabyte range (say over 4 MB) then the Linux kernel may object.</p>
<p>Other copy designs are possible, that instead of using threads,
use separate processes . One practical problem with this is the
<b>ioctl(2)</b> that sets up the share between a destination file
descriptor (fd) and a source fd. That will be done in the process
containing the destination fd but how does it find out about the
source fd? One way is in a process containing the source file
descriptor, to use the Unix <b>fork(2)</b> system command to spawn a
new process. The child process will share the same file descriptors
as its parent. So if the child then goes on to open the destination
storage device then it has the two file descriptors it needs to set
up the share. While that solution may look good on paper, it may
require a radical rewrite of existing code to implement. Perhaps a
better solution is to pass an open file descriptor from one process
to another process using a Unix socket. The <a href="https://keithp.com/blogs/fd-passing/">blog</a>
by Keith Packard outlines the technique. Code based on both
techniques can be found in the sg3_utils package's
testing/sg_tst_ioctl.c (with the '-f' option).</p>
<h2 class="western"><a name="__RefHeading___Toc1562_4294551682"></a><a name="10 Multiple requests|outline"></a><a name="10 Multiple requests|outline"></a>
10 Multiple requests</h2>
<p>The bsg <b>write(2)</b> based asynchronous interface (removed from
the kernel around lk 4.15) supported multiple sg_io_v4 objects in a
single invocation. Such an invocation is abbreviated to <i>mrq</i> in
the following. Sending a variable number of requests/commands that
way is harder to do with an <b>ioctl(2)</b> based interface as the
kernel favours pointers to <i>fixed</i> size objects passed as the
ioctl's third argument. Multiple requests (in one invocation) have
been implemented in this driver using an extra level of indirection
which is a common technique for solving software challenges.</p>
<p>A new sg v4 interface flag: SGV4_FLAG_MULTIPLE_REQS, has been
added to sg_io_v4::<font color="#006c3b">flags</font> . An instance
of a sg_io_v4 object with the SGV4_FLAG_MULTIPLE_REQS flag set is
termed as a <i>control object</i> which is abbreviated to <i>ctl_obj
</i>below. A pointer to a ctl_obj can be given as the third argument
to either <b>ioctl</b>(SG_IO), <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
or <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>). The
members of a <i>control object</i> are interpreted a little
differently from a <i>normal</i> (i.e. single request) sg v4
interface object:</p>
<table width="100%" cellpadding="4" cellspacing="0" style="page-break-after: avoid">
	<col width="34*"/>

	<col width="35*"/>

	<col width="187*"/>

	<tbody>
		<tr valign="top">
			<td width="13%" bgcolor="#bee3d3" style="background: #bee3d3" style="border: none; padding: 0cm"><p>
				<b>control object's fields</b></p>
			</td>
			<td width="14%" bgcolor="#bee3d3" style="background: #bee3d3" style="border: none; padding: 0cm"><p>
				<b>input value</b></p>
			</td>
			<td width="73%" bgcolor="#bee3d3" style="background: #bee3d3" style="border: none; padding: 0cm"><p>
				<b>Notes (<font color="#006c3b">flags</font> are written without
				the leading SGV4_FLAGS_ for brevity)</b></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">guard</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				'Q'</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				associated <font color="#006c3b">ctl_obj.protocol</font> and
				<font color="#006c3b">ctl_obj.subprotocol</font> fields must both
				be 0 implying SCSI command protocol. This is the same as the
				<i>normal</i> v4 interface object</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">request</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				0 <u>or</u> ptr-&gt; array of cdbs</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p style="font-variant: normal; font-style: normal">
				if 0 then <font color="#006c3b">ctl_obj.request_len</font> field
				must be 0. If non-zero then it is a pointer to an array of cdbs
				(SCSI command descriptor blocks). The number of elements ('n') in
				this array is <font color="#006c3b">ctl_obj.dout_xfer_len</font>
				divided by SG_V4_SZ. The actual length of each cdb in this array
				is given by the <font color="#a3238e">req-&gt;request_len</font>
				field in the corresponding request array element. All actual cdb
				lengths must be less than or equal to <font color="#006c3b">ctl_obj.request_len</font>
				divided by n.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">request_len</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				0 <u>or</u> length of array of cdbs</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				if 0 then <font color="#006c3b">ctl_obj.request</font> field must
				be 0. If non-zero then it is the length in bytes of the array of
				cdbs pointed to by <font color="#006c3b">ctl_obj.request</font> 
				</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">request_extra</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<i>mrq</i> pack_id if non-zero</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				If the user wants the option of being able to use
				ioctl(SG_IOABORT) on this invocation before it finishes, then
				they may set this field to a non-zero value. Only one outstanding
				<i>mrq</i> invocation per file descriptor can have a non-zero <i>mrq</i>
				pack_id.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">dout_xferp</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				ptr-&gt; request array</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				request array is provided by the user space via <b>ioctl</b>(SG_IO)
				or <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
				and copied into the driver for processing. In the case of
				<b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) it may be
				0 (since that <b>ioctl</b>(2) doesn't expect a request array and
				will ignore it if given). This <b>ioctl</b>(2) fails with E2BIG
				if the size of the request array exceeds 2 MB.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">dout_xfer_len</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				length of request array</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				length in bytes of array pointed to by <font color="#006c3b">ctl_obj.dout_xferp</font>
				. It must be an integer multiple of SG_V4_SZ.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">din_xferp</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				ptr-&gt; space to receive response array</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				pointer to space that will have the response array written out to
				it. May be the same value as <font color="#006c3b">dout_xferp</font>.
				In the case of <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
				when MULTIPLE_REQS and IMMED <font color="#006c3b">flags</font>
				are given, may be zero. Size cannot exceed 2 MB.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">din_xfer_len</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				length of response array</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				length in bytes which must be an integer multiple of SG_V4_SZ.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">din_iovec_count</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				max number to receive, 0 -&gt; all</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				only effects <i>mrq</i>  ioctl(SG_IORECEIVE). Places and upper
				limit on the number <font color="#000000">of completed requests
				to</font> receive. The value 0 is take to mean as many as
				possible (which is <font color="#006c3b">din_xfer_len</font>/SG_V4_SZ).</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">response</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				ptr-&gt; space for sense data</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this and the <font color="#006c3b">max_response_len</font> field
				will be used to &quot;stuff&quot; (overwrite) any element in the
				request array that has zero in both corresponding fields (i.e.
				<font color="#a3238e">response</font> and <font color="#a3238e">max_response_len</font>).
				This pointer is a destination for SCSI command sense data.
				Otherwise this field can be 0 and each element of the request
				array should specify a response (sense) buffer.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">max_response_len</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				18 to 256</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				using this and the <font color="#006c3b">response</font> field
				(i.e. when they are both non-zero) assumes that it is unlikely
				that more than one of the multiple requests will yield sense
				data. If the <font color="#006c3b">response</font> field in a
				request array element is 0 then this field is ignored for that
				element. Note that the  <font color="#006c3b">response_len</font>
				field is not used nor modified.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">flags</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				MULTIPLE_REQS</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				MULTIPLE_REQS is required, these are optional: IMMED, MMAP_IO,
				NO_WAITQ, ORDERED_WR, SHARE, SIGNAL and STOP_IF flags.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">dout_resid</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt;output&gt;&gt;</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				number of requests implied by <font color="#006c3b">dout_xfer_len</font>
				less the number of requests submitted. 0 is the expected value.
				Note: unit is v4 requests, not bytes.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">din_resid</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt;output&gt;&gt; 
				</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				number of responses implied by <font color="#006c3b">din_xfer_len</font>
				less the number actually written to <font color="#006c3b">din_xferp</font>
				.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">info</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt;output&gt;&gt;</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<span style="font-variant: normal"><span style="font-style: normal">If
				the </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
				</span></span><span style="font-variant: normal"><span style="font-style: normal">invocation</span></span><span style="font-variant: normal"><span style="font-style: normal">
				does completions (e.g. </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_IO)
				), then it is number of completions (responses) written to</span></span><span style="font-variant: normal">
				</span><span style="font-variant: normal"><font color="#006c3b">din_xferp</font></span><span style="font-variant: normal">
				.</span><span style="font-variant: normal"> Otherwise it is the
				number of submissions performed</span><span style="font-variant: normal">
				(e.g. </span><span style="font-variant: normal"><b>ioctl</b></span><span style="font-variant: normal">(</span><span style="font-variant: normal"><font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font></span><span style="font-variant: normal">)
				when IMMED given)</span><span style="font-variant: normal">.</span></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#006c3b">spare_out</font></p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt;output&gt;&gt;</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				secondary error code. Usually this will be caused by an error
				detected in submission in one of the requests (e.g. using the
				'ON_OTHER' flag when there is no file share established; this
				will cause <font color="#006c3b">spare_out</font> to be ERANGE).</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<br/>

				</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt;all other input fields&gt;&gt;</p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				0</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				for example: the <b>ioctl</b>(2) fails with ERANGE if
				<font color="#006c3b">dout_iovec_count</font> is non-zero</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="13%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt;all other output fields&gt;&gt;</p>
			</td>
			<td width="14%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt;output&gt;&gt;</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				0 written</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 4: Multiple requests
invocation, control object fields</b></font></p>
<p><br/>
<br/>

</p>
<p>Note that 'din' and 'dout' maintain their data transfer direction
<i>sense</i> which is with respect to the <u>user space</u>. The
<i>response array</i> is a request array with the output fields
written to it. However in the <i>non-blocking</i> methods shown
below, the <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
may not have the request array available, so its response array has
zero-ed 'in' fields. Further, in the <i>non-blocking</i> methods, the
response array's elements are in completion order which may be
different from the request array which dictates the submission order.
SG_V4_SZ is the size in bytes of the sg version 4 interface object
(in C: sizeof(struct sg_io_v4) ). <span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">Notice
the control object can optionally provide an array of cdbs; if given
the elements in that array of cdbs will override the cdbs pointed to
in each request array element.</span></span></p>
<p style="font-variant: normal; font-style: normal">Next is a
graphical representation of the pointer relationships in a <i>mrq</i>
control object.</p>
<img src="sg_v40_html_ba67513a10b7bb70.png" name="Image7" align="left" width="794" height="613">
  <br clear="left"/>
</img>

<p align="left" style="margin-left: 5cm; margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><span style="font-variant: normal"><span style="font-style: normal"><b>Figure
</b></span></span><span style="font-variant: normal"><b>7</b></span><span style="font-variant: normal"><span style="font-style: normal"><b>:
Multiple requests </b></span></span><span style="font-variant: normal"><b>control
object pointers</b></span></font></p>
<p><br/>
<br/>

</p>
<p>The above figure applies to blocking <i>mrq</i> invocations (<b>Table
5</b>) or the first half of non-blocking pairs  (i.e. the submission
part of <b>Table 6</b>). For the second half of a non-blocking pair
(i.e. the completion part of <b>Table 6</b>) <font color="#006c3b">din_xferp</font>
(or mmap()) must be given and <font color="#006c3b">dout_xferp</font>
is ignored. For blocking <i>mrq</i> invocations the <font color="#0066b3">i,
j</font> and <font color="#0066b3">k</font> values shown in <b>Figure
7</b>'s response array are the same order as the request array (i.e.
the response array is built in submission order). For the second half
of a non-blocking pair the <font color="#0066b3">i, j</font> and <font color="#0066b3">k</font>
values are in completion order. The latter case is an example of
where an application programmer may find the <font color="#a3238e">usr_ptr</font>
field useful.</p>
<p>The benefit of multiple requests is to lessen the number of
context switches and bulk up some transfers of meta-information so
more information is transferred in fewer transfers. These use cases
were considered:</p>
<ul>
	<li><p>doing a large, disk-to-disk copy: large enough so that the
	copy is broken into several segments. Request sharing with <i>ordered
	blocking</i> is well suited to this task. A READ from the copy
	source must complete before a WRITE (of the data just read) to the
	copy destination. Actually <i>ordered blocking</i> is stricter (i.e.
	more sequential) than is actually needed. And since a file
	descriptor can only support one request share operation at a time,
	another pair of file descriptors (one to the source of the copy, the
	other to the destination), could be used to perform the second
	segment of the copy at the same time as the first segment.</p>
	<li><p>when READing data from disjoint LBAs on a storage device. For
	example loading a big pdf file whose extents are not contiguous on
	the storage device. We wish to issue multiple SCSI READ commands and
	are only interested when they are <i>all</i> completed (or an error
	has occurred), the sooner the better. This is called <i>variable
	blocking</i> in the table below.</p>
	<li><p>an application that is based on a big dispatch loop in which
	SCSI command/requests are a small part. For responsiveness and
	performance, it is important that those SCSI commands don't block.
	This is implemented by either <i>non-blocking</i> method shown in
	the table below. If <i>submit non-blocking</i> is selected, then its
	ioctl(<font color="#a3238e">SG_IORECEIVE</font>) should use the
	IMMED flag.</p>
</ul>
<p style="font-variant: normal; font-style: normal">A table
summarizing four different methods of multiple requests follows with
a more in depth explanation after the table:</p>
<table width="100%" cellpadding="4" cellspacing="0" style="page-break-inside: avoid">
	<col width="35*"/>

	<col width="66*"/>

	<col width="74*"/>

	<col width="82*"/>

	<tr valign="top">
		<th width="14%" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<u>mrq </u><u>methods</u> ==&gt;</p>
			<p>submit/complete pattern ==&gt;</p>
			<p>arguments+fields</p>
		</th>
		<th width="26%" bgcolor="#e0efd4" style="background: #e0efd4" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<font size="4" style="font-size: 14pt"><u>ordered blocking</u></font></p>
			<p><font size="4" style="font-size: 14pt">[S1,C1, S2,C2, S3,C3,
			...]</font></p>
		</th>
		<th width="29%" bgcolor="#e0efd4" style="background: #e0efd4" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<font size="4" style="font-size: 14pt"><u>variable blocking</u></font></p>
			<p><font size="4" style="font-size: 14pt">[S1,S2,S3,...,
			Ck,Cm,Cj,...]</font></p>
		</th>
		<th width="32%" bgcolor="#e0efd4" style="background: #e0efd4" style="border: 1px solid #000000; padding: 0.1cm"><p style="margin-bottom: 0cm">
			<u>shared variable blocking</u></p>
			<p style="margin-bottom: 0cm">[[[SR1,CR1,SW1,CW1],</p>
			<p style="margin-bottom: 0cm">[SR2,CR2,SW2,CW2],</p>
			<p style="margin-bottom: 0cm">[SR3...],[SR4...]],</p>
			<p>[[SR5...] ...[SR7...]], ...]</p>
		</th>
	</tr>
	<tr valign="top">
		<td width="14%" bgcolor="#fedcc6" style="background: #fedcc6" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<strong>ioctl </strong><strong>for</strong><strong>
			</strong><strong><u>submission</u></strong><strong><u>+completion</u></strong></p>
		</td>
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>ioctl</b>(sg_fd, <b>SG_IO</b>, &amp;ctl_obj)</p>
		</td>
		<td width="29%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>ioctl</b>(sg_fd, <span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal"><span style="font-weight: normal">SG_IOSUBMIT</span></span></font></span>,
			&amp;ctl_obj)</p>
		</td>
		<td width="32%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			<b>ioctl</b>(sg_fd, <span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal"><span style="font-weight: normal">SG_IOSUBMIT</span></span></font></span>,
			&amp;ctl_obj)</p>
		</td>
	</tr>
	<tr valign="top">
		<td width="14%" bgcolor="#fedcc6" style="background: #fedcc6" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<strong>ctl_obj </strong><strong><font color="#006c3b">flags</font></strong><strong>
			</strong>
			</p>
			<p><br/>

			</p>
		</td>
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<u>required</u>: MULTIPLE_REQS</p>
			<p>optional: STOP_IF, SIGNAL, NO_WAITQ</p>
			<p><i>excluded</i>: IMMED, SHARE</p>
		</td>
		<td width="29%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<u>required</u>: MULTIPLE_REQS</p>
			<p>optional: STOP_IF, SIGNAL,  NO_WAITQ</p>
			<p><i>excluded</i>: IMMED, SHARE</p>
		</td>
		<td width="32%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			<u>required</u>: MULTIPLE_REQS, SHARE</p>
			<p>optional: STOP_IF, SIGNAL, ORDERED_WR, NO_WAITQ</p>
			<p><i>excluded</i>: IMMED</p>
		</td>
	</tr>
	<tr valign="top">
		<td width="14%" bgcolor="#fedcc6" style="background: #fedcc6" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<strong>req_arr element </strong><strong><font color="#a3238e">flags</font></strong></p>
			<p><br/>

			</p>
		</td>
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			optional: SHARE, DO_ON_OTHER, NO_DXFER</p>
			<p><i>excluded</i>: <strong><span style="font-weight: normal">MULTIPLE_REQS</span></strong></p>
			<p><strong><i><span style="font-weight: normal">ignored</span></i></strong><strong><span style="font-weight: normal">:
			IMMED</span></strong><strong><span style="font-weight: normal">, 
			NO_WAITQ</span></strong></p>
		</td>
		<td width="29%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			optional: SHARE, DO_ON_OTHER, NO_DXFER,  COMPLETE_B4</p>
			<p><i>excluded</i>: <strong><span style="font-weight: normal">MULTIPLE_REQS</span></strong></p>
			<p><strong><i><span style="font-weight: normal">ignored</span></i></strong><strong><span style="font-weight: normal">:
			IMMED</span></strong><strong><span style="font-weight: normal">, 
			NO_WAITQ</span></strong></p>
		</td>
		<td width="32%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			optional: SHARE, DO_ON_OTHER, NO_DXFER</p>
			<p><i>excluded</i>: <strong><span style="font-weight: normal">MULTIPLE_REQS</span></strong></p>
			<p><strong><i><span style="font-weight: normal">ignored</span></i></strong><strong><span style="font-weight: normal">:
			IMMED</span></strong><strong><span style="font-weight: normal">, 
			NO_WAITQ</span></strong></p>
		</td>
	</tr>
	<tr valign="top">
		<td width="14%" bgcolor="#fedcc6" style="background: #fedcc6" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			<b>Notes:</b></p>
			<p><strong><font color="#006c3b"><b>fla</b></font></strong><font color="#a3238e"><b>gs</b></font>
			are shown without the leading <b>SGV4_FLAG_</b></p>
		</td>
		<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			only method that uses <b>ioctl</b>(SG_IO). It must use the sg v4
			interface, both the control object and in the request array
			elements. S1 stands for submission 1 and C2 stands for completion
			2.</p>
		</td>
		<td width="29%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
			completions can be brought forward to pair with corresponding
			submission by using the COMPLETE_B4 flag. Response array in same
			order as request array but (internal) completions did necessary
			happen in that order. The Ck,Cm,Cj attempts to convey: &quot;no
			particular completion order&quot;.</p>
		</td>
		<td width="32%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
			designed for disk to disk copying. The notation: first character,
			S: submit, C: completion; second character: R: <font color="#000000"><u>read-side</u></font>,
			W: <font color="#000000"><u>write-side</u></font> command; third
			digit: RW pair number. The above notation assumes a segment
			containing 4 RW pairs. Segments are executed sequentially. Each RW
			pair in a segment are executed asynchronously while maintaining
			each RW pair's order (i.e. the pair's READ must complete before
			its WRITE commences).</p>
		</td>
	</tr>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-variant: normal; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 5: Blocking Multiple
requests invocation methods</b></font></p>
<p style="font-variant: normal; font-style: normal"><br/>
<br/>

</p>
<p><span style="font-variant: normal"><span style="font-style: normal">The
</span></span><i>ordered blocking</i><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">multiple
requests</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">method</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">submits
every command found in req_arr (read into the driver</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">via
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.dout_xferp</span></font></span><span style="font-variant: normal"><span style="font-style: normal">),</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">waiting</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">for
each request to complete </span></span><span style="font-variant: normal"><i>before</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">moving
to the next request</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">in
req_arr. It will exit when all the requests have been completed or if
an error occurs. After (partial) success,</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">the
updated req_arr will be written out to </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal"><span style="font-style: normal">.
Each completed request will have SG_INFO_MRQ_FINI OR-ed into its
</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">req.info</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">field</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">in
the response array. The updated ctl_obj is written out</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">to
the location indicated by the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_IO)'s
third argument. The </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.dout_resid</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">field
will contain the</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">number
of requests in </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.dout_xferp</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">l</span></span><span style="font-variant: normal"><i>ess</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">the
number successfully submitted; so zero is the expected number. The
order that requests appear in</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">req_arr
will be the same as the order of the response array</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">written
out on completion. The DO_ON_OTHER flag on requests instructs the
driver to submit that</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">request
on the shared file descriptor rather than the one given in first
argument of the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2).
If there is no file descriptor share already established then the
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
fails with an errno of ERANGE. Most syntax violations in multiple
requests</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">handling
will yield an ERANGE</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">error.</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">The
DO_ON_OTHER flag is only permitted with multiple requests, using it
on single request methods will cause the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
to fail with ERANGE.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">The
</span></span><i>variable blocking</i><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">multiple
requests</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">method</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">is
similar</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">to</span></span><span style="font-variant: normal">
</span><i>ordered blocking</i><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">but
by default requests are submitted without waiting for the previous
submission to complete. This can be overridden on a request by
request basis with either the SHARE or COMPLETE_B4 </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal"><span style="font-style: normal">.
With either of these </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">given,</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">the
associated</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">request
will complete before the next request (if any) is submitted. After
the submission loop, all outstanding completions are fetched before
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal"><span style="font-weight: normal">SG_IOSUBMIT</span></span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
returns to the user. The same information is copied back to the user
space as outlined in the previous paragraph.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">The
</span></span><span style="font-variant: normal"><i>shared variable
blocking</i></span><span style="font-variant: normal"><span style="font-style: normal">
multiple requests method is designed to support disk to disk copying.
</span></span><span style="font-variant: normal"><span style="font-style: normal">It
assumes a file share has already been set up and both file
descriptors will be used. This includes the case where the copy is
from one region of the disk to another region of the </span></span><span style="font-variant: normal"><i>same</i></span><span style="font-variant: normal"><span style="font-style: normal">
disk: two file descriptors are required. </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">The
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(2)
</span></font></span><span style="font-variant: normal"><span style="font-style: normal">must
be executed using the </span></span><span style="font-variant: normal"><span style="font-style: normal"><u>read-</u></span></span><span style="font-variant: normal"><span style="font-style: normal"><u>side</u></span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal"><u><span style="font-weight: normal">file
descriptor,</span></u></span></span><span style="font-variant: normal"><span style="font-style: normal">
while all the </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">paired
</span></font></span><span style="font-variant: normal"><span style="font-style: normal">WRITEs
commands must use the DO_ON_OTHER </span></span><span style="font-variant: normal"><span style="font-style: normal"><u>and</u></span></span><span style="font-variant: normal"><span style="font-style: normal">
the NO_DXFER flags. All data carrying SCSI commands must use the</span></span><span style="font-variant: normal"><span style="font-style: normal">
SHARE flag and appear in read-write pairs, usually </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">adjoining</span></font></span><span style="font-variant: normal"><span style="font-style: normal">
one another with the </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u>read-side</u></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
command first. The only exception is non-data carrying SCSI commands
such as TEST UNIT READY</span></span><span style="font-variant: normal"><span style="font-style: normal">
and PRE-FETCH</span></span><span style="font-variant: normal"><span style="font-style: normal">
that can appear anywhere. The list of commands given to this </span></span><span style="font-variant: normal"><span style="font-style: normal">method</span></span><span style="font-variant: normal"><span style="font-style: normal">
cannot end with a </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u>read-side</u></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
command. </span></span><span style="font-variant: normal"><span style="font-style: normal">These
sanity checks are done before any commands are executed and </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
invocations</span></span><span style="font-variant: normal"><span style="font-style: normal">
that don't comply are reject</span></span><span style="font-variant: normal"><span style="font-style: normal">ed</span></span><span style="font-variant: normal"><span style="font-style: normal">
entirely, usually with a </span></span><span style="font-variant: normal"><span style="font-style: normal">ERANGE
errno from the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2).</span></span><span style="font-variant: normal"><span style="font-style: normal">
The list of SCSI commands provided by the user is divided up into
segments, each typically made up of 4 read-write (RW) command pairs.
The </span></span><span style="font-variant: normal"><span style="font-style: normal">4
READs are all started </span></span><span style="font-variant: normal"><span style="font-style: normal">asynchronously</span></span><span style="font-variant: normal"><span style="font-style: normal">.
Then as each READ completes, its paired WRITE is started, when all
WRITEs in a segment are completed, the driver moves onto the next
segment and continues until the</span></span><span style="font-variant: normal"><span style="font-style: normal">
list of commands given to the </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
invocation is </span></span><span style="font-variant: normal"><span style="font-style: normal">processed</span></span><span style="font-variant: normal"><span style="font-style: normal">.
</span></span><span style="font-variant: normal"><span style="font-style: normal">So
while the </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
invocation is blocking seen from the user's perspective, the driver
asynchronously processes </span></span><span style="font-variant: normal"><span style="font-style: normal">the
given SCSI commands </span></span><span style="font-variant: normal"><span style="font-style: normal">while
observing two constraints. The first constraint</span></span><span style="font-variant: normal"><span style="font-style: normal">
is from the nature of a copy: the pair</span></span><span style="font-variant: normal"><span style="font-style: normal">ed</span></span><span style="font-variant: normal"><span style="font-style: normal">
WRITE cannot start before its associated READ. The second constraint
is from the driver: no more than </span></span><span style="font-variant: normal"><span style="font-style: normal">4</span></span><span style="font-variant: normal"><span style="font-style: normal">
RW pairs can be processed at the same time.</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal">If
the user sets the </span></span><span style="font-variant: normal"><span style="font-style: normal">NO_DXFER</span></span><span style="font-variant: normal"><span style="font-style: normal">
flag on all the </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u>read-side</u></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
commands, then all data buffer management is done by the driver. </span></span><span style="font-variant: normal"><span style="font-style: normal">Four
reserve requests </span></span><span style="font-variant: normal"><span style="font-style: normal">associated
with the READ side file descriptor are used for this data buffer
manag</span></span><span style="font-variant: normal"><span style="font-style: normal">e</span></span><span style="font-variant: normal"><span style="font-style: normal">ment.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">I</span></span><span style="font-variant: normal"><span style="font-style: normal">n
t</span></span><span style="font-variant: normal"><span style="font-style: normal">he
</span></span><span style="font-variant: normal"><i>shared variable
blocking</i></span><span style="font-variant: normal"><span style="font-style: normal">
multiple requests method</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal">each</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u>write-side</u></span></font></span><span style="font-variant: normal"><span style="font-style: normal"><u>
</u></span></span><span style="font-variant: normal"><span style="font-style: normal">command
</span></span><span style="font-variant: normal"><span style="font-style: normal">is</span></span><span style="font-variant: normal"><span style="font-style: normal">
issued as soon as </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">its
</span></font></span><span style="font-variant: normal"><span style="font-style: normal">paired
</span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u>read-side</u></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
command</span></span><span style="font-variant: normal"><span style="font-style: normal">
has completed. This can lead to WRITE commands being issued
&quot;out-of-order&quot;</span></span><span style="font-variant: normal"><span style="font-style: normal">
since there is no guarantee that those READs will </span></span><span style="font-variant: normal"><i>complete</i></span><span style="font-variant: normal"><span style="font-style: normal">
in the order in which they were issued.</span></span><span style="font-variant: normal"><span style="font-style: normal">
With a normal disk this is okay. However there are at least two
situation</span></span><span style="font-variant: normal"><span style="font-style: normal">s</span></span><span style="font-variant: normal"><span style="font-style: normal">
where this will be a problem:</span></span></p>
<ul>
	<li><p><span style="font-variant: normal"><span style="font-style: normal">if
	the destination device is a tape drive in which </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">a</span></font></span><span style="font-variant: normal"><span style="font-style: normal">
	write operation starts at the position of the recording heads. That
	position will normal</span></span><span style="font-variant: normal"><span style="font-style: normal">ly
	be </span></span><span style="font-variant: normal"><span style="font-style: normal">where
	the tape drive completed the previous read or write operation.</span></span></p>
	<li><p><span style="font-variant: normal"><span style="font-style: normal">if
	the destination device </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">uses</span></font></span><span style="font-variant: normal"><span style="font-style: normal">
	shingled magnetic recording (SMR) and the ZBC (command) set in &quot;host
	managed&quot; mode.</span></span><span style="font-variant: normal"><span style="font-style: normal">
	ZBC requires the device to check the given starting LBA of a WRITE
	against its &quot;write pointer&quot;. </span></span><span style="font-variant: normal"><span style="font-style: normal">That
	write pointer will typically be pointing at the LBA following the
	previous successful </span></span><span style="font-variant: normal"><span style="font-style: normal">WRITE
	command</span></span><span style="font-variant: normal"><span style="font-style: normal">.
	</span></span><span style="font-variant: normal"><span style="font-style: normal">If
	they are not a match then the device will fail the operation with an
	ILLEGAL REQUEST sense key and the additional sense of WRITE BOUNDARY
	VIOLATION.</span></span></p>
</ul>
<p align="left"><span style="font-variant: normal"><span style="font-style: normal">To
cope with these situations the </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>ORDERED_</b></span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>WR</b></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
flag </span></span><span style="font-variant: normal"><span style="font-style: normal">in
the control object </span></span><span style="font-variant: normal"><span style="font-style: normal">has
been added.</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal"><u>Read-side</u></span></span><span style="font-variant: normal"><span style="font-style: normal">
commands are always issued in the order specified by the user but
they may complete &quot;out-of-order&quot; with respect to one
another. In that case, this flag will delay starting the paired
</span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u>write-side</u></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
command until it is &quot;in-order&quot;. Also</span></span><span style="font-variant: normal"><span style="font-style: normal">,</span></span><span style="font-variant: normal"><span style="font-style: normal">
if ordering of commands is that important, then one of the two
&quot;Q_AT_TAIL&quot; methods should be used</span></span><span style="font-variant: normal"><span style="font-style: normal">
to discourage the Linux </span></span><span style="font-variant: normal"><span style="font-style: normal">b</span></span><span style="font-variant: normal"><span style="font-style: normal">lock
layer from taking the default &quot;queue at head&quot; semantics too
literally. </span></span><span style="font-variant: normal"><span style="font-style: normal">&quot;Q_AT_TAIL&quot;</span></span><span style="font-variant: normal"><span style="font-style: normal">
can either be set at the file descriptor level with extended
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>SG_CTL_FLAGM_Q_TAIL)
</b></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">or
on the individual command level with the </span></span></span><span style="font-variant: normal"><span style="font-style: normal"><b>SGV4_FLAG_Q_AT_TAIL</b></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
flag.</span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
Both the </span></span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u><span style="font-weight: normal">read-side</span></u></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><span style="font-weight: normal">
and </span></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u><span style="font-weight: normal">write-side</span></u></span></font></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
should use </span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">&quot;Q_AT_TAIL&quot;</span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
</span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">semantics
if precise command ordering is required.</span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
The scope of  </span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">the
</span></span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>ORDERED_</b></span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>WR</b></span></font></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
flag</span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
is the file descriptor on which it is used. So if, for example,
multiple threads with separate file descriptors to the </span></span></span><span style="font-variant: normal"><i><span style="font-weight: normal">same
</span></i></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">destination
device (e.g. a ZBC disk) overlap their </span></span></span><span style="font-variant: normal"><i><span style="font-weight: normal">mrq</span></i></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
commands then &quot;out-of-order&quot; WRITEs will almost certainly
occur. </span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">If
write-ordering is </span></span></span><span style="font-variant: normal"><i><span style="font-weight: normal">not
required</span></i></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
then cutting a large copy into sub-copies and then spreading them out
over multiple threads is a good strategy. If write-ordering </span></span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><u><span style="font-weight: normal">is</span></u></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><span style="font-weight: normal">
</span></span></font></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">required</span></span></span><span style="font-variant: normal"><i><span style="font-weight: normal">
</span></i></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">then
only one thread should be used, alternatively there could be multiple
reader threads </span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">but
only</span></span></span><span style="font-variant: normal"><span style="font-style: normal"><span style="font-weight: normal">
one writer thread.</span></span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">These
</span></span><span style="font-variant: normal"><span style="font-style: normal">three</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><i>blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">multiple
requests</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">methods
both can optionally take the STOP_IF flag on the control object. That
will cause a check to be done at completion of each request for
driver, transport or device (SCSI) errors or warnings. If any errors
or warnings are detected then no more requests will be submitted.
Notice that the STOP_IF flag has no effect in </span></span><span style="font-variant: normal"><i>variable
blocking</i></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">if
there are no SHARE or COMPLETE_B4 </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">as
all requests have already been submitted before any completions are
checked. The action of the STOP_IF flag has been designed this way so
as to </span></span><span style="font-variant: normal"><i>not</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">orphan
requests that are inflight due to an error occurring on some other
request.</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span>
</p>
<table width="100%" cellpadding="4" cellspacing="0" style="page-break-after: avoid; page-break-inside: avoid">
	<col width="35*"/>

	<col width="98*"/>

	<col width="122*"/>

	<thead>
		<tr valign="top">
			<th width="14%" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.1cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<u>mrq </u><u>methods</u> ==&gt;</p>
				<p>submit/complete pattern ==&gt;</p>
				<p>arguments+fields</p>
			</th>
			<th width="38%" bgcolor="#e0efd4" style="background: #e0efd4" style="border: none; padding: 0cm"><p>
				<font size="4" style="font-size: 14pt"><u>submit non-blocking</u></font></p>
				<p><font size="4" style="font-size: 14pt">[S1,S2,S3,...]
				[Ck,Cm,Cj]</font></p>
			</th>
			<th width="48%" bgcolor="#e0efd4" style="background: #e0efd4" style="border: none; padding: 0cm"><p>
				<font size="4" style="font-size: 14pt"><u>waitless non-blocking</u></font></p>
				<p><font size="4" style="font-size: 14pt">[S1,S2,S3,...]
				[Ck,Cm,Cj,...]</font></p>
			</th>
		</tr>
	</thead>
	<tbody>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				<strong>ioctl </strong><strong>for</strong><strong> </strong><strong><u>submission</u></strong></p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>ioctl</b>(sg_fd, <font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>,
				&amp;ctl_obj)</p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<b>ioctl</b>(sg_fd, <font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>,
				&amp;ctl_obj)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				<strong>ctl_obj </strong><strong><font color="#006c3b">flags</font></strong></p>
				<p><br/>

				</p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<u>required</u>: MULTIPLE_REQS, IMMED</p>
				<p>optional: SIGNAL, MMAP_IO, REC_ORDER</p>
				<p><i><span style="font-weight: normal">excluded</span></i>:
				STOP_IF, NO_WAITQ, SHARE</p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<u>required</u>: MULTIPLE_REQS, IMMED, NO_WAITQ</p>
				<p>optional: SIGNAL, MMAP_IO, REC_ORDER</p>
				<p><i>excluded</i>: STOP_IF, SHARE</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				<strong>req_arr element </strong><strong><font color="#a3238e">flags</font></strong><strong>
				</strong>
				</p>
				<p><br/>

				</p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				optional: SIGNAL</p>
				<p><i>excluded</i>: SHARE, DO_ON_OTHER, COMPLETE_B4,
				<strong><span style="font-weight: normal">MULTIPLE_REQS</span></strong></p>
				<p><strong><span style="font-weight: normal">ignored:  NO_WAITQ</span></strong></p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				optional: SIGNAL</p>
				<p><i>excluded</i>: SHARE, DO_ON_OTHER, COMPLETE_B4,
				<strong><span style="font-weight: normal">MULTIPLE_REQS</span></strong></p>
				<p><strong><span style="font-weight: normal">ignored:  NO_WAITQ</span></strong></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p style="background: #eeeeee">
				<br/>

				</p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<br/>

				</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				<strong>ioctl </strong><strong>for</strong><strong> </strong><strong><u>completion</u></strong></p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>ioctl</b>(sg_fd, <font color="#a3238e"><b>SG_IORECEIVE</b></font>,
				&amp;ctl_obj)</p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<b>ioctl</b>(sg_fd, <font color="#a3238e"><b>SG_IORECEIVE</b></font>,
				&amp;ctl_obj)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				<strong>ctl_obj </strong><strong><font color="#006c3b">flags</font></strong></p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<u>required</u>: MULTIPLE_REQS</p>
				<p>optional: IMMED, SIGNAL,NO_WAITQ</p>
				<p><i>excluded</i>: STOP_IF</p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<u>required</u>: MULTIPLE_REQS, IMMED</p>
				<p>optional: SIGNAL</p>
				<p><i>excluded</i>: STOP_IF</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				<strong>req_arr element </strong><strong><font color="#a3238e">flags</font></strong><strong><font color="#a3238e">
				</font></strong><strong><font color="#000000">from submission</font></strong></p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				optional: SIGNAL</p>
				<p><i>excluded</i>: SHARE, DO_ON_OTHER, COMPLETE_B4,
				<strong><span style="font-weight: normal">MULTIPLE_REQS</span></strong></p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				optional: SIGNAL</p>
				<p><i>excluded</i>: SHARE, DO_ON_OTHER, COMPLETE_B4,
				<strong><span style="font-weight: normal">MULTIPLE_REQS</span></strong></p>
			</td>
		</tr>
		<tr valign="top">
			<td width="14%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				<b>Notes:</b></p>
				<p><strong><font color="#006c3b"><b>fla</b></font></strong><font color="#a3238e"><b>gs</b></font>
				are shown without the leading <b>SGV4_FLAG_</b></p>
			</td>
			<td width="38%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				in this case the <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
				may be blocking. The response array is in the order of internal
				completions which is not necessarily the submission order.</p>
			</td>
			<td width="48%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<br/>

				</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 6: Non-blocking
Multiple requests invocation methods</b></font></p>
<p style="font-variant: normal; font-style: normal"><br/>
<br/>

</p>
<p><span style="font-variant: normal"><span style="font-style: normal">The
</span></span><span style="font-variant: normal"><i>submit
non-blocking</i></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">method
uses </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal"><span style="font-weight: normal">SG_IOSUBMIT</span></span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
&amp;</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
and sets the MULTIPLE_REQS and IMMED </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">in
the ctl_obj. The requests in the request array are all submitted in
order and then the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
returns to the user code. That code can then use any combination of
signals (both SIGIO or realtime (RT)) or the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>poll</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
system call (or </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>select</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
or </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>epoll</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2))
or </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_GET_NUM_WAITING)
or possibly</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_GET_PACK_ID)</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">to
detect that some or all of the submitted</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">requests
have completed. Then the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
&amp; </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">with
the MULTIPLE_REQS flag set and optionally the IMMED flag</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">set</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">in
the ctl_obj should be called:</span></span></p>
<ul>
	<li><p><span style="font-variant: normal"><span style="text-decoration: none"><span style="font-style: normal">without</span></span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">IMMED
	in </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal"><span style="font-style: normal">:</span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">the
	</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
	&amp;</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)</span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">call
	may block, returning when all the responses are ready. The
	</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xfer_len</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">field
	divided by </span></span><span style="font-variant: normal"><span style="font-style: normal">SG_V4_SZ</span></span><span style="font-variant: normal"><span style="font-style: normal">
	is the number of request completions this </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
	will attempt to yield. As an example: if that division yields 5,</span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">and
	3 requests are already completed,</span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">then
	this </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
	will wait for those other two requests to complete </span></span><span style="font-variant: normal"><i>before</i></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">returning
	with all 5 responses. And if the number already completed was 6 then
	the first 5 would be written out to </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">and
	the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
	would return without blocking, leaving one completed request for
	another </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
	invocation to &quot;pick up&quot;</span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">later.
	If there are no requests waiting (i.e. completed) </span></span><span style="font-variant: normal"><span style="font-style: normal"><u>and</u></span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">no
	requests are submitted, pending completion, then this </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
	fails with an errno of ENODATA. The response array output to
	</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">is
	zero filled with only output fields (including the </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">usr_ptr</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">field)
	filled for those requests that have completed. See the <a href="#10.1 Processing mrq responses|outline">Processing
	mrq responses</a> section below for more details.</span></span></p>
	<li><p><span style="font-variant: normal"><span style="font-style: normal"><u>with</u></span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">IMMED
	in </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal"><span style="font-style: normal">:
	</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
	&amp;</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)</span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">will
	return more or less immediately with all the responses that are
	available at the time. So it may need to be called more than once.
	The </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">and
	</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">din_xfer_len</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">fields
	are expected to be non-zero. The </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xfer_len</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">field
	divided by </span></span><span style="font-variant: normal"><span style="font-style: normal">SG_V4_SZ</span></span><span style="font-variant: normal"><span style="font-style: normal">
	is the maximum number of request completions this </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
	will yield. As an example: if that number is 5 and 3 requests are
	already completed then the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
	will only yield those 3 completed requests and then return to the
	caller. If there are no requests waiting (i.e. completed) </span></span><span style="font-variant: normal"><span style="font-style: normal"><u>and</u></span></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">no
	requests are submitted, pending completion, then this </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
	fails with an errno of ENODATA. If there are no requests waiting
	(i.e. completed) and there is one or more submitted requests still
	inflight then the response array output to </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
	</span><span style="font-variant: normal"><span style="font-style: normal">will
	be all zeros.</span></span></p>
</ul>
<p><span style="font-variant: normal"><span style="font-style: normal">In
both cases the response array will not necessarily be in the order of
the request array reflecting</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal">that
the storage device does not necessarily complete commands in the
order that they are </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">submitted</span></font></span><span style="font-variant: normal"><span style="font-style: normal">.</span></span><span style="font-variant: normal"><span style="font-style: normal">
The order in the response array can be specified using the
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>REC_ORDER</b></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
flag. </span></span><span style="font-variant: normal"><span style="font-style: normal">S</span></span><span style="font-variant: normal"><span style="font-style: normal">ee
the </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">later
sub</span></font></span><span style="font-variant: normal"><span style="font-style: normal">section</span></span><span style="font-variant: normal"><span style="font-style: normal">
concerning that flag.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">T</span></span><span style="font-variant: normal"><span style="font-style: normal">he
maximum number of responses received by a </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
&amp;</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
invocation can be set by placing a non-zero value in the
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_iovec_count</span></font></span><span style="font-variant: normal"><span style="font-style: normal">
field.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">The
</span></span><span style="font-variant: normal"><i>waitless</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><i>non-blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">method
uses </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal"><span style="font-weight: normal">SG_IOSUBMIT</span></span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
&amp;</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
and sets the MULTIPLE_REQS </span></span><span style="font-variant: normal"><span style="font-style: normal">,
IMMED </span></span><span style="font-variant: normal"><span style="font-style: normal">and
NO_WAITQ</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">in
the ctl_obj.</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">The
submission side is that same as the </span></span><span style="font-variant: normal"><i>submit
non-blocking</i></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">method.
They differ at the </span></span><span style="font-variant: normal"><i>internal
completion point</i></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">where
the </span></span><span style="font-variant: normal"><i>waitless</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><i>non-blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">method</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">does
</span></span><span style="font-variant: normal"><span style="font-style: normal"><u>not</u></span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">invoke
the wake_up() call on the file descriptor's wait_queue,</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">unless
overridden. Without that wake_up() call,</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><b>poll</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
(</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>select</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
and </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>epoll</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2))
will </span></span><span style="font-variant: normal"><span style="font-style: normal"><u>not</u></span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">detect
the associated</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">response.
Also using </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
&amp;ctl_obj)</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">without
the IMMED flag will potentially wait forever. So the user code should
restrict itself to using </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_GET_NUM_WAITING)
or possibly</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_GET_PACK_ID)</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">and
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
&amp;</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><u>with</u></span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">the
IMMED flag</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">set.
The second</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">bullet
point above for </span></span><span style="font-variant: normal"><i>submit
non-blocking</i></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">(i.e.
with IMMED in </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
applies here as well. </span></span>
</p>
<p><span style="font-variant: normal"><span style="font-style: normal">Here
are some further details for </span></span><span style="font-variant: normal"><i>submit
non-blocking</i></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">and
waitless</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><i>non-blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">multiple
requests</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">methods:
all requests are submitted (which should not block,</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">but
could run out of resources) after which control is returned to the
caller. Notice that several</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><font color="#a3238e">flags</font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">are
now &quot;excluded&quot; apart from SIG</span></span><span style="font-variant: normal"><span style="font-style: normal">NAL</span></span><span style="font-variant: normal"><span style="font-style: normal">.</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">Any
command in the request array using those excluded </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">will
cause the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
to fail with an errno of ERANGE and no requests will be submitted.
[IOW the control object and the request array is pre-scanned for
obvious syntax errors.] File descriptor sharing may be used but this
is </span></span><span style="font-variant: normal"><span style="font-style: normal"><u>not</u></span></span><span style="font-variant: normal">
necessarily associated with </span><span style="font-variant: normal"><span style="font-style: normal">request
sharing, rather it will allow some of the multiple requests to use
the SIG</span></span><span style="font-variant: normal"><span style="font-style: normal">NAL</span></span><span style="font-variant: normal"><span style="font-style: normal">
flag. When SIG</span></span><span style="font-variant: normal"><span style="font-style: normal">NAL</span></span><span style="font-variant: normal"><span style="font-style: normal">
is set in </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">on
a request, then after that request completes, the response array (in
its current state) is flushed out (i.e. written to where
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">points),
then on the file descriptor </span></span><span style="font-variant: normal"><span style="font-style: normal">on
which the request was sent, </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>poll</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
will have POLLIN set and a signal will be issued if armed.</span></span></p>
<p style="font-variant: normal; font-style: normal">A <i>secondary
error</i> is an error that occurs after zero or more commands from a
multiple requests array have already been submitted. No further
commands are submitted after a secondary error is detected. The
secondary error is placed in the <font color="#006c3b">ctl_obj.spare_out</font>
field. Any commands that are inflight when a secondary error is
detected, are completed. Secondary errors are (positive) errno
values. The expectation is that if the same request was input
individually with <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
(i.e. a non-<i>mrq</i> invocation) then that <b>ioctl</b>(2) would
fail with the <u>same</u> errno value.</p>
<p>Only t<span style="font-variant: normal"><span style="font-style: normal">he
</span></span><i>ordered blocking</i><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">and
</span></span><span style="font-variant: normal"><i>variable blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">multiple
requests</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">methods
(and </span></span><span style="font-variant: normal"><span style="font-style: normal"><u>not</u></span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">the
two </span></span><span style="font-variant: normal"><i>non-blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">methods)
can additionally use <a href="#8 Request sharing|outline">request
sharing</a></span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">with
the following modification. Since all multiple requests</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">invocation</span></font></span><span style="font-variant: normal"><span style="font-style: normal">s
use a single file descriptor (i.e. the first argument of the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
), then there needs</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">to
be another way of indicating a particular request should use the
</span></span><span style="font-variant: normal"><i>other</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">(i.e.
shared) file descriptor. This is done with the DO_ON_OTHER flag.</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><a href="#6 Sharing file descriptors|outline">File
descriptor sharing</a> can be used with all f</span></span><span style="font-variant: normal"><span style="font-style: normal">ive</span></span><span style="font-variant: normal"><span style="font-style: normal">
multiple requests methods</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">either
to support request sharing or to nominate another file descriptor to
which some POLL_IN and signal indications are sent to, triggered by
the SIG</span></span><span style="font-variant: normal"><span style="font-style: normal">NAL</span></span><span style="font-variant: normal"><span style="font-style: normal">
flag.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">With
the </span></span><span style="font-variant: normal"><i>non-blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">multiple
requests methods, rather than use the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>poll</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
command or signals, </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(sg_fd,
SG_GET_NUM_WAITING, &amp;an_integer) can be used. It will place the
number that are completed but not &quot;picked up&quot; into
an_integer with little overhead and it won't block. The user can also
find out how many requests are active on</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">the
given file descriptor; this includes those requests that are inflight
plus those that are waiting to be &quot;picked up&quot;. That number
can be found with </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_SET_GET_EXTENDED,
{SG_SEIRV_WAITING}). With the non-blocking multiple requests methods</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">there
is no ability to fetch the response of a particular request using a
pack_id or tag. However with a</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><i>normal</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
a request submitted via a multiple requests</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal"><span style="font-weight: normal">SG_IOSUBMIT</span></span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
can be found by pack_id or tag.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">With
the </span></span><span style="font-variant: normal"><i>non-blocking</i></span><span style="font-variant: normal"><span style="font-style: normal">
multiple requests methods,</span></span><span style="font-variant: normal"><span style="font-style: normal">
the MMAP_IO flag may be used on the control object. In this case the
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>mmap</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
system call must have already been invoked on this file descriptor.
The mmap-ed region logically takes the place of </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">.</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">din_xferp</span></font></span><span style="font-variant: normal"><span style="font-style: normal">
and as each request is completed, its resultant sg_io_v4 object is
written to the mmap-ed region. </span></span><span style="font-variant: normal"><span style="font-style: normal">Once
the </span></span><span style="font-variant: normal"><span style="font-style: normal">MMAP_IO
flag </span></span><span style="font-variant: normal"><span style="font-style: normal">is
used on the control object, then it can not be used in any request
placed in the associated request array (i.e. what is given to
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><span style="font-style: normal">.</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">d</span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">out</span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">_xferp</span></font></span><span style="font-variant: normal"><span style="font-style: normal">).
When  the </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
operation with the MMAP flag commences, the mmap-ed region is zeroed.
It is written to in ascending order, in the order of completion.</span></span></p>
<p><span style="font-variant: normal"><span style="font-style: normal">The
O_NONBLOCK flag can be set on a sg driver file descriptor with the
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>open</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
or </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>fcntl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
system calls. [Note that the related O_ASYNC file descriptor flag for
enabling signals can only be set with the </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>fcntl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
system call.]</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">If
the O_NONBLOCK flag is set</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">on
the sg_fd given as the first argument of </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal"><span style="font-weight: normal">SG_IOSUBMIT</span></span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
or </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
then it has a similar effect to giving the IMMED flag to
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj</span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">.</span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">.
If the O_NONBLOCK flag is set on the sg_fd given as the first
argument of </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_IO)
then the O_NONBLOCK flag is ignored and ioctl(SG_IO) is </span></span><span style="font-variant: normal"><i>blocking</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">as
described above. </span></span>
</p>
<p><span style="font-variant: normal"><span style="font-style: normal">Typically
few SCSI commands yield sense data and when they do, it is not
necessarily related directly to the command response that it is
attached to. For example after a WRITE command a SSD may decide to
yield sense data indicating that it has run out of resources to do
further WRITEs and that the SSD will soon become a read-only device!
So it is never a good idea to ignore sense data. On the other hand
allocating (and freeing) buffers for each command's possible sense
data can be burdensome and error prone. To simplify this a little the
control objects can be given a sense data pointer and its length in
bytes (</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.response</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">and
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.max_response_len</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">respectively)
and that will be used for any associated command request in the
request array that has zero in those two fields.</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">The
downside of doing this is that if two or more commands yield sense
data, only the last one will be seen.</span></span></p>
<p>The following diagram illustrates some transactions in part of the
<i><span style="font-weight: normal">ordered blocking</span></i>
method that is also using request sharing. Notice that the <font color="#000000"><u>read-side</u></font>
share file descriptor is the one given to <b>ioctl</b>(SG_IO) and
that requests (i.e. WRITE commands) for the <font color="#000000"><u>write-side</u></font>
file descriptor use the DO_ON_OTHER flag.</p>
<img src="sg_v40_html_f93bdd946463f18d.png" name="Image15" align="left" width="794" height="559">
  <br clear="left"/>
</img>

<p style="margin-left: 5cm"><span style="font-style: normal"><b>Figure
</b></span><span style="font-style: normal"><b>8</b></span><span style="font-style: normal"><b>:
Multiple requests with request sharing</b></span> 
</p>
<p>The sequence points, shown as blue circles in the above diagram,
are where the driver notionally changes its attention from one file
descriptor to the other, with the prime (i.e. the trailing quote)
showing the receiving end of that attention. SQ1 is where the share
between the two file descriptors is established and that does not
necessarily need to be immediately before the main multiple requests
<b>ioctl</b>(2). SQ2 on the <font color="#000000"><u>read-side</u></font>
is at the completion of the first READ (i.e. 'ind 0') and at this
point the driver starts the first WRITE (i.e. 'ind1') on the <i>other</i>
file descriptor which is the <font color="#000000"><u>write-side</u></font>.
The performance win here is that there is no return to the user space
to check the just completed command and issue the next command. At
SQ3 the WRITE has completed and this causes the second READ (i.e.
'ind 2') to start. If the SGV4_FLAG_STOP_IF flag has been OR-ed into
the ctl_obj.flag field then at SQ2, SQ3 and SQ4 an additional check
is made to see if an error or warning has been issued by the storage
device, the transport to it, or the LLD (and its associated HBA); if
so <b>ioctl</b>(SG_IO) will exit.</p>
<p>Note that multiple requests are <u>not</u> available using the <u>v3
interface</u> object: neither with <b>ioctl</b>(SG_IO) nor
<b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>)+<b>ioctl</b>(<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>)
. <b>ioctl</b>(SG_IO) using the v4 interface <i>can</i> be used for
issuing a <i>mrq</i> invocation (i.e. 'ordered blocking' as shown in
the table above).</p>
<p>The SGV4_FLAG_MULTIPLE_REQS flag  may be set on an
<b>i</b><b>octl</b>(SG_IOABORT) invocation and means that the user
wants to attempt to abort  on some or all of the commands issued (or
yet to be issued) by a prior <i>mrq</i> invocation. The prior
invocation is identified by the pack_id value held in the
<font color="#a3238e">request_extra</font> field. So in relation to
<b>i</b><b>octl</b>(SG_IOABORT) the  SGV4_FLAG_MULTIPLE_REQS flag
does <i><u>not</u></i> mean that array of pack_ids is being given.
Each  <b>i</b><b>octl</b>(SG_IOABORT) invocation can abort at most
one normal request/command or one <i>mrq</i> array of commands.</p>
<h3 class="western"><a name="__RefHeading___Toc1564_4294551682"></a><a name="10.1 Processing mrq responses|outline"></a><a name="10.1 Processing mrq responses|outline"></a>
10.1 Processing mrq responses</h3>
<p>When a <i>mrq</i> succeeds, or fails (other than an <b>ioctl</b>(2)
failure that results in errno being set) then the control object is
written back to the user space to the same location it was read from
(i.e. where the third argument of the <b>ioctl</b>(2) points). The
only exception is <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
when the SGV4_FLAG_IMMED flag is set in which case nothing is written
back. In the writeback case, the control object's fields of interest
to the user code are <font color="#006c3b">dout_resid</font>,
<font color="#006c3b">din_resid</font>, <font color="#006c3b">info</font>
and <font color="#006c3b">spare_out</font>. All four refer to the
array of normal sg_io_v4 objects written back (to the user space)
using the <font color="#006c3b">ctl_obj.din_xferp</font> pointer.
[That pointer may be zero in some cases and nothing is written back
but that is not recommended.]</p>
<p><font color="#006c3b">ctl_obj.dout_resid</font> is the number of
elements in request array (i.e. <span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.dout_xfer_len</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">/
</span></span><span style="font-variant: normal"><span style="font-style: normal">SG_V4_SZ</span></span><span style="font-variant: normal"><span style="font-style: normal">)
less the number actually submitted. Like most &quot;residuals&quot; a
value of zero is good as it implies all given elements i</span></span><span style="font-variant: normal"><span style="font-style: normal">n</span></span><span style="font-variant: normal"><span style="font-style: normal">
the request have been </span></span><span style="font-variant: normal"><span style="font-style: normal">submitted</span></span><span style="font-variant: normal"><span style="font-style: normal">.
Any non-zero (positive) value suggests something abnormal has
happened and that the array of normal sg_io_v4 objects written back
(to the user space) using the </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">pointer
should be checked.</span></span></p>
<p style="font-weight: normal"><font color="#006c3b">ctl_obj.din_resid</font>
is the number of elements in response array (i.e.
<span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xfer_len</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">/
</span></span><span style="font-variant: normal"><span style="font-style: normal">SG_V4_SZ</span></span><span style="font-variant: normal"><span style="font-style: normal">)
less the number actually completed. Any non-zero (positive) value
suggests something abnormal has happened and that the array of normal
sg_io_v4 objects written back (to the user space) using the
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">pointer
should be checked. Note that the full size request array is always
written back to the user space but normal sg_io_v4 objects beyond</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">that
indicated by </span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">din_resid</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">will
be all zeros.</span></span></p>
<p style="font-variant: normal; font-style: normal; font-weight: normal">
<font color="#006c3b">ctl_obj.info</font> is the actual number of
completions in the response array.</p>
<p style="font-weight: normal"><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.spare_out</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">holds
a secondary error which is an errno value, so zero implies no
secondary error. When requests are submitted individually, any
problem with the syntax of the normal control object is reported back
via</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">a
failed </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
</span></span><span style="font-variant: normal"><span style="font-style: normal">by</span></span><span style="font-variant: normal"><span style="font-style: normal">
setting errno (e.g. when using </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_IO)
or </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IOSUBMIT</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
). However when invoking multiple requests, that technique is not
available because a failed </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
with an errno value indicates something is wrong with the </span></span><span style="font-variant: normal"><i><u>control</u></i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">object.</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">So
when a contained normal sg_io_v4 object within a </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
has a syntax error, then that errno value is placed in
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.spare_out</span></font></span><span style="font-variant: normal"><span style="font-style: normal">.
Note that there may have been good requests submitted before the
problematic normal sg_io_v4 object and their completions should be
processed as usual.</span></span></p>
<p style="font-weight: normal"><span style="font-variant: normal"><span style="font-style: normal">Each
element in</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">the
response array written back to the user space using the
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">pointer
is more</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">or
less what would be expected if that request had been submitted
individually. There is one notable addition</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">with
</span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">s:
the SG_INFO_MRQ_FINI mask is OR-ed into each element's info field
when its completion is processed, so the absence of the mask implies
that a request has not been completed.</span></span></p>
<p style="font-weight: normal"><span style="font-variant: normal"><span style="font-style: normal">Note
that when ioctl(</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">SG_IORECEIVE</span></font></span><span style="font-variant: normal"><span style="font-style: normal">)
is used, the written back response array is not necessarily in the
order of the corresponding </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
submission. This reflects that the storage device may process
commands out-of-order. A typical example is when a disk has queued
READs and WRITEs and a TEST UNIT READY is sent; that</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">TEST
UNIT READY will typically be responded to as soon as the storage
device receives it. It is left up to the user code to match the
response array(s) with their corresponding </span></span><span style="font-variant: normal"><i>mrq</i></span><span style="font-variant: normal"><span style="font-style: normal">
submission. The </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">usr_ptr</span></font></span><span style="font-variant: normal"><span style="font-style: normal">,
pack_id (</span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">request_extra</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">field
in the v4 interface) and </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">request_tag</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">are
provided to help the user code do that matching. The </span></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">usr</span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">_ptr</span></font></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">is
a &quot;raw&quot; pointer in the v3 interface and a 64 bit unsigned
value in the v4 interface, in both cases it is treated</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">as
an </span></span><span style="font-variant: normal"><i>opaque</i></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">value
that the sg driver does not use or modify, it just keeps it with a
request and sends it back to the user space in the response</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">after
its completion.</span></span><span style="font-variant: normal"> </span><span style="font-variant: normal"><span style="font-style: normal">This
style of pointer is sometimes called a &quot;closure pointer&quot;.</span></span></p>
<p style="font-variant: normal; font-style: normal; font-weight: normal">
Note that <font color="#006c3b">ctl_obj.driver_status</font>,
<font color="#006c3b">ctl_obj.transport_status</font> and
<font color="#006c3b">ctl_obj.device_status</font> are not used and
are set to zero in a <i>mrq</i> response.</p>
<h3 class="western"><a name="__RefHeading___Toc1566_4294551682"></a>10.2
Aborting multiple requests</h3>
<p>The <b>ioctl</b>(SG_IOABORT) can be used to abort all inflight and
yet-to-be submitted requests associated with a single <i>mrq</i>
invocation. Any <i>mrq</i> invocation that the user may want to abort
later must be given a <u>non-zero</u> <i>mrq</i> pack_id (in the
<font color="#006c3b">request_extra</font> field of the control
object). There can only be one of these non-zero <i>mrq</i> pack_ids
outstanding at a time per file descriptor.</p>
<p>Usually <b>ioctl</b>(SG_IOABORT) would be issued after a
<b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
call (i.e. async or non-blocking usage). It is possible, using
another thread, to abort a <b>ioctl</b>(SG_IO) <i>mrq</i> invocation.
In this case the first thread would still be waiting inside the
<b>ioctl</b>(SG_IO) <i>mrq</i> invocation when a second thread used
the same pack_id (and file descriptor) to call <b>ioctl</b>(SG_IOABORT).</p>
<p>Any requests in a <i>mrq</i> invocation that have already reached
their internal completion point when the <i>mrq</i> abort is issued
must be processed in the normal fashion. Any inflight requests will
have blk_abort_request() called on them. Those remaining requests
that have not yet been submitted will be dropped. See the <a href="#10.1 Processing mrq responses|outline">Processing
mrq responses</a> section above for how an abort will be reported.</p>
<p>In the <b>ioctl</b>(sg_fd, SG_IOABORT, &amp;ctl_obj) invocation
the SGV4_FLAG_MULTIPLE_REQS flag must be set and the <font color="#006c3b">request_extra</font>
field must be set to the non-zero <i><span style="text-decoration: none">mrq</span></i>
pack_id. SG_PACK_ID_WILDCARD can be given for the <i>mrq</i> pack_id.
Optionally the SGV4_FLAG_DEV_SCOPE flag may be given. In that case
after the current file descriptor (i.e. the one given as the first
argument of the <b>ioctl</b>(SG_IOABORT)) is checked for a <i>mrq</i>
match on the pack_id, if that fails to find a match, then the open
file descriptors belonging to the current fd's sg device (e.g.
/dev/sg3) are checked for a match. The abort is sent to the first
match, if any, on the pack_id and the <b>ioctl</b>(SG_IOABORT)
finishes (i.e. no further checks for match are done).</p>
<p>If a call to ioctl(SG_IOABORT) is successful the array of sg_io_v4
objects pointed to by <font color="#006c3b">ctl_obj.din_xferp</font>
should be examined carefully. That array will be populated by either
<b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>), <b>ioctl</b>(SG_IO)
or when an element of the array that uses the SGV4_FLAG_SIGNAL flag.
When that flag is detected in an element of the request array (i.e.
in a normal v4 interface object) then after that command is
completed, the contents of that array of sg_io_v4 objects (complete
to and including that command) is written out to where
<font color="#006c3b">ctl_obj.din_xferp</font> points. In the case
where the <i>mrq</i> is <i>submit </i><i>non-blocking</i> or <i>waitless</i>
<i>non-blocking</i>, then it is the <font color="#006c3b">ctl_obj.din_xferp</font>
given to <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
that is used. This must be the case as the mating <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
has typically not yet been issued. 
</p>
<h3 class="western"><a name="__RefHeading___Toc1568_4294551682"></a>10.3
Single/multiple (non-)blocking requests</h3>
<p>Almost all interactions between a user space program and the sg
driver involve using a sg driver file descriptor. Each sg driver file
descriptor belongs to a sg device. [And optionally each file
descriptor may be paired (shared) with another sg file descriptor
which may belong to the same or a different sg device.] More
precisely within the sg driver, a file descriptor corresponds to a
kernel object of type 'struct file'. Using the terminology found in
'man 2 dup' (i.e. the manpage of the <b>dup</b> system call) that
kernel object is an <i>open file description</i> containing a set of
flags and a file offset, among other things. In a user space process
an <b>open</b>(2) system call returns an integer (zero or greater)
which <i>refers</i> to that open file description. That integer is
often termed a <i>file descriptor</i>. The <b>dup</b>(2) system call
creates a second reference to the <i>same</i> open file description,
as does passing a file descriptor to another process using Unix
sockets. Since such operations are relatively uncommon, an <i>open
file description</i> in this driver and a <i>file descriptor</i>
created by using <b>open</b>(2) on a sg device will be regarded as
the same thing.</p>
<p>Each sg driver file descriptor has one xarray (type of list)
containing both active and inactive requests. All commands/requests
are issued by this driver to lower levels (i.e. levels that are
<i>closer </i>to the storage devices) using a non-blocking,
asynchronous interface with its completion flagged using a software
interrupt mechanism. So <i>blocking</i> requests are managed by this
driver. Given one file descriptor, any two commands whose execution
overlap, then at some point both commands will have entries on that
file descriptor's active request list. It is important to match the
correct response with each request. If both requests were blocking
then this matching is relatively simple since the identity of each
request is known and can be searched for on the active request list.
If one request was blocking and the other non-blocking then handling
the active request list is still relatively simple. Non-blocking
request completions are processed in FIFO order (first (completion)
in becomes first out (to the user space)). If two or more
non-blocking requests are on the same request list then the problem
of matching the responses with their corresponding requests is left
up to the user space! To aid the user space to do this matching, the
pack_id, tag and usr_ptr fields are provided. The driver does do some
work in this regard: all blocking requests on an active request list
are marked so that they will never be seen by non-blocking mechanisms
such as <b>poll</b>(2), <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>),
<b>ioctl</b>(SG_GET_NUM_WAITING), or<span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_SET_GET_EXTENDED,
{SG_SEIRV_SUBMITTED}).</span></span></p>
<p>No other distinction (other than between requests submitted as
blocking or non-blocking) is made on a file descriptor's active
request list. This means single, non-blocking requests and multiple,
non-blocking requests can be submitted on the same file descriptor
and they are all treated the same way on the active queue. Their
responses can be fetched (in FIFO order of completion) by any
combination of single and multiple requests calls, using SIGPOLL (or
RT signals), <b>poll</b>(2) and <b>ioctl</b>(SG_GET_NUM_WAITING) to
detect completion, and either <b>read</b>(2) or <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
to fetch the response once a completion has occurred.</p>
<p>When there are no active requests on a sg file descriptor, there
will be at least one entry which will be the inactive <font color="#ba131a">reserve
request</font> created when that file descriptor was <b>open</b>(2)-ed.
There may be other inactive requests in the xarray which reflects at
some earlier time (in the lifetime of that file descriptor) a newly
issued request found that the <font color="#ba131a">reserve request</font>
was busy, its data buffer was not big enough, or it was unavailable.
On the <font color="#000000"><u>read-</u></font><u>side </u>of a file
descriptor share, the <font color="#ba131a">reserve request</font> is
only used for requests that have the SGV4_FLAG_SHARE flag set, so the
<font color="#ba131a">reserve request</font> is unavailable for new
requests that don't use the share flag. The number of inactive
requests in a file descriptor's xarray can be found with
<span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_SET_GET_EXTENDED,
{SG_SEIRV_</span></span><span style="font-variant: normal"><span style="font-style: normal">INACT</span></span><span style="font-variant: normal"><span style="font-style: normal">_RQS}).</span></span><span style="font-variant: normal">
</span><span style="font-variant: normal"><span style="font-style: normal">The
total number of inactive requests of the given file descriptor </span></span><span style="font-variant: normal"><i>and</i></span><span style="font-variant: normal"><span style="font-style: normal">
all file descriptors that have the same owning sg device, can be
found with </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_SET_GET_EXTENDED,
{SG_SEIRV_DEV_</span></span><span style="font-variant: normal"><span style="font-style: normal">INACT</span></span><span style="font-variant: normal"><span style="font-style: normal">_RQS}).</span></span></p>
<h3 class="western"><a name="__RefHeading___Toc18199_72860742"></a>10.4
SGV4_FLAG_REC_ORDER flag</h3>
<p><span style="font-variant: normal"><span style="font-style: normal">Sometimes
it is useful to dictate the order of the response array when
</span></span><span style="font-variant: normal"><span style="font-style: normal">non-blocking
multiple requests are completed. It may also be convenient to send
the submissions in lumps (or even one a time) but receive them in one
large </span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(SG_IORECEIVE(MRQ))
and have the responses placed in predictable positions within the
response array. </span></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">Without</span></font></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><span style="font-style: normal">the
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>REC_ORDER</b></span></font></span><span style="font-variant: normal"><span style="font-style: normal">
flag, the response array (</span></span><span style="font-variant: normal"><span style="font-style: normal">which
is pointed to by</span></span><span style="font-variant: normal"><span style="font-style: normal">
</span></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">)
is populated in completion order. And the completion order may differ
from the submission order so it is safe to assume the completion
order </span></font></span><span style="font-variant: normal"><font color="#000000"><i>will</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
be different.</span></font></span></p>
<p><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">Enter
the  </span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>REC_ORDER</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
flag</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">.
It can be given on either a normal </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IOSUBMIT)
or non-blocking </span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IOSUBMIT)</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">with
the </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>SGV4_FLAG_IMMED</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
flag also set.</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
In the latter case it is treated as if the  </span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>REC_ORDER</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
flag</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
was OR-ed into </span></font></span><span style="font-variant: normal"><font color="#000000"><i>each</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">flags</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
field</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
of the request array. When a request with this flag is processed, the
contents of the </span></font></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">request_priority</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
field is held and </span></font></span><span style="font-variant: normal"><font color="#000000"><i>may</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
be treated as an index into the response array at a later time. The
conditional</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">is
used because if </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
a completed </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">request</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
is read by a normal (i.e. non </span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">)
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IORECEIVE)
then that index is ignored. That index is used when a </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">blocking
or </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">non-blocking
</span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IO</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">RECEIVE</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">)</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
call fetches </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">one
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">or
more </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">responses.</span></font></span></p>
<p><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">The
index is origin zero (so index </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">0</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
is the first element of the response array). If the index exceeds the
number of elements in the response array (i.e. </span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.din_xferp</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
/ SG_V4_SZ) then that response is </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">written
to index (potentially overwriting anything already there which is
most likely undesirable)</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">.
No other checks are performed. For example, if the </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>REC_ORDER</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
flag</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
is set on a </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">non-blocking
</span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IOSUBMIT)</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">with
five requests and their  </span></font></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">request_priority</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
field</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
are left as zero, then</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
a subsequent</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
a </span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IO</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">RECEIVE</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">)</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
call </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">will
place between zero and five responses all at index 0 of the response
array. Only the last one written will be visible. The </span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal">ctl_obj.info</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
field will indicate how many response have been written (to the same
index</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
in this case</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">).
This is not particularly useful but does indicate how the index is
processed.</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
Another degenerate case is having a </span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IO</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">RECEIVE</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">)</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
call </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">handling
a mix if requests, some using the  </span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>REC_ORDER</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
flag</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">,
some not; best not go there. Either set that flag on all or none</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
of the requests in an array</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">.</span></font></span></p>
<p><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">Th</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">e
motivation for th</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">is
flag came about while writing a &quot;sgv4&quot; </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">engine
(</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">back</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">-</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">end</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">)</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
for the fio utility. The implementation uses an array of (maximum)
iodepth for submissions and is filled from the front (bottom) and is
committed at or before the iodepth is reached. </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">In
the version under development the initial (say 8) requests are issued
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">as
they are queued by </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">individual
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">,
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">non-blocking
ioctl(SG_IOSUBMIT) calls. Thereafter &quot;prep&quot;-ed and
&quot;queue&quot;-d requests are held until the array fills or fio
send a commit. Then those held requests a</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">re</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
sent with a non-blocking </span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
ioctl(SG_IOSUBMIT). Finally one or more non-blocking </span></font></span><span style="font-variant: normal"><font color="#000000"><i>mrq</i></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>ioctl</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">(SG_IORECEIVE)
</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">calls
are used to collect the responses. All the submissions use the 
</span></font></span><span style="font-variant: normal"><font color="#006c3b"><span style="font-style: normal"><b>SGV4_FLAG_</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal"><b>REC_ORDER</b></span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
flag</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
and the array of submissions has the array index placed in each
element's  </span></font></span><span style="font-variant: normal"><font color="#a3238e"><span style="font-style: normal">request_priority</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
field</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">
so that the responses &quot;land&quot; in the </span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">same
location as the submissions</span></font></span><span style="font-variant: normal"><font color="#000000"><span style="font-style: normal">.
</span></font></span>
</p>
<h2 class="western"><a name="__RefHeading___Toc1570_4294551682"></a>11
pack_id or tag</h2>
<p>When doing asynchronous IO with the sg driver there needs to be a
way to wait for a particular response, not just the response that is
the <i>oldest</i>. [By <i>oldest</i> is meant the command request in
the active queue (a per file descriptor queue) whose callback
occurred at the earliest time; this will usually be the first one in
the active queue.] A common example would be a multi-thread
application where each worker thread shares the same file descriptor
and issues one command request and waits for the response to that
request before issuing another command request.</p>
<p>Historically the way to do this with the sg driver is with a
<i>pack_id</i> (short for packet identifier) which is a 32 bit
integer. The <i>pack_id</i> is generated by the user application and
passed into the interface structure (and in the v4 interface the
<i>pack_id</i> is placed in <font color="#a3238e"><span style="font-style: normal">request_extra</span></font>).
The <i>pack_id</i> doesn't have to be unique (per file descriptor)
but it is practical that it is unique (and the sg driver does <i>not</i>
check its uniqueness). The user application should then call
<b>ioctl</b>(SG_SET_FORCE_PACK_ID, &amp;one) which alerts the sg
driver to read (from the user space) the pack_id given to
<b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) or <b>read</b>(2)
and then get the (first) matching request on the active queue or wait
for it to arrive. The <i>pack_id</i> value -1 (or 0xffffffff if
viewed as an unsigned integer) is used as a wildcard or to report
nothing is available, depending on the context. The <i>pack_id</i>
method has worked well and generated few error or queries over the
years and will continue to be supported in the sg v4 driver.</p>
<p>So what is a <i>tag</i> in this context? It is also a 32 bit
integer but instead of being generated by the user application, it is
generated by the block system. So instead of being given via the v4
interface structure to <font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>,
it is returned in the interface structure at the <font color="#000000">end
</font>of <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
in the <font color="#a3238e">request_tag</font> field (which is a 64
bit integer). Notice that the <i>tag</i> is only available in the v4
interface structure and via the two new async <b>ioctl</b>s:
<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>
and <font color="#a3238e">SG_IORECEIVE</font>. Using the tag to find
a command response is very similar to the way it is done with <i>pack_id</i>
described above.  The <i>tag</i> wildcard is also -1 (or all &quot;f&quot;s
in hex when viewed as an unsigned integer) so again the logic is very
similar to <i>pack_id</i>.</p>
<p>So given the above, the default remains what it was in v3 of the
sg driver, namely, using <i>pack_id</i> unless another indication is
given. To use tags to choose a response <b>ioctl</b>(SG_SET_FORCE_PACK_ID,
&amp;one_in_int) is needed first on the file descriptor. Then the v4
interface object given to <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
should <u>OR</u> SGV4_FLAG_YIELD_TAG with other <font color="#a3238e">flags</font>
in that interface object. Then after that <b>ioctl</b> has finished
successfully, the <font color="#a3238e">request_tag</font> field in
that object should be set. If it is -1 then no tag was found (as
discussed in the previous paragraph). The match <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
call should make sure the <font color="#a3238e">request_tag</font>
field is set as appropriate and the SGV4_FLAG_FIND_BY_TAG flag should
be <u>OR</u>-ed with other <font color="#a3238e">flags</font>.</p>
<h2 class="western"><a name="__RefHeading___Toc36099_3879977686"></a><a name="12 iopoll/blk_poll() support|outline"></a>
12 iopoll/blk_poll() support</h2>
<p>This feature goes by various names with <i><u><span style="font-weight: normal">iopoll</span></u></i>
probably being the original name. <i><u>blk_poll </u></i>is the name
of a function in the block layer available to higher layers that
results in a polling operation in the associated storage device's low
level driver (LLD). Yet another name is <i><u>hipri</u></i> and
probably originates from the REQ_HIPRI flag placed on a request as it
is issued by the block layer to invoke this behaviour. The fio
utility uses the keyword <i><u>hipri</u></i> to <font color="#000000">indicate
that request/commands that it issues (dictated by other fio commands,
typically in a script file) will use REQ_HIPRI and blk_poll().</font>
The assumption by the block layer interface is that any user (higher
layer) that issues a request with the REQ_HIPRI flag <font color="#000000">will
complete that request by one or more calls to blk_poll() and </font><font color="#000000"><i><u>not</u></i></font><font color="#000000">
with other mechanisms the usually involve the LLD firing an interrupt
to indicate a completion. blk_poll()'s third argument is a boolean
called spin that if true will cause the LLD to continue polling and
only return when a completion or an error occurs. In the case of the
SCSI subsystem, each command/request has a timeout value and if the
request/command doesn't complete in the given time, or the user fails
to call blk_poll()</font><font color="#000000"> before that timeout,
then the request command will be aborted.</font></p>
<p><font color="#000000">The sg driver has a new command/request
flag: SGV4_FLAG_HIPRI that causes the associated command to be issued
with </font><font color="#000000">the REQ_HIPRI flag </font><font color="#000000">set.
Strictly speaking nothing needs to be done differently on the
completion side as the driver knows which commands are &quot;hipri&quot;
and arranges for completion with blk_poll(spin&lt;-false)
accordingly. For example a call to </font><font color="#000000"><b>ioctl</b></font><font color="#000000">(SG_GET_NUM_WAITING)</font><font color="#000000">
usually count the number of this file descriptor's requests that are
in SG_RQ_AWAIT_RCV state (actually a running count is kept to speed
this ioctl). If any of those requests where issued with
SGV4_FLAG_HIPRI and are in SG_RQ_INFLIGHT state then
blk_poll(spin&lt;-false) is called once before the running count is
returned. If th</font><font color="#000000">at</font><font color="#000000">
blk_poll() flushes out a completion then </font><font color="#000000">that
request will transition from INFLIGHT--&gt;AWAIT_RCV and that running
count will be incremented. So no change is required in the user
interface to the sg driver, </font><font color="#000000"><b>ioctl</b></font><font color="#000000">(SG_GET_NUM_WAITING)</font><font color="#000000">
knows what to do. Other parts of the driver such as read(2) with the
version 3 interface of </font><font color="#000000"><b>ioctl</b></font><font color="#000000">(SG_IORECEIVE)
with the version 4 interface will also call blk_poll() when the need
arises.</font></p>
<p><font color="#000000">In the version 4 sg driver, there is a
</font><font color="#000000"><b>ioctl</b></font><font color="#000000">(SG_</font><font color="#000000">S</font><font color="#000000">ET_</font><font color="#000000">GET_EXTENDED</font><font color="#000000">)</font><font color="#000000">
sub-command: </font><font color="#000000"><span style="font-weight: normal">SG_SEIM_</span></font><font color="#000000"><span style="font-weight: normal">BLK_POLL</span></font><font color="#000000"><b>
</b></font><font color="#000000"><span style="font-weight: normal">that
calls blk_poll() directly. It uses the </span></font><font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt"><span style="font-weight: normal">sg_extended_info::numo</span></font></font></font><font color="#000000"><span style="font-weight: normal">
field as a loop count, that is the number of times it will call
blk_poll(spin&lt;</span></font><font color="#000000"><span style="font-weight: normal">--</span></font><font color="#000000"><span style="font-weight: normal">false)
on each request with </span></font><font color="#000000"><span style="font-weight: normal">SGV4_FLAG_HIPRI
</span></font><font color="#000000"><span style="font-weight: normal">set
and belonging to the given file descriptor. </span></font><font color="#000000"><span style="font-weight: normal">If
</span></font><font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt"><span style="font-weight: normal">sg_extended_info::numo</span></font></font></font><font color="#000000"><span style="font-weight: normal">
is 0 then blk_poll(s</span></font><font color="#000000"><span style="font-weight: normal">pin&lt;</span></font><font color="#000000"><span style="font-weight: normal">--f</span></font><font color="#000000"><span style="font-weight: normal">alse</span></font><font color="#000000"><span style="font-weight: normal">)
is called once on each candidate request. If </span></font><font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt"><span style="font-weight: normal">sg_extended_info::num</span></font></font></font><font color="#000000"><span style="font-weight: normal">
is negative then blk_poll(s</span></font><font color="#000000"><span style="font-weight: normal">pin&lt;</span></font><font color="#000000"><span style="font-weight: normal">--true)
is called once on each candidate request.</span></font></p>
<h2 class="western"><a name="__RefHeading___Toc1572_4294551682"></a>13
Bi-directional command support</h2>
<p><u>N.B. Support for SCSI bidirectional commands has been removed
from the Linux kernel in version 5.1 . To allow the driver to merge
post lk 5.1, bidi support has been removed from this driver. That
bidi support is available as a separate patch if the driver is used
with kernel's prior to bidi support being removed.</u></p>
<p style="text-decoration: none">One of the main reasons for
designing the sg V4 interface was to handle SCSI (or other storage
protocols) bi-directional commands (abbreviated here to <i>bidi</i>).
In the SCSI command sets, <i>bidi</i> commands are mainly found in
block commands that support RAID (e.g. XDWRITEREAD(10)) and many of
the Object Storage Device (OSD) commands. Linux contains a &quot;osd&quot;
upper level driver (ULD) and an object based file system called
exofs. New SCSI commands are being considered such as READ GATHERED
which would most likely be a <i>bidi</i> command. The NVMe command
set (NVM) extends the <i>bidi</i> commands concept to &quot;quad-di&quot;:
data-in and data-out plus metadata-in and metadata-out.</p>
<p>Synchronous SCSI <i>bidi</i> commands have been available in the
bsg driver for more than 12 years using <b>ioctl</b>(&lt;bsg_dev_fd&gt;,
SG_IO) using the sg V4 interface (i.e. struct sg_io_v4) and are now
available with the sg V4 driver where &lt;bsg_dev_fd&gt; is replaced
by &lt;sg_dev_fd&gt;. Asynchronous SCSI bidi commands were available
for the same period but were withdrawn around Linux kernel 4.15 due
to problems with the bsg driver. Those asynchronous commands were
submitted via the Unix <b>write</b>(2) call and the response was
received using a Unix <b>read</b>(2) call. In the sg v4 driver the
submitted and received object structure remains the same <i>but</i>
the Unix <b>write</b>(2) and <b>read</b>(2) system calls can no
longer be used. Instead two new <b>ioctl</b>(2)s have been introduced
called <font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>
and <font color="#a3238e">SG_IORECEIVE</font> to replace <b>write</b>(2)
and <b>read</b>(2) respectively. The functionality is almost
identical, read on for details.</p>
<p>In the sg driver the direct IO flag has the effect of letting the
block layer manage the data buffers associated with a command. The
effect of indirect IO in the sg driver is to let the sg driver manage
the data buffers. Indirect IO is the default for the sg driver with
the other options being mmap IO (memory mapped IO) and direct IO.
Indirect IO is the most flexible with the sg driver, it can be used
by both uni-directional and <i>bidi </i>commands and has no alignment
requirements on the user space buffers. Request sharing discussed
above cannot be used with direct IO (because the sg driver needs
control of the data buffers to implement the share) while mmap IO is
not implemented for <i>bidi </i>commands. Also a user space scatter
gather list cannot be used for either the data-out or data-in
transfers associated with a <i>bidi</i> command.</p>
<p>Other than the exclusions in the previous paragraph, all other
capabilities of the sg driver are available to <i>bidi</i> commands.
The completion is sent when the second transfer (usually a data-in
transfer) has completed. pack_id and/or tags can be used as discussed
in the previous section. Signal on completion, polling for completion
and multi-threading should also work on <i>bidi</i> commands without
issues.</p>
<h2 class="western"><a name="__RefHeading___Toc1574_4294551682"></a>14
SG interface support changes</h2>
<p style="margin-bottom: 0cm">In the following table, a comparison is
made between the supported interfaces of the sg driver found in lk
4.20 (V3.5.36) and the proposed V4 sg driver. The movement of the
main header file from the include/scsi directory to
include/uapi/scsi/sg should not impact user space programs since
modern Linux distributions should check both and the stub header now
in include/scsi/sg.h includes the other one. There is a chance the
GNU libc maintainers don't pick up this change/addition, but if so
the author would expect that to be a transient problem. The
sg3_utils/testing directory in the sg3_utils package gets around this
problem with a local copy of the &quot;real&quot; new sg header in a
file named uapi_sg.h .</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p align="center" style="margin-bottom: 0cm"><br/>

</p>
<table width="100%" cellpadding="2" cellspacing="1" style="page-break-after: avoid">
	<col width="41*"/>

	<col width="40*"/>

	<col width="48*"/>

	<col width="38*"/>

	<col width="44*"/>

	<col width="46*"/>

	<tr>
		<td width="16%" height="165" style="border: 1px double #808080; padding: 0.05cm"><p align="center" style="margin-bottom: 0.2cm">
			<font color="#0066b3"><b>interface support ==&gt;</b></font></p>
			<p align="center" style="margin-bottom: 0.2cm"><br/>
<br/>

			</p>
			<p align="center"><font color="#9a6704"><b>sg driver version</b></font></p>
		</td>
		<td width="16%" bgcolor="#fcd3c1" style="background: #fcd3c1" style="border: none; padding: 0cm"><p align="center" style="margin-bottom: 0.2cm">
			<b><font size="4" style="font-size: 14pt">v1+v2</font> interfaces</b></p>
			<p align="center" style="margin-bottom: 0.2cm"><u><b>Non-blocking</b></u></p>
			<p align="center"><b>struct sg_header</b></p>
		</td>
		<td width="19%" bgcolor="#fcd3c1" style="background: #fcd3c1" style="border: none; padding: 0cm"><p align="center" style="margin-bottom: 0.2cm">
			<font color="#5565af"><b><font color="#0066b3"><font size="4" style="font-size: 14pt">v3
			i</font></font><font color="#0066b3"><font size="4" style="font-size: 14pt">nterface</font></font></b></font></p>
			<p align="center" style="margin-bottom: 0.2cm"><font color="#0066b3"><u><b>Non-blocking</b></u></font></p>
			<p align="center"><font color="#0066b3"><b>struct sg_io_hdr</b></font></p>
		</td>
		<td width="15%" bgcolor="#fcd3c1" style="background: #fcd3c1" style="border: none; padding: 0cm"><p align="center" style="margin-bottom: 0.2cm">
			<font color="#5565af"><b><font color="#0066b3"><font size="4" style="font-size: 14pt">v3
			i</font></font><font color="#0066b3"><font size="4" style="font-size: 14pt">nterface</font></font></b></font></p>
			<p align="center" style="margin-bottom: 0.2cm"><font color="#0066b3"><b>BLOCKING</b></font></p>
			<p align="center"><font color="#0066b3"><b>struct sg_io_hdr</b></font></p>
		</td>
		<td width="17%" bgcolor="#fcd3c1" style="background: #fcd3c1" style="border: none; padding: 0cm"><p align="center" style="margin-bottom: 0.3cm">
			<font color="#5565af"><font size="4" style="font-size: 14pt"><b><font color="#a3238e">v4
			interface</font><font color="#a3238e">d</font></b></font></font></p>
			<p align="center" style="margin-bottom: 0.3cm"><font color="#a3238e"><u><b>Non-blocking</b></u></font></p>
			<p align="center"><font color="#a3238e"><b>struct sg_io_v4 (bsg.h)</b></font></p>
		</td>
		<td width="18%" bgcolor="#fcd3c1" style="background: #fcd3c1" style="border: none; padding: 0cm"><p align="center" style="margin-bottom: 0.3cm">
			<font color="#5565af"><b><font color="#a3238e"><font size="4" style="font-size: 14pt">v4
			interface</font></font><font color="#a3238e"><font size="4" style="font-size: 14pt">d</font></font></b></font></p>
			<p align="center" style="margin-bottom: 0.3cm"><font color="#a3238e"><b>BLOCKING</b></font></p>
			<p align="center"><font color="#a3238e"><b>struct sg_io_v4 (bsg.h)</b></font></p>
		</td>
	</tr>
	<tr>
		<td width="16%" height="94" bgcolor="#bee3d3" style="background: #bee3d3" style="border: none; padding: 0cm"><p align="center">
			<font color="#9a6704"><b>sg driver V3.5.36</b></font></p>
			<p align="center"><font color="#9a6704"><b>lk 2.6, 3, 4 and 5.0</b></font></p>
			<p align="center"><font color="#9a6704"><b>interface header ==&gt;</b></font></p>
		</td>
		<td width="16%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			<b>write</b>(2)+<b>read</b>(2)</p>
			<p align="center">include/scsi/sg.h</p>
		</td>
		<td width="19%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			<b>write</b>(2)+<b>read</b>(2)</p>
			<p align="center">include/scsi/sg.h</p>
		</td>
		<td width="15%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			<b>ioctl</b>(SG_IO)</p>
			<p align="center">include/scsi/sg.h</p>
		</td>
		<td width="17%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p align="center">
			not available ^^^</p>
		</td>
		<td width="18%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			not available ***</p>
		</td>
	</tr>
	<tr>
		<td width="16%" height="189" bgcolor="#bee3d3" style="background: #bee3d3" style="border: none; padding: 0cm"><p align="center">
			<font color="#9a6704"><b>sg driver V4.0.x</b></font></p>
			<p align="center"><font color="#9a6704"><b>lk ?</b></font></p>
			<p align="center"><font color="#9a6704"><b>interface header ==&gt;</b></font></p>
		</td>
		<td width="16%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			<b>write</b>(2)+<b>read</b>(2) ****</p>
			<p align="center"><br/>
<br/>

			</p>
			<p align="center">include/uapi/scsi/sg.h</p>
		</td>
		<td width="19%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			<b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>)+</p>
			<p align="center"><b>ioctl</b>(<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>)
			or</p>
			<p align="center"><b>write</b>(2)+<b>read</b>(2) ^^^^</p>
			<p align="center"><br/>
<br/>

			</p>
			<p align="center">include/uapi/scsi/sg.h</p>
		</td>
		<td width="15%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			<b>ioctl</b>(SG_IO)</p>
			<p align="center"><br/>
<br/>

			</p>
			<p align="center">include/uapi/scsi/sg.h</p>
		</td>
		<td width="17%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p align="center">
			<b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)+</p>
			<p align="center"><b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)</p>
			<p align="center"><br/>
<br/>

			</p>
			<p align="center">include/uapi/scsi/sg.h +</p>
			<p align="center">include/uapi/linux/bsg.h</p>
		</td>
		<td width="18%" style="border-top: none; border-bottom: 1px double #808080; border-left: 1px double #808080; border-right: 1px double #808080; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p align="center">
			<b>ioctl</b>(SG_IO)</p>
			<p align="center" style="margin-bottom: 0cm"><br/>

			</p>
			<p align="center" style="margin-bottom: 0cm">include/uapi/scsi/sg.h
			+</p>
			<p align="center">include/uapi/linux/bsg.h</p>
		</td>
	</tr>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 7: sg driver's
support of v1, v2, v3 and v4 interfaces</b></font></p>
<p align="left" style="margin-left: 3.75cm; margin-bottom: 0.1cm"><br/>
***
available via the bsg driver; 
</p>
<p align="left" style="margin-left: 3.75cm; margin-bottom: 0.1cm">^^^
removed from the bsg driver in lk 4.15; 
</p>
<p align="left" style="margin-left: 3.75cm; margin-bottom: 0.1cm">****
the plan is to deprecate the <b>write</b>(2)/<b>read</b>(2) based
interfaces which would leave v1+v2 interfaces unsupported.</p>
<p align="left" style="margin-left: 3.75cm; margin-bottom: 0.1cm">^^^^
warning issued once in log when either <b>write</b>(2) or <b>read</b>(2)
used</p>
<p><br/>
<br/>

</p>
<p>Note that there is no v1+v2 blocking interface. Rather than
completely drop the <b>write</b>(2)+<b>read</b>(2) interface, it
could be kept alive for only v1+v2 interfaces. Applications based on
the v1+v2 interfaces would be written around 20 years ago and need a
low level re-write to use the v3 or v4 non-blocking interfaces. So
what might be dropped is the ability of the v3 interface to use the
<b>write</b>(2)+<b>read</b>(2) interface as the only code change
required should be to change the <b>write</b>(2) to an
<b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>) and the
<b>read</b>(2) to an <b>ioctl</b>(<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>).</p>
<h2 class="western"><a name="__RefHeading___Toc1576_4294551682"></a>15
IOCTLs</h2>
<p>Over time there has been a transfer of functionality from the
<b>write</b>(2) and <b>read</b>(2) system calls to various <b>ioctl</b>(2)s
which are listed below. Using the <b>write</b>(2) and <b>read</b>(2)
system calls in the way that this driver does is frowned upon by the
Linux kernel architects, as is adding new <b>ioctl</b>(2)s! Only 6
new <b>ioctl</b>(2)s have been added in the sg v4 driver as noted in
the status column of the table below. Two of those <b>ioctl</b>(2)s
were proposed in this <a href="https://www.spinics.net/lists/linux-scsi/msg123031.html">post</a>
by a Linux architect (L. Torvalds). And two more (i.e.
SG_IO_SUBMIT_V3 and <font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>)
are very closely related to those proposed. Still, there is a lot of
<i>extra</i> information exchanged between the user space and the
driver to support the new functionality added in v4 of this driver.
That is nearly all done via one new omnibus <b>ioctl</b>(2):
SG_SET_GET_EXTENDED using a 96 byte structure; see the second , third
and fourth tables below.</p>
<p>The following table lists the <b>ioctl</b>(2)s that the sg v4
driver processes. They are in the alphabetical order of the name of
the second <b>ioctl</b>(2) argument. In most cases the scope of the
action of the <b>ioctl</b>(2) is that of the file descriptor, given
as the first argument and referred to below as the <i>current</i>
file descriptor. If the scope is other than the current file
descriptor, that is noted in the second column. Note that there is a
&quot;fall-through&quot; in the last row of this table, so any
<b>ioctl</b>(2)s not processed by this driver will be passed to the
SCSI mid-level and if it doesn't process them and thence onto the LLD
(SCSI low level driver) that owns the &quot;host&quot; that the file
descriptor's device is connected to. If no driver processes an
<b>ioctl</b>(2) then it should return -1 with an errno of ENOTTY
(according to POSIX) but the sometimes other error codes given,
depending on the LLD.</p>
<table width="100%" cellpadding="4" cellspacing="0" style="page-break-after: avoid">
	<col width="66*"/>

	<col width="29*"/>

	<col width="161*"/>

	<tbody>
		<tr valign="top">
			<th width="26%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				ioctl name [hex value]</p>
				<p>second argument to ioctl(2) call</p>
			</th>
			<th width="11%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				Status</p>
				<p>output via 3rd arg ptr unless noted</p>
			</th>
			<th width="63%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				Notes</p>
			</th>
		</tr>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>BLKSECTGET</b> [0x1267]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
				<p>scope: host (HBA)</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this ioctl value replicates what a block layer device file (e.g.
				/dev/sda) will do with the same value. It calls the
				queue_max_sectors() helper on the owning device's command queue.
				The resulting number is multiplied by 512 to get count in bytes
				and output where the third argument points, assumed to be a
				pointer to int (so a maximum of about 2 GB). It represent the
				maximum data size of a single request that the block layer will
				accept.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>BLKTRACESETUP</b> [0xc0481273]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
				<p>scope: device</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				third argument of <b>ioctl</b>(2) is pointer to a struct
				blk_user_trace_setup object. Needs a kernel with
				CONFIG_BLK_DEV_IO_TRACE=y . This <b>ioctl</b>(2) and its siblings
				are passed through to the block layer which implements them: a
				pass-through inside a pass-through</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>BLKTRACESTART</b> [0x1274]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
				<p>scope: device</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				ignores third argument of <b>ioctl</b>(2). See blktrace and
				blkparse utilities in the blktrace package.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>BLKTRACESTOP</b> [0x1275]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
				<p>scope: device</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				ignores third argument of <b>ioctl</b>(2). Part of blktrace
				support.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>BLKTRACETEARDOWN</b> [0x1276]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
				<p>scope: device</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				ignores third argument of <b>ioctl</b>(2). Part of blktrace
				support.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SCSI_IOCTL_GET_BUS_NUMBER</b></p>
				<p style="font-weight: normal">[0x5386]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, deprecated</p>
				<p>scope: host</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				implemented by the SCSI mid-level. Assumes the third argument is
				pointer to int (32 bit) and places a field called 'host_no' in
				it. host_no is an index of SCSI HBAs (host bus adapters) in the
				system. In this case it will the host number that the SCSI device
				is connected to. That SCSI device has been <b>open</b>(2)-ed to
				yield the file descriptor that this <b>ioctl</b>(2) uses. In
				modern Linux usage, this information is better obtained from
				sysfs. Alternatively <b>ioctl</b>(SG_GET_SCSI_ID) can be used
				(see below).</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SCSI_IOCTL_GET_IDLUN </b><span style="font-weight: normal">[0x5382]</span></p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, deprecated</p>
				<p>scope: device</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				implemented by the SCSI mid-level. Assumes the third argument is
				pointer to int (32 bit) and places a packed integer (with 4
				components) in it. The lower 8 bits are a target device number,
				the next 8 bits are the LUN, the next 8 bits are the channel
				number, and the top 8 bits are the host_no mentioned in the
				previous item. There are many things wrong with this from a
				modern SCSI perspective. In modern Linux usage, this information
				is better obtained from sysfs or <b>ioctl</b>(<span style="font-weight: normal">SG_GET_SCSI_ID).</span></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SCSI_IOCTL_PROBE_HOST </b><span style="font-weight: normal">[0x5385]</span></p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, deprecated</p>
				<p>scope: host</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				implemented by the SCSI mid-level. Yields an identifying string
				associated with the host. Assumes the third argument is a pointer
				to a byte array whose length in placed in a (32 bit) int in the
				first 4 bytes. That length will be overwritten by the ASCII byte
				array output. This information can also be obtained from sysfs.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SCSI_IOCTL_SEND_COMMAND</b> [0x1]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, deprecated</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this is the SCSI mid-level pass-through which is very old, found
				in lk 1.0 and it has a very quirky interface. Please do not use.
				May be removed in the future.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_EMULATED_HOST</b> [0x2203]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				seems to be &quot;dead&quot;</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				originally indicated a host emulated SCSI (e.g. ATAPI) but libata
				does not seem to set this value in the host template provided by
				each LLD.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_ACCESS_COUNT</b> [0x2289]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				not supported</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				returns 1 [unless the owning sg device is missing in which case 0
				is returned, very unlikely]</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_COMMAND_Q</b> [0x2270]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				see SG_SET_COMMAND_Q notes below. Yields current state of the
				COMMAND_Q flag held by the this file descriptor.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_KEEP_ORPHAN</b> [0x2288]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				when a synchronous <b>ioctl</b>(SG_IO) is interrupted (e.g. by a
				signal from another process) the default action (depending on the
				signal) may be to terminated the <b>ioctl</b>(2) with an errno of
				EINTR. The driver terms such an inflight command/request an
				&quot;orphan&quot;. The default action is to &quot;throw away&quot;
				the response from the device and clean up the request's
				resources. This loses information such as whether the command
				succeeded. This ioctl returns 0 (the default) or 1 depending on
				whether the request belonging to this file descriptor will throw
				away (when 0) or keep (when 1) the response to interrupted
				requests. Note that closing a sg file descriptor will clean-up
				any outstanding request resources this file descriptor is using
				at the time of the <b>close</b>(2) [in reality that takes place a
				little later (when the last response &quot;lands&quot;) because
				nothing is permitted to suspend a <b>close</b>(2)].</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_LOW_DMA</b> [0x227a]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p style="margin-bottom: 0.2cm">
				active, deprecated</p>
				<p>scope: host</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Yields the host's unchecked_isa_dma flag (0 or 1) via the third
				argument. The 'host' is typically the host bus adapter (HBA) that
				this sg device (the parent of the current file descriptor) is
				connected to.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_NUM_WAITING</b> [0x227d]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				Number of non-blocking requests on the active list that are
				waiting to be read. That &quot;read&quot; can be done with either
				an <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) or a
				<b>read</b>(2) system call. Requests that are <i>inflight</i> are
				not counted. If there are any blocking requests waiting on the
				list, they are not counted. Similar to <b>ioctl</b>(SG_SET_GET_EXTENDED,
				{SG_SEIRV_SUBMITTED}) which additionally counts (non-blocking)
				<i>inflight</i> requests. When using non-blocking multiple
				requests this will be the expected number of responses that
				<b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>,
				FLAG_MULTIPLE_REQS | FLAG_IMMED) will receive. This <b>ioctl</b>(2)
				holds no locks in the sg driver and accesses an atomic integer.
				So it is fast and should never block making it suitable for
				polling. In the presence of other producers or consumers the
				number waiting may change before a user has time to act on the
				result of this call.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_PACK_ID</b> [0x227c]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				the third argument is expected to be a pointer to int. By default
				it will set that int to the pack_id of the first (oldest) command
				that is completed internally but still awaits <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
				or <b>read</b>(2) to finish. If no requests are waiting -1 (i.e.
				the wildcard value) is placed in that int. This <b>ioctl</b>(2)
				yields the <i>pack_id</i> by default, unless the
				SG_CTL_FLAGM_TAG_FOR_PACK_ID boolean has been set on this file
				descriptor.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_REQUEST_TABLE</b> [0x2286]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				The third argument is assumed to point to an array of 16 struct
				sg_req_info objects (that struct is defined in
				include/uapi/scsi/sg.h). First the array is zeroed making all
				req_state fields zero which corresponds to INACTIVE state. Then
				any requests that are active have fields placed in the
				sg_req_info elements. Then if there is still room, requests
				marked as inactive are placed in sg_req_info elements. This
				action stops when either 16 elements are filled or there are no
				more requests associated with the current file descriptor to
				transfer. 
				</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_RESERVED_SIZE</b> [0x2272]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this is the size, in bytes, that the <font color="#ba131a">reserve
				request</font> associated with this file descriptor currently
				has. The third argument is assumed to be a pointer to an int that
				receives this value.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_SCSI_ID</b> [0x2276]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, enhanced in v4</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				the third argument should by a pointer to an object of type
				struct sg_scsi_id . This <b>ioctl</b>(2) fills the fields in that
				structure. The extension in v4 is to use two 'unused' 32 bit
				integers at the end of that struct as an array of 8 bytes to
				which the SCSI LUN is written. This is the preferred LUN format
				from t10.org . This extension does not change the size of struct
				sg_scsi_id . For those looking for the corresponding HCTL tuple
				for the device this file descriptor belongs to ,this <b>ioctl</b>(2)
				is one way: H --&gt; sg_scsi_id::host_no; C --&gt;
				sg_scsi_id::channel, T --&gt; sg_scsi_id::scsi_id and L --&gt;
				sg_scsi_id::scsi_lun[8] . Another way is to use 'lsscsi -g' which
				data-mines in sysfs or the user can write their own sysfs
				data-mining code.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_SG_TABLESIZE</b> [0x227F]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				yields the maximum number of scatter gather elements that the
				associated host (HBA) supports. That is the host through which
				the sg device is attached, that &quot;owns&quot; the given file
				descriptor. The third argument is assumed to point to an int.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_TIMEOUT</b> [0x2201]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, deprecated; timeout 
				</p>
				<p>in seconds is <u>return</u> <u>value</u></p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				the v1 and v2 interfaces did not contain a command timeout field
				so this was a substitute. Both the v3 and v4 interface have a
				command timeout field which is better than using this <b>ioctl</b><span style="font-weight: normal">().
				N.B. The third argument of this ioctl() is </span><u><span style="font-weight: normal">not</span></u><span style="font-weight: normal">
				used.</span></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_TRANSFORM</b> [0x2205]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				seems to be &quot;dead&quot;</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this driver passes this ioctl value through to the SCSI mid-level
				which seems to do nothing with it. Testing reveals that it yields
				an errno of EINVAL</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_GET_VERSION_NUM</b> [0x2282]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				uses the third argument as a pointer to write out a 32 bit
				integer whose latter digits went seen in decimal are in the form
				[x]xyyzz . [x] means blank (space) if zero. This is usually
				expressed as an ASCII string as '[x]x.[y]y.zz' .</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_IO</b> [0x2285]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, added functionality</p>
				<p>in v4 driver</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				both v3 and v4 interface blocking commands can be issued with
				this <b>ioctl</b>(2). Only returns -1 and sets errno when the
				preparation for submitting the command/request encounters a
				problem. Thereafter any problems encountered set the <i>out</i>
				fields in the v3 or v4 interface object. So both should be
				checked.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_IOABORT</b> [0x40a02243]</p>
				<p><br/>

				</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>
<br/>

				</p>
				<p><font color="#a3238e"><u><span style="background: #eeeeee">new
				in v4 driver</span></u></font></p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				only the v4 interface can use this <b>ioctl</b>(2) to abort a
				command in process, using either the pack_id (in the
				<font color="#a3238e">request_extra</font> field) or the tag. The
				current file descriptor is checked first and if no match is found
				then all of the open file descriptors belonging to the current
				device are checked. The pack_id is used by default, unless the
				SG_CTL_FLAGM_TAG_FOR_PACK_ID boolean has been set on this file
				descriptor. If no corresponding request is found (capable of
				being aborted) then errno is set to ENODATA. The completion on an
				aborted command will have DRIVER_SOFT set in the driver_status
				field.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e"><b>SG_IORECEIVE</b></font> [0xc0a02242]</p>
				<p><br/>

				</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e"><u>new in v4 driver</u></font></p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				only the v4 interface can use this <b>ioctl</b>(2) to complete a
				command/request started with asynchronous <b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>)
				on the same file descriptor. If multiple requests are outstanding
				on the same file descriptor, then setting
				<b>ioctl</b>(SG_SET_FORCE_PACK_ID) indicates that subsequent
				requests on this file descriptor should take account of the
				pack_id (in the <font color="#a3238e">request_extra</font> field)
				or the tag (in the <font color="#a3238e">request_tag</font>)
				field to choose a matching response.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3"><b>SG_IORECEIVE_V3</b></font> [0xc0582246]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e"><u>new in v4 driver</u></font></p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				only the v3 interface can use this <b>ioctl</b>(2) to complete a
				command/request started with asynchronous <b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>)
				on the same file descriptor. If multiple requests are outstanding
				on the same file descriptor, then setting
				<b>ioctl</b>(SG_SET_FORCE_PACK_ID) indicates that subsequent
				requests on this file descriptor should take account of the
				pack_id field to choose a matching response.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e"><b>SG_IOSUBMIT</b></font> [0xc0a02241]</p>
				<p><br/>

				</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e"><u>new in v4 driver</u></font></p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				only the v4 interface can use this <b>ioctl</b>(2) to issue
				(submit) new commands. This <b>ioctl</b>(2) will return
				relatively quickly potentially well before the command has
				completed. Each call to <b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
				needs to be paired with a call to <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>)
				using the same (sg) file descriptor. This call is part of the v4
				asynchronous (non-blocking) interface.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#0066b3"><b>SG_IOSUBMIT_V3</b></font> [0xc0582245]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e"><u>new in v4 driver</u></font></p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				only the v3 interface can use this <b>ioctl</b>(2) to issue
				(submit) new commands. This <b>ioctl</b>(2) will return
				relatively quickly potentially well before the command has
				completed. Each call to <b>ioctl</b>(<font color="#0066b3">SG_IOSUBMIT_V3</font>)
				needs to be paired with a call to <b>ioctl</b>(<font color="#0066b3"><span style="font-weight: normal">SG_IORECEIVE_V3</span></font>)
				using the same (sg) file descriptor. This call is part of the v3
				asynchronous (non-blocking) interface.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_NEXT_CMD_LEN</b> [0x2283]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, deprecated</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				only applies to the v2 interface which does <i>not</i> include a
				command (cdb) length field. That assumes the driver can work out
				what the cdb length. While that works for standard cdbs (from
				T10) it may not work for vendor specific commands, hence this
				<b>ioctl(</b>2).</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SCSI_RESET</b> [0x2284]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				third argument should point to an int which should contain one of
				these values: SG_SCSI_RESET_NOTHING[0], SG_SCSI_RESET_DEVICE[1]
				(i.e. LU reset), SG_SCSI_RESET_BUS[2], SG_SCSI_RESET_HOST[3], or
				SG_SCSI_RESET_TARGET[4]. Any one of those values can be OR-ed
				with this mask SG_SCSI_RESET_NO_ESCALATE[0x100]; without that
				mask, the escalation order on failure is 1 -&gt; 4 -&gt; 2 - &gt;
				3 . This <b>ioctl</b> is implemented by the SCSI middle layer.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_COMMAND_Q</b> [0x2271]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				in the v1 and v2 drivers the default was 0 (so no command queuing
				on this file descriptor). In the v3 driver it was 0 until a v3
				interface structure was presented, in which case it was turned on
				(1) for this file descriptor. In the v4 driver it is on (1) by
				default. 0 --&gt; only allow one command per fd; 1 --&gt; allow
				command queuing. When command queuing is off, if a second command
				is presented before the previous has finished and errno of EDOM
				will result.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_DEBUG</b> [0x227e] 
				</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, scope=device</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				0 --&gt; turn off (def), 1 --&gt; turn on . Currently the only
				impact of setting this is to print out sense data (to the log) of
				any request on all fds that belong to the current device.
				Typically only requests that yield a SCSI status of &quot;Check
				condition&quot; provide sense data.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_FORCE_LOW_DMA</b> [0x2279]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				does nothing</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				users of modern Linux systems should not concern themselves with
				&quot;low DMA&quot;, this comes from the ISA era. 0 --&gt; use
				adapter setting (def); 1 --&gt; force &quot;low dma&quot;.
				However this <b>ioctl</b>(2) has since been neutered and does
				nothing.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_FORCE_PACK_ID</b> [0x227b]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				when activated, a non-blocking response is only accepted if it
				has a matching pack_id (or tag). A pack_id (or tag) of -1 is
				treated as a wildcard. In the v4 interface the <font color="#a3238e">request_extra</font>
				field is used for the pack_id. A non-blocking request is finished
				with either <b>ioctl</b>(SG_IORECEIVE[_V3]) or <b>read</b>(2).
				The third argument to this <b>ioctl</b>(2) is assumed to be a
				pointer to a 32 bit integer. 0 --&gt; take the oldest available
				response (def); 1 --&gt; match on pack_id (or tag) given in each
				subsequent request on this fd. Even though the third argument is
				a pointer to int, this <b>ioctl</b>(2) is effectively boolean.
				The default is to use the pack_id rather than the tag unless
				SG_SET_GET_EXTENDED{SG_CTL_FLAGM_TAG_FOR_PACK_ID} is active on
				this file descriptor.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_GET_EXTENDED</b> [0xc0602251]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#a3238e"><u>new in v4 driver</u></font></p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				takes pointer to 96 byte <font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">sg_extended_info</font></font></font>
				structure; it can set and get 32 bit values and it can set and
				get boolean values. Each <b>ioctl</b>(2) can perform more than
				one action. Explained in the following tables and associated
				descriptions.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_KEEP_ORPHAN</b> [0x2287]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				how to treat a SCSI response when a <b>ioctl</b>(SG_IO), <b>read</b>(2)
				or <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) that
				is waiting is interrupted. 0 --&gt; drop it (def); 1 -&gt; hold
				it so the response can be fetched with either another <b>read</b>(2)
				or <b>ioctl</b>(<font color="#a3238e">SG_IORECEIVE</font>) call</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_RESERVED_SIZE</b> [0x2275]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				sets or resets the size of the <font color="#ba131a">reserve
				request</font> data buffer size of this file descriptor to the
				given value (in bytes). If this file descriptor is in use (i.e.
				sending a SCSI command) then this <b>ioctl</b>(2) will fail with
				an errno of EBUSY.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_TIMEOUT</b> [0x2201]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active, deprecated</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				command timeout in seconds (pointed to by third argument). See
				&quot;_GET_&quot; notes.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>SG_SET_TRANSFORM</b> [0x2204]</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				seems to be &quot;dead&quot;</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				this driver passes this ioctl value through to the SCSI mid-level
				which seems to do nothing with it. Testing reveals that it yields
				an errno of EINVAL</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="26%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt; any others&gt;&gt;</p>
			</td>
			<td width="11%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				??</p>
			</td>
			<td width="63%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				sent through to the SCSI mid-level (and then to the LLD
				associated with the device the fd belongs to) for further
				processing.</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm; font-style: normal">
<font size="3" style="font-size: 12pt"><b>Table 8: ioctl(2)s accepted
by sg driver</b></font></p>
<p><br/>
<br/>

</p>
<p>The third argument to <b>ioctl</b>(SG_SET_GET_EXTENDED) is a
pointer to an object of type struct <font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">sg_extended_info</font></font></font>
. That structure is found in the &lt;scsi/sg.h&gt; header and is
shown here:</p>
<pre class="western">struct sg_extended_info {
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">sei_wr_mask</font></font><font size="2" style="font-size: 11pt">;       /* OR-ed SG_SEIM_* user-&gt;driver values */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">sei_rd_mask</font></font><font size="2" style="font-size: 11pt">;       /* OR-ed SG_SEIM_* driver-&gt;user values */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">ctl_flags_wr_mask</font></font><font size="2" style="font-size: 11pt">; /* OR-ed SG_CTL_FLAGM_* values */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">ctl_flags_rd_mask</font></font><font size="2" style="font-size: 11pt">; /* OR-ed SG_CTL_FLAGM_* values */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">ctl_flags</font></font><font size="2" style="font-size: 11pt">;         /* bit values OR-ed, see SG_CTL_FLAGM_* */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">read_value</font></font><font size="2" style="font-size: 11pt">;        /* write SG_SEIRV_*, read back related */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">reserved_sz</font></font><font size="2" style="font-size: 11pt">;       /* data/sgl size of pre-allocated request */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">tot_fd_thresh</font></font><font size="2" style="font-size: 11pt">;     /* total data/sgat for this fd, 0: no limit */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">minor_index</font></font><font size="2" style="font-size: 11pt">;       /* rd: kernel's sg device minor number */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">share_fd</font></font><font size="2" style="font-size: 11pt">;          /* SHARE_FD and CHG_SHARE_FD use this */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">sgat_elem_sz</font></font><font size="2" style="font-size: 11pt">;      /* sgat element size (must be power of 2) */</font>
       <font size="2" style="font-size: 11pt">int32_t </font><font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">num</font></font></font><font size="2" style="font-size: 11pt">;      </font><font size="2" style="font-size: 11pt">		    </font><font size="2" style="font-size: 11pt">/* </font><font color="#000000"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">blk_poll: loop_count (-1 -&gt; spin)</font></font></font><font size="2" style="font-size: 11pt"> */</font>
        <font size="2" style="font-size: 11pt">uint32_t </font><font color="#6b6400"><font size="2" style="font-size: 11pt">pad_to_96</font></font><font size="2" style="font-size: 11pt">[</font><font size="2" style="font-size: 11pt">48</font><font size="2" style="font-size: 11pt">];     /* pad so struct is 96 bytes long */</font>
};</pre><p style="margin-bottom: 0cm">
If both the <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">sei_wr_mask</span></font></font></code><code class="western">
</code>and <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">sei_rd_mask</span></font></font></code>
fields are zero then <b>ioctl</b>(SG_SET_GET_EXTENDED) does nothing.
If those fields are non-zero then they should contain one or more of
the following mask values OR-ed together. The field names of struct
sei_extended_info are shown in <i>italics</i>:</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<table width="100%" cellpadding="2" cellspacing="0" style="page-break-after: avoid; page-break-inside: avoid">
	<col width="50*"/>

	<col width="49*"/>

	<col width="157*"/>

	<tbody>
		<tr valign="top">
			<th width="20%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				SG_SET_GET_EXTENDED</p>
				<p><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal"><span style="font-weight: normal">sei_wr_mask</span></span></font></font></code>
				and <code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">sei_rd_mask</span></span></font></code>
				<span style="font-variant: normal"><span style="font-style: normal">values</span></span></p>
			</th>
			<th width="19%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				Associated field(s)</p>
				<p><br/>

				</p>
			</th>
			<th width="61%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				Notes [fd: file descriptor given as 1st arg to ioctl(2)]</p>
			</th>
		</tr>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_</b><font color="#000000"><b>BLK_POLL</b></font>
				[0x100]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">num</font></font></font><font color="#6b6400"><span style="text-decoration: none"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt"> </font></font></span></font><font color="#000000"><span style="text-decoration: none"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">[raw</font></font></span></font><font color="#000000"><span style="text-decoration: none"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">: read after write</font></font></span></font><font color="#000000"><span style="text-decoration: none"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">]</font></font></span></font></pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				calls blk_poll() <font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">num</font></font></font>
				times for each request associated with the current file
				descriptor that has <b>SGV4_FLAG_</b><font color="#000000"><b>HIPRI</b></font>
				set. If <font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">num</font></font></font>
				is 0 then call blk_poll() once for each qualifying request; if it
				is negative call blk_poll(spin&lt;-true) for each qualifying
				request. Places the number of requests found/started back in the
				<font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">num</font></font></font>
				field.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_CHG_SHARE_FD</b> [0x40]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><span style="text-decoration: none"><font size="2" style="font-size: 11pt"><span style="font-style: normal">share_fd</span></font></span></font></code><span style="text-decoration: none"><span style="font-style: normal">  </span></span>'read before write' [rbw]</pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when written, this is only valid if fd is the <font color="#000000"><u>read-</u></font><u>side</u>
				of a share. If so <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">share_fd</span></font></font></code>
				replaces the prior <font color="#000000"><u>write-side</u></font>
				fd (which is the value read back) so that <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">share_fd</span></font></font></code>
				becomes the new <font color="#000000"><u>write-side</u></font> of
				a fd share.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_CTL_FLAGS</b> [0x1]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">ctl_flags</span></font></font><font size="2" style="font-size: 11pt"><span style="font-style: normal">, </span></font><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">ctl_flags_wr_mask</span></font></font> and
<font color="#6b6400"><font size="2" style="font-size: 11pt">ctl_flags_rd_mask</font></font></pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				three fields in a <font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">sg_extended_info</font></font></font>
				object are associated with this variant of the <b>ioctl</b>(2), a
				value mask, a write mask and a read mask. The mask value are the
				SG_CTL_FLAGM_* values shown in the following table.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_</b><b>EVENTFD </b><span style="font-weight: normal">[0x</span><span style="font-weight: normal">2</span><span style="font-weight: normal">00]</span></p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">share_fd</span></font></font></code> [rbw]</pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				for passing a user space generated file descriptor created by
				<b>eventfd</b>(2) to this driver. If the sg file descriptor (i.e.
				first argument to the <b>ioctl</b>(2)) already has a eventfd
				associated with it then this <b>ioctl</b>(2) will fail with an
				errno of EBUSY. To undo: see <b>SG_CTL_FLAGM_RM_E</b><b>VENT</b><b>FD</b><span style="font-weight: normal">
				in table 10.</span></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_MINOR_INDEX</b> [0x10]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><span style="text-decoration: none"><font size="2" style="font-size: 11pt"><span style="font-style: normal">minor_index</span></font></span></font></code> 'read only' [ro]</pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when read places the minor number of the sg device that this fd
				is associated with in <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">minor_index</span></font></font></code>
				. For example after <b>open</b>(2)-ing &quot;/dev/sg3&quot; that
				fd should place 3 in the <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">minor_index</span></font></font></code>
				field.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<span style="font-variant: normal"><span style="font-style: normal"><b>SG_SEIM_READ_VAL</b></span></span>
				[0x2]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><span style="text-decoration: none"><font size="2" style="font-size: 11pt"><span style="font-style: normal">read_value</span></font></span></font></code><span style="text-decoration: none"> 'read after write' [raw]</span></pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when a known value (see SG_SEIRV_* entries in table below) is
				written to <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">read_value</span></font></font></code>
				then after this <b>ioctl</b>(2) the corresponding value will be
				in the <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">read_value</span></font></font></code>
				field. For this action, <span style="font-variant: normal"><font size="2" style="font-size: 11pt"><span style="font-style: normal"><span style="font-weight: normal">SG_SEIM_READ_VAL
				should be OR-ed into</span></span></font></span> <u>both</u>
				<code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">sei_wr_mask</span></font></font></code>
				<font size="2" style="font-size: 11pt">and </font><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">sei_rd_mask</span></font></font></code>
				<font size="2" style="font-size: 11pt">fields</font><span style="font-variant: normal"><font size="2" style="font-size: 11pt"><span style="font-style: normal"><span style="font-weight: normal">.</span></span></font></span></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_RESERVED_SIZE</b> [0x4]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">reserved_sz</span></font></font></code><font size="2" style="font-size: 11pt"> </font>[raw]</pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when written, this fd's <font color="#ba131a">reserve request</font>'s
				data buffer will be resized to <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">reserved_sz</span></font></font></code>
				bytes.The given value may be trimmed down by system limits. When
				read, the actual size of this fd's (resized) data buffer will be
				placed in <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">reserved_sz</span></font></font></code>
				when this <b>ioctl</b>(2) completes. So when both written and
				read, this <b>ioctl</b>(2) is very similar to
				<b>ioctl</b>(SG_SET_RESERVED_SIZE) combined with
				<b>ioctl</b>(SG_GET_RESERVED_SIZE) .</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_SGAT_ELEM_SZ</b> [0x80]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">sgat_elem_sz</span></font></font></code> [rbw]</pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when the driver builds a scatter gather list for a request's data
				buffer a fixed element size is used which is a power of 2 and
				greater than or equal to the machine's page size (often 4 KB).
				The default size is currently 32 KB (2**15). When written,
				<code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">sgat_elem_sz</span></font></font></code>
				will replace the prior element size. When read the prior element
				size is placed in <code class="western"><font color="#6b6400"><span style="font-style: normal">sgat_elem_sz</span></font></code>
				. Effects future requests on this fd that use data-in or
				data-out.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_SHARE_FD</b> [0x20]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">share_fd</span></font></font></code> [rbw]</pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p style="margin-bottom: 0cm">
				when written, a shared fd relationship is set up by this
				<b>ioctl</b>(2). The fd that is the first argument of the
				<b>ioctl</b>(2) should be the future <font color="#000000"><u>write-side</u></font>
				and <code class="western"><font color="#6b6400"><span style="font-style: normal">share_fd</span></font></code>
				identifies the future <font color="#000000"><u>read-side</u></font>.
				Neither fd can already be part of a share. When read (read before
				write), if successful <code class="western"><font color="#6b6400"><span style="font-style: normal">share_fd</span></font></code>
				should yield 0xffffffff which indicates (internally) both fds
				were not previously part of a share.</p>
				<p>When read, but not written, then <code class="western"><font color="#6b6400"><span style="font-style: normal">share_fd</span></font></code>
				will yield: 0xffffffff (-1) if the first argument is not part of
				a share; 0xfffffffe (-2) if the first argument is the <font color="#000000"><u>read-</u></font><u>side</u>
				of a share; or the <font color="#000000"><u>read-side</u></font><u>'s</u>
				fd if the first argument is the <font color="#000000"><u>write-side</u></font>
				of a share.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="20%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIM_TOT_FD_THRESH</b> [0x8]</p>
			</td>
			<td width="19%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><pre class="western"><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">tot_fd_thresh</span></font></font></code> [rbw]</pre>
			</td>
			<td width="61%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				By default, a limit of all data buffers that can be active on a
				fd is set at 16 MB. A request that tries to exceed this will be
				rejected with an errno of E2BIG. The default can be changed by
				writing to <code class="western"><font color="#6b6400"><span style="font-style: normal">tot_fd_thresh</span></font></code>
				. A value of 0 is taken as unlimited; there will be a slight
				improvement of the driver throughput in this case. The current
				[or previous] value may be read.</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm"><font size="3" style="font-size: 12pt"><b><span style="font-style: normal">Table
</span><span style="font-style: normal">9</span><span style="font-style: normal">:
ioctl(SG_SET_GET_EXTENDED)</span><i> </i></b><code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal"><span style="font-weight: normal">sei_wr_mask</span></span></font></font></code><i><b>
</b></i><span style="font-style: normal"><b>and</span><i> </i></b><code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">sei_rd_mask</span></span></font></code><i><b>
</b></i><span style="font-style: normal"><b>values</b></span></font></p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p><font size="3" style="font-size: 12pt">An example follows of
changing the scatter gather list element size to 64 KB and reading
prior value:</font></p>
<pre class="western">        <font size="3" style="font-size: 12pt">sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">sei_wr_mask</font></font><font size="3" style="font-size: 12pt"> |= SG_SEIM_SGAT_ELEM_SZ;</font>
        <font size="3" style="font-size: 12pt">sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">sei_rd_mask</font></font> <font size="3" style="font-size: 12pt">|= SG_SEIM_SGAT_ELEM_SZ;</font>
        <font size="3" style="font-size: 12pt">sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">sgat_elem_sz</font></font> <font size="3" style="font-size: 12pt">= 64 * 102</font><font size="3" style="font-size: 12pt">4</font><font size="3" style="font-size: 12pt">;</font>
        <font size="3" style="font-size: 12pt">if (ioctl(sg_fd, SG_SET_GET_EXTENDED, &amp;sei) &lt; 0) {</font>
                <font size="3" style="font-size: 12pt">err = errno;</font>
                <font size="3" style="font-size: 12pt">goto error_processing;</font>
        <font size="3" style="font-size: 12pt">}</font>
        <font size="3" style="font-size: 12pt">prev_sgat_elem_sz = sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">sgat_elem_sz</font></font><font size="3" style="font-size: 12pt">;</font>
        <font size="3" style="font-size: 12pt">/* success */</font></pre><p style="margin-bottom: 0cm">
The <code class="western"><font color="#6b6400"><span style="font-style: normal">ctl_flags</span></font></code>
field can be viewed as 32 boolean (i.e. 1 bit) fields. If both the
<code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">ctl_flags_wr_mask</span></font></font></code>
and <code class="western"><font color="#6b6400"><span style="font-style: normal">ctl_flags_rd_mask</span></font></code>
fields are zero then <b>ioctl</b>(SG_SET_GET_EXTENDED) does nothing
with the <code class="western"><font color="#6b6400"><span style="font-style: normal">ctl_flags</span></font></code>
field. All three fields should contain one or more of the following
mask values OR-ed together:</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<table width="100%" cellpadding="2" cellspacing="0" style="page-break-after: avoid; page-break-inside: avoid">
	<col width="62*"/>

	<col width="26*"/>

	<col width="168*"/>

	<tbody>
		<tr valign="top">
			<th width="24%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				SG_SET_GET_EXTENDED</p>
				<p><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>,
				<font color="#6b6400"><span style="font-weight: normal">ctl_flags_wr_mask</span></font>
				+ <font color="#6b6400"><span style="font-weight: normal">ctl_flags_rd_mask</span></font>
				values</p>
			</th>
			<th width="10%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				Type</p>
				<p><br/>

				</p>
			</th>
			<th width="66%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				Notes</p>
				<p><font color="#6b6400"><span style="font-weight: normal">ctl_flags_wr_mask</span></font><font color="#000000"><span style="font-weight: normal">
				</span></font><font color="#000000"><span style="font-weight: normal">is
				shortened to </span></font><font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font><font color="#000000"><span style="font-weight: normal">
				below,   </span></font><font color="#6b6400"><span style="font-weight: normal">ctl_flags_rd_mask
				</span></font><font color="#000000"><span style="font-weight: normal">is
				shortened to</span></font><font color="#000000"><span style="font-weight: normal">
				 </span></font><font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font></p>
			</th>
		</tr>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_EXCL_WAITQ</b> [0x1000]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[rbw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				by default, when waiting for an event (which is a request
				reaching its internal completion point) a
				wait_event_interruptible() call is made. When this flag is set
				the &quot;_exclusive()&quot; variant of that call is made. The
				difference is that the wake_up() call in each internal completion
				point only wakes up the first &quot;exclusive&quot; wait
				detected, then stops. All non-&quot;exclusive&quot; waits (if
				any) are woken up before any exclusive waits. This flag addresses
				what is known as the &quot;thundering herd&quot; problem with
				wait queues. N.B. this is a per file descriptor setting; IOWs
				applications waiting on <i>other</i> file descriptors (even if
				they are the same sg device) do <u>not</u> effect the waits on
				the current file descriptor (i.e. the file descriptor on which
				this <b>ioctl</b>(2) is called). When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set then the _exclusive variant is selected thereafter. If
				that latter bit is clear then the wait_event_interruptible() call
				 is selected thereafter. When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				indicates the selection state <i><u>before</u></i> the change, if
				any.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_IS_</b><font color="#000000"><b>READ_SIDE</b></font>
				[0x40]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				read-only [ro]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl if this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set implies this fd is part of a file share <i>and</i> this is
				the <font color="#000000"><u>read-</u></font><u>side</u></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_IS_SHARE</b> [0x20]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				read-only [ro]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl if this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set implies this fd is part of a file share 
				</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_</b><b>READ_S</b><b>I</b><b>D</b><b>E</b><b>_ERR</b>
				[0x200]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[ro]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				i<font color="#000000">ndicates</font> if the <font color="#000000"><u>read-side</u></font><u>'s</u>
				request has completed with a non-zero SCSI status or other driver
				error. <font color="#000000">If set</font> the shared request
				state is terminated (i.e. the <font color="#000000"><u>write-side</u></font>
				will not be able to issue an associated <font color="#000000"><u>write-side</u></font>
				request). This may be used either on the <font color="#000000"><u>read-side</u></font><u>'s</u>
				or <font color="#000000"><u>write-side</u></font><u>'s</u> fd</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_</b><b>READ_S</b><b>I</b><b>D</b><b>E</b><b>_FINI</b>
				[0x100]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[rbw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				i<font color="#000000">ndicates</font><font color="#000000"> </font>when
				set that the <font color="#000000"><u>read-side</u></font>'s
				request has completed and is waiting for the <font color="#000000"><u>write-side</u></font>
				request to start. This may be used either on the <font color="#000000"><u>read-side</u></font><u>'s</u>
				or <font color="#000000"><u>write-side</u></font><u>'s</u> fd.
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set , on either side of a file share, if the <font color="#000000"><u>write-side</u></font>
				of a request share is pending, then the shared buffer is
				released. IOWs the request share is finished at this point. If
				the bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear, no action is taken. When written to 0 there is no
				action.</p>
				<p>When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl if this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set that implies the <font color="#000000"><u>read-side</u></font><font color="#000000"><span style="text-decoration: none">
				</span></font><font color="#000000"><span style="text-decoration: none">request
				has completed; </span></font><font color="#000000"><span style="text-decoration: none">if
				this bit in </span></font><font color="#6b6400"><span style="text-decoration: none"><span style="font-weight: normal">ctl_flags</span></span></font><font color="#000000"><span style="text-decoration: none">
				is </span></font><font color="#000000"><span style="text-decoration: none">clear
				then the  </span></font><font color="#000000"><u>read-side</u></font><font color="#000000"><span style="text-decoration: none">
				</span></font><font color="#000000"><span style="text-decoration: none">request
				has not completed. The state reported is before any change (i.e.
				read before write [rbw]).</span></font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_MORE_ASYNC</b> <span style="font-weight: normal">[0x</span><span style="font-weight: normal">8</span><span style="font-weight: normal">00]</span></p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[rbw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				The blk_get_request() call can still block in standard async
				mode. When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set , then subsequent  non-blocking calls to
				<b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
				will yield EBUSY in the case when the blk_get_request() call
				would block. When the bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear then the blk_get_request() call <font color="#000000">may</font>
				block. This latter state (i.e. &quot;cleared&quot;) is the
				default for backward compatibility.</p>
				<p>When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				<font color="#000000">reflect the state of this flag </font><font color="#000000"><i>prior</i></font><font color="#000000">
				to any change.</font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_NO_DURATION </b><span style="font-weight: normal">[0x400]</span></p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[rbw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set , then subsequent requests on this file descriptor <i>will
				not</i> calculate command duration. This state bypasses two
				ktime_get_bootime() calls per command. When the bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear then subsequent requests on this file descriptor <i>will</i>
				calculate command duration; this is the default action.</p>
				<p>When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				<font color="#000000">reflect the state of this flag </font><font color="#000000"><i>prior</i></font><font color="#000000">
				to any change.</font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_NO_WAIT_POLL </b><span style="font-weight: normal">[0x8000]</span></p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[rbw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				modifies the action of the <b>poll</b>(2) system call on current
				file descriptor. When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set , then if no requests are waiting (i.e. passed the
				internal completion point) and the <b>poll</b>(2) call requests a
				non-zero timeout, then POLLERR is set for this file descriptor
				(rather than waiting). Designed to be used with request that <font color="#000000">use
				the </font><font color="#000000"><b>SGV4_FLAG_NO_WAITQ</b></font><font color="#000000">
				flag: without a wait queue entry there is no point in </font><font color="#000000"><b>poll</b></font><font color="#000000">(2)
				waiting hence it generates POLLERR and moves on.</font><font color="#000000">
				If </font><font color="#000000">the corresponding bit</font><font color="#000000">
				in </font><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font><font color="#000000">
				is </font><font color="#000000">clear, then </font><font color="#000000"><b>poll</b></font><font color="#000000">(2)
				</font><font color="#000000">will act as per its generic
				definition and wait, even though no event will come; this is the
				default action.</font></p>
				<p><font color="#000000">W</font><font color="#000000">hen </font><font color="#000000">this
				bit is set in </font><font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font><font color="#000000">,
				</font><font color="#000000">then after the ioctl this bit in
				</font><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font><font color="#000000">
				</font><font color="#000000">reflect the state of this flag </font><font color="#000000"><i>prior</i></font><font color="#000000">
				to any change.</font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_ORPHANS</b> [0x8]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[ro]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl if this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set implies there is one or more orphaned commands/request
				associated with this fd. When the bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear then there are no orphaned commands/request associated
				with this fd.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_OTHER_OPENS</b> [0x4]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[ro]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				when this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl if this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set implies there are other sg driver <b>open</b>(2)s active
				on this sg device. When the bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear then there this is the only file descriptor active on
				this sg device.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_Q_TAIL</b> [0x10]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				read-after-write [raw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set then <font color="#000000">this</font> causes the
				following commands/requests on this fd to be queued to the block
				layer at the tail of its queue. <font color="#000000">If </font><font color="#000000">the
				corresponding bit</font><font color="#000000"> in </font><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font><font color="#000000">
				is </font><font color="#000000">clear, then </font><font color="#000000">this</font>
				causes <font color="#000000">requests</font> to be queued at head
				(the default). Each v3 and v4 command can use the
				SG_FLAG_Q_AT_TAIL or SG_FLAG_Q_AT_HEAD OR-ed into the <font color="#0066b3">fla</font><font color="#a3238e">gs</font>
				field to override this setting.</p>
				<p> <font color="#000000">W</font><font color="#000000">hen </font><font color="#000000">this
				bit is set in </font><font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font><font color="#000000">,
				</font><font color="#000000">then after the ioctl this bit in
				</font><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font><font color="#000000">
				</font><font color="#000000">reflect the state of this flag </font><font color="#000000"><i>after</i></font><font color="#000000">
				any change.</font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_</b><b>RM_E</b><b>VENT</b><b>FD</b> [0x4000]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[rbw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set then <font color="#000000">this</font> undoes the effect
				of the previous <b>ioctl</b>(<span style="font-weight: normal">sg_fd,
				SG_SET_GET_EXTENDED(SG_SEIM_</span><span style="font-weight: normal">EVENTFD</span><span style="font-weight: normal">)).
				It has no effect if there is no current even</span><span style="font-weight: normal">t</span><span style="font-weight: normal">fd
				associated with this sg file descriptor.</span><span style="font-weight: normal">
				</span><font color="#000000"><span style="font-weight: normal">If
				</span></font><font color="#000000"><span style="font-weight: normal">the
				corresponding bit</span></font><font color="#000000"><span style="font-weight: normal">
				in </span></font><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font><font color="#000000"><span style="font-weight: normal">
				is </span></font><font color="#000000"><span style="font-weight: normal">clear</span></font><font color="#000000"><span style="font-weight: normal">,
				nothing is changed.</span></font></p>
				<p><font color="#000000"><span style="font-weight: normal">W</span></font><font color="#000000"><span style="font-weight: normal">hen
				</span></font><font color="#000000"><span style="font-weight: normal">this
				bit is set in </span></font><font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font><font color="#000000"><span style="font-weight: normal">,
				</span></font><font color="#000000"><span style="font-weight: normal">then
				after the ioctl this bit in </span></font><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font><font color="#000000"><span style="font-weight: normal">
				</span></font><font color="#000000"><span style="font-weight: normal">reflect
				the state of this flag </span></font><font color="#000000"><span style="font-weight: normal">(i.e.
				true if evenfd associated, false otherwise) </span></font><font color="#000000"><i><span style="font-weight: normal">prior</span></i></font><font color="#000000"><span style="font-weight: normal">
				to any change.</span></font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_SNAP_DEV</b> [0x2000]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[rbw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set then the state of the owning device (e.g. /dev/sg3)
				<i>overwrites</i> the single internal buffer. That internal
				buffer can be viewed with 'cat
				/sys/kernel/debug/scsi_generic/snapped' and its format is similar
				to that seen from 'cat /sys/kernel/debug/scsi_generic/snapshot'.
				If the bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear the action is similar but the state information is
				<i>appended</i> to that internal buffer. If the internal buffer
				is already over half full then the previous contents are
				overwritten.</p>
				<p>When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				i<font color="#000000">ndicates</font> when clear that the
				internal buffer was empty <i>before</i> any change; and when set
				it was non-empty.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_TAG_FOR_PACK_ID</b> [0x2]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[raw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set then that causes the following commands/requests on this
				fd to use the tag field rather than pack_id (in
				sg_io_v4::<font color="#5c2d91">request_extra</font>).  If the
				bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear then that causes the following commands/requests on this
				fd to use the pack_id (in sg_io_v4::<font color="#5c2d91">request_extra</font>)
				rather than the tag field; this is the default.</p>
				<p>When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				<font color="#000000">reflect the state of this flag </font><font color="#000000"><i>after
				</i></font><font color="#000000">any change.</font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_TIME_IN_NS</b> [0x1]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[raw]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set then that causes the following commands/requests to this
				fd to use command/request duration calculations to be done in
				nanoseconds. If the bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is clear then that causes duration calculations to be done in
				milliseconds which is the default.</p>
				<p>When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				<font color="#000000">reflect the state of this flag </font><font color="#000000"><i>after
				</i></font><font color="#000000">any change.</font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="24%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_CTL_FLAGM_UNSHARE</b> [0x80]</p>
			</td>
			<td width="10%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				[w, rd--&gt;0]</p>
			</td>
			<td width="66%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				When this bit is set in <font color="#6b6400"><span style="font-weight: normal">wr_mask</span></font>,
				then if prior to the ioctl the corresponding bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				is set then this will undo the share relationship between a
				<font color="#000000"><u>read-side</u></font> fd and a <font color="#000000"><u>write-side</u></font>
				fd. It can be sent to either fd. If a shared command/request is
				active using either fd then this <b>ioctl</b>(2) will fail with
				an errno of EBUSY. If no share relationship exists for the given
				fd this <b>ioctl</b>(2) will return 0 and do nothing. <font color="#000000"><span style="font-weight: normal">If
				</span></font><font color="#000000"><span style="font-weight: normal">the
				corresponding bit</span></font><font color="#000000"><span style="font-weight: normal">
				in </span></font><font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font><font color="#000000"><span style="font-weight: normal">
				is </span></font><font color="#000000"><span style="font-weight: normal">clear</span></font><font color="#000000"><span style="font-weight: normal">,
				nothing is changed.</span></font></p>
				<p>When this bit is set in <font color="#6b6400"><span style="font-weight: normal">rd_mask</span></font>,
				then after the ioctl this bit in <font color="#6b6400"><span style="font-weight: normal">ctl_flags</span></font>
				<font color="#000000">is cleared.</font></p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm"><font size="3" style="font-size: 12pt"><b><span style="font-style: normal">Table
</span><span style="font-style: normal">10</span><span style="font-style: normal">:
ioctl(SG_SET_GET_EXTENDED) </span></b><code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">ctl_flags</span></span></font></code><i><b>,
</b></i><code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">ctl_flags_wr_mask</span></span></font></code><i><b>
</b></i><span style="font-style: normal"><b>and</span><i>
</i></b><code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">ctl_flags_rd_mask</span></span></font></code><i><b>
</b></i><span style="font-style: normal"><b>values</b></span></font></p>
<p><br/>
<br/>

</p>
<p><font size="3" style="font-size: 12pt">For example to set command
duration time to nanoseconds, the following snippet of code could be
used. It is assumed that sei is an object of type struct
<font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">sg_extended_info</font></font></font>
and that it has been zeroed out:</font></p>
<pre class="western">        <font size="3" style="font-size: 12pt">/* Change a setting on this file descriptor */</font>
        <font size="3" style="font-size: 12pt">sei.<font color="#6b6400">sei_wr_mask</font> |= SG_SEIM_CTL_FLAGS;</font>
        <font size="3" style="font-size: 12pt">sei.<font color="#6b6400">ctl_flags_wr_mask</font> |= SG_CTL_FLAGM_TIME_IN_NS;</font>
        <font size="3" style="font-size: 12pt">sei.<font color="#6b6400">ctl_flags</font> |= SG_CTL_FLAGM_TIME_IN_NS;</font>
        <font size="3" style="font-size: 12pt">if (ioctl(sg_fd, SG_SET_GET_EXTENDED, &amp;sei) &lt; 0) {</font>
                <font size="3" style="font-size: 12pt">err = errno;</font>
                <font size="3" style="font-size: 12pt">goto error_processing;</font>
        <font size="3" style="font-size: 12pt">}</font>
        <font size="3" style="font-size: 12pt">/* success, request duration time henceforth in nanoseconds */</font>
        <font size="3" style="font-size: 12pt">/* */</font>
        <font size="3" style="font-size: 12pt">/* </font><font color="#000000"><font face="Liberation Mono, monospace"><font size="3" style="font-size: 12pt">Fetch</font></font></font><font size="3" style="font-size: 12pt"> a setting on this file descriptor */</font>
        <font size="3" style="font-size: 12pt">sei.<font color="#6b6400">sei_</font><font color="#6b6400">rd</font><font color="#6b6400">_mask</font> |= SG_SEIM_CTL_FLAGS;</font>
        <font size="3" style="font-size: 12pt">sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">ctl_flags_</font></font><font color="#6b6400"><font size="3" style="font-size: 12pt">rd</font></font><font color="#6b6400"><font size="3" style="font-size: 12pt">_mask</font></font><font size="3" style="font-size: 12pt"> |= SG_CTL_</font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">READ_S</span></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">I</span></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">D</span></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">E</span></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">_FINI</span></font><font size="3" style="font-size: 12pt">;</font>
        <font size="3" style="font-size: 12pt">if (ioctl(sg_fd, SG_SET_GET_EXTENDED, &amp;sei) &lt; 0) {</font>
                <font size="3" style="font-size: 12pt">err = errno;</font>
                <font size="3" style="font-size: 12pt">goto error_processing;</font>
        <font size="3" style="font-size: 12pt">}</font>
        <font size="3" style="font-size: 12pt">if (sei.<font color="#6b6400">ctl_flags</font> &amp; SG_CTL_<span style="font-weight: normal">READ_S</span><span style="font-weight: normal">I</span><span style="font-weight: normal">D</span><span style="font-weight: normal">E</span><span style="font-weight: normal">_FINI) {</span></font>
                <font size="3" style="font-size: 12pt">/* </font><font color="#000000"><font face="Liberation Mono, monospace"><font size="3" style="font-size: 12pt">read-side request has completed</font></font></font><font size="3" style="font-size: 12pt"> */</font>
        <font size="3" style="font-size: 12pt">} else {</font>
                <font size="3" style="font-size: 12pt">/* <font color="#000000"><font face="Liberation Mono, monospace">read-side request has not completed</font></font> */</font>
        <font size="3" style="font-size: 12pt">}</font>
</pre><p>
<font size="3" style="font-size: 12pt">If the user wants maximum
speed (i.e. smallest overhead and </font><font size="3" style="font-size: 12pt">latency)
they may want to experiment with setting </font><font size="3" style="font-size: 12pt"><b>SG_CTL_FLAGM_EXCL_WAITQ,
SG_CTL_FLAGM_MORE_ASYNC </b></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">and/or</span></font><font size="3" style="font-size: 12pt"><b>
SG_CTL_FLAGM_NO_DURATION </b></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">flags.
If  </span></font><font size="3" style="font-size: 12pt"><b>SG_CTL_FLAGM_EXCL_WAITQ
</b></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">is</span></font><font size="3" style="font-size: 12pt"><b>
</b></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">set
inappropriately</span></font><font size="3" style="font-size: 12pt"><b>
</b></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">then
requests will hang and that can be seen with 'cat
/proc/scsi/sg/debug'. Hanging requests are still cleaned up by a
</span></font><font size="3" style="font-size: 12pt"><b>close</b></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">(2)
so they should </span></font><font size="3" style="font-size: 12pt"><i><span style="font-weight: normal">not</span></i></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">
impact the driver or system over the longer term.</span></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">
Also consider setting </span></font><font size="3" style="font-size: 12pt"><b>SG_SEIM_TOT_FD_THRESH
</b></font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">to
zero</span></font><font size="3" style="font-size: 12pt"><b>.</b></font></p>
<p><font size="3" style="font-size: 12pt">Finally it was noticed that
there are many more &quot;interesting&quot; values to </font><font size="3" style="font-size: 12pt"><i>read</i></font><font size="3" style="font-size: 12pt">
from the driver (e.g. about its state) than values to </font><font size="3" style="font-size: 12pt"><i>write</i></font><font size="3" style="font-size: 12pt">
to the driver. So rather than potentially fill struct
</font><font color="#6b6400"><font face="Liberation Mono, monospace"><font size="2" style="font-size: 11pt">sg_extended_info</font></font></font><font size="3" style="font-size: 12pt">
with 32 bit values that are only read, the </font><code class="western"><font color="#6b6400"><font size="3" style="font-size: 12pt"><span style="font-style: normal">read_value</span></font></font></code>
<font size="3" style="font-size: 12pt">field was introduced. One of
the following constants is </font><font size="3" style="font-size: 12pt"><i>written</i></font><font size="3" style="font-size: 12pt">
to the </font><code class="western"><font color="#6b6400"><font size="3" style="font-size: 12pt"><span style="font-style: normal">read_value</span></font></font></code>
<font size="3" style="font-size: 12pt">field</font><font size="3" style="font-size: 12pt">
prior to the </font><font size="3" style="font-size: 12pt"><b>ioctl(2)</b></font><font size="3" style="font-size: 12pt">
call</font><font size="3" style="font-size: 12pt">, then the
associated value can be read from the same field when the</font>
<font size="3" style="font-size: 12pt"><b>ioctl</b></font><font size="3" style="font-size: 12pt">(2)
finishes successfully.</font></p>
<table width="100%" cellpadding="2" cellspacing="0" style="page-break-after: avoid; page-break-inside: avoid">
	<col width="40*"/>

	<col width="18*"/>

	<col width="198*"/>

	<tbody>
		<tr valign="top">
			<th width="16%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				SG_SET_GET_EXTENDED</p>
				<p>value written to <code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">read_value</span></span></font></code>
								</p>
			</th>
			<th width="7%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				scope 
				</p>
			</th>
			<th width="77%" bgcolor="#fcd4d1" style="background: #fcd4d1" style="border: none; padding: 0cm"><p>
				Notes</p>
			</th>
		</tr>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_BOOL_MASK</b> [0x1]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				fd</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				with <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
				set to SG_SEIRV_BOOL_MASK, after
				<b>ioctl</b>(SG_SET_GET_EXTENDED{SG_SEIM_READ_VAL) <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
				has a 32 bit mask of bit positions that are used in <code class="western"><font color="#6b6400"><span style="font-style: normal">ctl_flags</span></font></code>
				(and <code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">ctl_flags_wr_mask</span></span></font></code>
				and <code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">ctl_flags_rd_mask</span></span></font></code>).
				It is reading the SG_CTL_FLAGM_ALL_BITS define whose value is
				currently 0xffff .</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_DEV_</b><b>INACT</b><b>_RQS</b> [0x4]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				SCSI_device</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				sum of number of inactive requests on each fd belonging to the
				SCSI device (e.g. a SSD) that owns the given fd.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_DEV_SUBMITTED</b> [0x6]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				SCSI_device</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				sum of number of active list elements, excluding those associated
				with synchronous (blocking) invocation, on each fd belonging to
				the SCSI device that owns fd given as the first argument to the
				<b>ioctl</b>(2)</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_DEV_TS_LOWER</b>  [0x8]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				SCSI_device</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				after this call the <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
				field is set to the <i>lower</i> 32 bits of a 64 bit timestamp.
				That timestamp is set when the sg device owning this file
				descriptor is created, its unit is nanoseconds, and it is
				typically the number of nanoseconds since the machine was booted.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_DEV_TS_UPPER</b>  [0x9]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				SCSI_device</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				after this call the <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
				field is set to the <i>upper</i> 32 bits of a 64 bit timestamp.
				That timestamp is set when the sg device owning this file
				descriptor is created, its unit is nanoseconds, and it is
				typically the number of nanoseconds since the machine was booted.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_</b><b>INACT</b><b>_RQS</b> [0x3]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				fd</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				number of &quot;inactive&quot; request objects currently in this
				fd's xarray. When there are no active command/requests, this
				value should be at least one inactive request which will be this
				fd's (first) reserved request.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_INT_MASK</b> [0x0]</p>
			</td>
			<td width="7%" style="border-top: 1px solid #000000; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0.05cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				fd</p>
			</td>
			<td width="77%" style="border: 1px solid #000000; padding: 0.05cm"><p>
				after <b>ioctl</b>(2) <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
				has a 32 bit mask of bit positions that are used in <code class="western"><font color="#6b6400"><font size="2" style="font-size: 11pt"><span style="font-style: normal">sei_wr_mask</span></font></font></code>
				and <code class="western"><font color="#6b6400"><span style="font-style: normal">sei_rd_mask</span></font></code>
				. It is reading the SG_SEIM_ALL_BITS define whose value is
				currently 0x3ff .</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_MAX_RSV_REQS</b> [0x7]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				fd</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				The maximum number of reserve requests each file descriptor can
				support. When <b>open</b>('/dev/sg&lt;n&gt;') is invoked the new
				file descriptor has one reserve request associated with it. Extra
				reserve requests are generated when, for example,
				<b>ioctl</b>(<font color="#a3238e"><span style="font-weight: normal">SG_IOSUBMIT</span></font>)
				is invoked on the <font color="#000000"><u>read-side</u></font>
				of a share and there are one or more shared requests already
				active.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_SUBMITTED</b> [0x5]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				fd</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				after <b>ioctl</b>(2), <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
				has a 32 bit integer which is the number requests on the active
				list; this includes all submitted non-blocking requests that have
				not yet been completed and read. So this includes requests that
				are <i>inflight.</i><span style="font-variant: normal">
				</span><span style="font-variant: normal"><span style="font-style: normal">ioctl(SG_GET_NUM_WAITING)
				is similar but it does not include </span></span><i>inflight</i><span style="font-variant: normal">
				</span><span style="font-variant: normal"><span style="font-style: normal">requests.</span></span><span style="font-variant: normal">
				</span><span style="font-variant: normal"><span style="font-style: normal">This
				</span></span><span style="font-variant: normal"><span style="font-style: normal"><b>ioctl</b></span></span><span style="font-variant: normal"><span style="font-style: normal">(2)
				holds no locks in the sg driver and accesses an atomic integer.
				So it is fast and should never block making it suitable for
				polling. In the presence of other producers or consumers the
				number submitted</span></span><span style="font-variant: normal">
				</span><span style="font-variant: normal"><span style="font-style: normal">may
				change before a user has time to act on the result of this call.</span></span></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="16%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				<b>SG_SEIRV_VERS_NUM</b> [0x2]</p>
			</td>
			<td width="7%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0cm"><p>
				driver</p>
			</td>
			<td width="77%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.05cm; padding-left: 0.05cm; padding-right: 0.05cm"><p>
				after <b>ioctl</b>(2) <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
				has a 32 bit integer whose latter digits went seen in decimal are
				in the form [x]xyyzz . [x] means blank (space) if zero. This is
				usually expressed as an ASCII string as '[x]x.[y]y.zz' .</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm"><font size="3" style="font-size: 12pt"><b><span style="font-style: normal">Table
1</span><span style="font-style: normal">1</span><span style="font-style: normal">:
ioctl(SG_SET_GET_EXTENDED) value written to</span><i> </i></b><code class="western"><font color="#6b6400"><span style="font-style: normal"><span style="font-weight: normal">read_value</span></span></font></code><i><b>
</b></i><span style="font-style: normal"><b>field</b></span></font></p>
<p><br/>
<br/>

</p>
<p>For example, to find out the number of commands/requests submitted
(but not yet finished) on the device (e.g. /dev/sg3) associated with
file descriptor sg_fd:</p>
<pre class="western">        <font size="3" style="font-size: 12pt">sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">sei_wr_mask</font></font><font size="3" style="font-size: 12pt"> |= SG_SEIM_READ_VAL;</font>
        <font size="3" style="font-size: 12pt">sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">sei_rd_mask</font></font><font size="3" style="font-size: 12pt"> |= SG_SEIM_READ_VAL;</font>
        <font size="3" style="font-size: 12pt">sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">read_value</font></font> <font size="3" style="font-size: 12pt">= </font><font size="3" style="font-size: 12pt"><span style="font-weight: normal">SG_SEIRV_DEV_SUBMITTED</span></font><font size="3" style="font-size: 12pt">;</font>
        <font size="3" style="font-size: 12pt">if (ioctl(sg_fd, SG_SET_GET_EXTENDED, &amp;sei) &lt; 0) {</font>
                <font size="3" style="font-size: 12pt">err = errno;</font>
                <font size="3" style="font-size: 12pt">goto error_processing;</font>
        <font size="3" style="font-size: 12pt">}</font>
        <font size="3" style="font-size: 12pt">tot_num_submitted = sei.</font><font color="#6b6400"><font size="3" style="font-size: 12pt">read_value</font></font><font size="3" style="font-size: 12pt">;</font></pre><p>
Note that this number only counts non-blocking requests submitted
through the sg driver. If, for example, /dev/sdc and /dev/sg3 were
the same device then it doesn't count any requests that might be
submitted by the sd driver through /dev/sdc .</p>
<p>The sg device creation timestamp does not change after a sg device
object is created. So the order of reading the upper and lower 32
bits of the 64 bit timestamp is not usually significant (unless the
associated device is substituted <i>between</i> the calls). The real
(i.e. wall clock) time of that device object creation can be found by
this calculation:</p>
<p>	<b>clock_gettime</b>(CLOCK_REALTIME) -
<b>clock_gettime</b>(CLOCK_BOOTTIME) +
nanosecs2timespec(64bit_sg_seirv_dev_ts)</p>
<p>There is a slight fuzziness when this calculation is done
repeatedly (assuming the <b>clock_gettime</b>() calls are repeated)
in the order of tens of nanoseconds. This can be made worse when the
Linux scheduler schedules out the process between these calls. For
determining if an sg device changed or not, it is best to use the raw
64 bit timestamp built from the <code class="western"><font color="#6b6400"><span style="font-style: normal">read_value</span></font></code>
fields yielded by <b>SG_SEIRV_DEV_TS_LOWER</b><span style="font-weight: normal">
and </span><b>SG_SEIRV_DEV_TS_</b><b>UPPER</b><span style="font-weight: normal">
ioctl calls.</span></p>
<h2 class="western"><a name="__RefHeading___Toc17996_3956569564"></a><b>16
System Calls</b></h2>
<p><span style="font-weight: normal">This section lists Linux system
calls that can be used with a sg file descriptor</span><span style="font-weight: normal">,
normally as the first argument</span><span style="font-weight: normal">
of a system call</span><span style="font-weight: normal">.</span><span style="font-weight: normal">
</span><span style="font-weight: normal">System calls </span><span style="font-weight: normal">are
the main </span><span style="font-weight: normal">method </span><span style="font-weight: normal">that</span><span style="font-weight: normal">
user space programs </span><span style="font-weight: normal">have </span><span style="font-weight: normal">to
interact with the Linux kernel and the resources that it manages.
</span><span style="font-weight: normal">Remember 'man &lt;system_call&gt;'
is your friend; what is shown below is </span><i><u><span style="font-weight: normal">additional</span></u></i><span style="font-weight: normal">
information specific to the sg driver for these system calls.</span></p>
<table width="100%" cellpadding="4" cellspacing="0" style="page-break-after: avoid">
	<col width="53*"/>

	<col width="16*"/>

	<col width="187*"/>

	<tbody>
		<tr valign="top">
			<th width="21%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				system call name</p>
				<p>generic <font color="#000000"><b>description</b></font> in
				'man 2 &lt;system_call&gt;'</p>
			</th>
			<th width="6%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				Status</p>
			</th>
			<th width="73%" bgcolor="#ffe5ca" style="background: #ffe5ca" style="border: none; padding: 0cm"><p>
				Notes</p>
			</th>
		</tr>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>close</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				called '<b>release</b>()' within Linux drivers such as sg. <font color="#000000">F</font><font color="#000000">i</font>le
				descriptor aliases can be produced with system calls like <b>dup</b>(2)
				and <b>dup2</b>(2). In that case multiple aliases may be
				<b>close</b>(2)-d with only the <i><u>last</u></i> <b>close</b>(2)
				being forwarded to the sg driver as a <b>release</b>(). The sg
				driver potentially does a lot of work on <b>release</b>(), some
				of which is done <i><u>after</u></i> the last <b>close</b>(2)
				returns to the user space! That post-<b>close</b>(2) work
				includes waiting for any requests that are still <i>inflight</i>
				to reach their internal completion point at which time their
				resources are cleaned up. To speed normal operation, request
				resources (i.e. sg_request objects and their associated buffers)
				are <i><u>not</u></i> freed until a <b>release</b>() occurs on
				their owning file descriptor. Those inactive request resources
				are re-used by later requests on the same file descriptor. The
				deferring of frees makes &quot;use-after-free&quot; type errors
				very rare in this driver but can lead to a lot of resources (e.g.
				memory) being held when large IO depths are used. If this is a
				problem and the large IO depth is no longer needed, then <b>close</b>()
				that file descriptor and get a new one with
				<b>open</b>(&lt;same_file_devcie_name&gt;) .</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>fcntl</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				the F_SETFD command (second argument) can be used to add the
				O_ASYNC file access mode (third argument)  to the given sg file
				descriptor (first argument).  Subsequent internal completion
				points on this file descriptor will generate a SIGIO or real time
				signal. The F_SETSIG command can be used to generate a real time
				(RT) signal at the internal completion point instead of SIGIO if
				the RT signal number (third argument) is greater than 0; if the
				third argument is 0 then generate a SIGIO at the internal
				completion point (default action).</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>ioctl</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				see previous section.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>lseek, llseek</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				disabled</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				sg driver calls no_llseek() which causes <b>lseek</b>(2) and
				<b>llseek</b>(2) to fail with errno=ESPIPE .</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>mmap, munmap</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				a subset of the generic <b>mmap</b>() system call is supported by
				this driver. It is used to make the contents of a driver buffer
				visible directly to the user space. Only one such <b>mmap</b>()-ed
				buffer per sg driver file descriptor can be visible at a time.
				<b>mmap</b>() must be invoked with <i>addr</i> (its first
				argument) set to NULL, <i>prot</i> should be set to {PROT_READ |
				PROT_WRITE), <i>flags</i> set to MAP_SHARED, and the final
				argument <i>offset</i> set to 0. Then the driver 'gives back' the
				mmap-ed area address to the user space. In practice this means
				that the same mmap-ed area cannot be used for <i><u>both</u></i>
				a READ request and a WRITE request, which would be useful for
				copying. That is part of the motivation for shared requests in
				this driver. Note the sg file descriptor is given as the second
				last argument of <b>mmap</b>().</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>open</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				simplest is to <b>open</b>(&lt;sg_device_name&gt;, flags) with
				flags set to O_RDWR . Some well known SCSI commands like INQUIRY
				will succeed with O_RDONLY. On most systems
				<b>open</b>(&lt;sg_device_name&gt;) will fail unless the user has
				root permissions. <b>open</b>(&lt;sg_device_name&gt;, flags)
				implements special semantics when the O_EXCL flag is OR-ed with
				others; if another user has an active file descriptor already on
				the <i><u>same</u></i><i> </i>&lt;sg_device_name&gt; then a
				subsequent <b>open</b>() will wait until the former is released
				(i.e. <b>close</b>() is called) or will fail with errno=EBUSY.
				The failure occurs when O_NONBLOCK has <i><u>not </u></i>been
				given, the (interruptible) wait occurs otherwise. O_DIRECT cannot
				be used with <b>open</b>(&lt;sg_device_name&gt;, flags) since
				&lt;sg_device_name&gt; is a character device; an equivalent
				<font color="#000000">action </font>can be produced with the
				SG_FLAG_DIRECT_IO flag set on a request. Unlike other system
				calls listed here, <b>open</b>(2) <i><u>returns</u></i> a sg
				driver file descriptor which will always be 0 or greater.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>poll</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				active</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				The internal completion point generates a POLLIN event. Any
				requests that are still waiting and have not yet been processed
				(e.g. with SG_IORECEIVE) will also generate a POLLIN event. If a
				sg file descriptor is being shared by two threads and one does a
				blocking <b>ioctl</b>(SG_IO) and the other does a non-blocking
				<b>ioctl</b>(SG_IOSUBMIT) then the <i>blocking</i> <b>ioctl</b>
				reaching its completion point will <i><u>not</u></i> cause a
				POLLIN event.</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>read</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#ff0000">deprecated</font></p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				<font color="#000000">a </font><font color="#000000">non-blocking
				(asynchronous) request containing a SCSI command </font><font color="#000000">is</font><font color="#000000">
				</font><font color="#000000"><i><u>complet</u></i></font><font color="#000000"><i><u>ed</u></i></font><font color="#000000">
				with this system call. Only version 3 (i.e. struct sg_io_hdr) and
				version 2 interfaces are supported; so version 4 (i.e. struct
				sg_io_v4) is </font><font color="#000000"><i><u>not</u></i></font><font color="#000000">
				supported</font><font color="#000000"> by </font><font color="#000000"><b>read</b></font><font color="#000000">()</font><font color="#000000">.</font><font color="#000000">
				Note that when ioctl(SG_SET_FORCE_PACK_ID) is active, the </font><font color="#0066b3">pack_id</font><font color="#000000">
				field is </font><font color="#000000"><i><u>read</u></i></font><font color="#000000">
				by this driver </font><font color="#000000">via</font><font color="#000000">
				the </font><font color="#000000"><b>read</b></font><font color="#000000">(2)'s
				third argument, and if that matches a completed request then its
				associated data is then written out to the user space via the
				same third argument. This is somewhat surprising (i.e.
				bi-directional data flow) give</font><font color="#000000">n</font><font color="#000000">
				the generic definition </font><font color="#000000">o</font><font color="#000000">f
				the </font><font color="#000000"><b>read</b></font><font color="#000000">(2)
				system call</font><font color="#000000"> which has a
				uni-directional data transfer sense (i.e. </font><font color="#000000"><i>from</i></font><font color="#000000">
				the device </font><font color="#000000"><i>to</i></font><font color="#000000">
				the user space).</font></p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<b>write</b></p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<font color="#ff0000">deprecated</font></p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				a non-blocking (asynchronous) request containing a SCSI command
				is <i><u>submitted</u></i> with this system call. Only version 3
				(i.e. struct sg_io_hdr) and version 2 interfaces are supported;
				so version 4 (i.e. struct sg_io_v4) is <i><u>not</u></i>
				supported by <b>write</b>().</p>
			</td>
		</tr>
	</tbody>
	<tbody>
		<tr valign="top">
			<td width="21%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				&lt;&lt; any others&gt;&gt;</p>
			</td>
			<td width="6%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: none; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0cm"><p>
				<br/>

				</p>
			</td>
			<td width="73%" style="border-top: none; border-bottom: 1px solid #000000; border-left: 1px solid #000000; border-right: 1px solid #000000; padding-top: 0cm; padding-bottom: 0.1cm; padding-left: 0.1cm; padding-right: 0.1cm"><p>
				if <font color="#000000">a</font> system call requires mandatory
				support from the sg driver then it will fail. Otherwise the
				system call will have its generic action.</p>
			</td>
		</tr>
	</tbody>
</table>
<p align="center" style="margin-top: 0.21cm; margin-bottom: 0.21cm"><font size="3" style="font-size: 12pt"><b><span style="font-style: normal">Table
1</span><span style="font-style: normal">2</span><span style="font-style: normal">:
</span><font color="#000000"><font size="3" style="font-size: 12pt"><span style="font-style: normal">system
calls</span></font></font></b></font></p>
<p style="font-weight: normal">Note that the sg version 4 interface
(i.e. struct sg_io_v4) uses <b>ioctl</b>(2)s for all its submissions,
completions and adds new support for aborting a SCSI command that is
underway.</p>
<h2 class="western"><a name="__RefHeading___Toc1578_4294551682"></a>17
Downloads and testing</h2>
<p>This tarball: <a href="p/sgv4_20210117.tgz">sgv4_20210117</a>
contains a README file that outlines what is included. There are
earlier versions of this driver for the <u>lk5.</u><u>7</u><u>, lk5.8</u>
and <u>lk5.</u><u>9</u><u> series</u>. The most recent versions of
this driver around found in its <u>lk5.</u><u>11rc</u> directory 
Each of the directories contains a patchset placed in sub-directory.
The three new or changed files that represent the driver:
drivers/scsi/sg.c , include/uapi/scsi/sh.h and include/include/sg.h
are also placed under each lk5.* directory. 
</p>
<p>The sg3_utils was originally written to test the v3 sg driver
interface when it was introduced, circa 2000. So where better to put
sg v4 test code? Since the sg3_utils is well established, the author
sees no benefit in introducing a sg4_utils package in which less than
an estimated 5% of the code would change, much easier to incorporate
that code change/addition in the existing package. The latest
sg3_utils release is on the <a href="index.html">main</a> page (<font color="#000000">beta
</font>version 1.46  revision 854 as this is written) and contains
utilities for testing the sg v4 interface. The underlying support
library has been using the sg v4 header for many years as a common
(i.e. intermediate) format (API) across the supported Operating
Systems. If the given device was a bsg device node then the sg v4
interface was used; otherwise (e.g. for sg and block devices) the sg
v4 header was translated down to a v3 header and forwarded on. In the
current version, the sg3_utils will use <b>ioctl</b>(SG_GET_VERSION_NUM)
on sg devices and if it is a v4 driver then it will send a v4 header,
otherwise it will do as it does now. [That v4 interface usage can be
defeated by './<b>configure</b> --disable-linux-sgv4' .] 
</p>
<p>The presence of the environment variable SG3_UTILS_LINUX_NANO
(typically with 1 assigned into it) in the shell executing sg3_utils
package utilities will cause the elapsed time of SCSI commands to be
calculated in nanoseconds if the v4 sg driver is active. Typically
command times are only shown when the --verbose option is given (or
several of them). The duration is measured starting from the point
the sg driver sends a command to the block layer to the point when
the sg driver receives a (soft) interrupt indicating that command has
finished. Note that user space measures of a command duration should
always be greater than the duration the sg driver calculates. Most of
the test utilities in the next paragraph also act on
SG3_UTILS_LINUX_NANO .</p>
<p>In the testing directory of that beta are several utilities that
are &quot;v4&quot; driver aware:</p>
<ul>
	<li><p><b>sg_tst_ioctl</b><span style="font-variant: normal"><span style="text-decoration: none"><span style="font-style: normal"><span style="font-weight: normal">:</span></span></span></span>
	mainly tests <b>ioctl</b>(SG_SET_GET_EXTENDED) variants. Also tests
	forking a process and passing sg file descriptors between processes
	with Unix sockets.</p>
	<li><p><b>sg_tst_async</b><span style="font-weight: normal">: uses
	either TEST UNIT READY (TUR), READ(16) or WRITE(16) to bombard the
	sg driver from a user selected number of threads</span> <span style="font-weight: normal">(pthreads)
	[C++]</span></p>
	<li><p><span style="text-decoration: none"><b>sgh_dd</b></span><span style="text-decoration: none"><span style="font-weight: normal">:
	is another </span></span><span style="text-decoration: none"><b>dd</b></span><span style="text-decoration: none"><span style="font-weight: normal">(1)
	clone. It exercises shared file descriptors and requests from 1 or
	more threads. It can also invoke multiple requests with the mrq=NRQS
	operand. See '</span></span><span style="text-decoration: none"><font face="Liberation Mono, monospace"><span style="font-weight: normal">sgh_dd
	-h</span></font></span><span style="text-decoration: none"><span style="font-weight: normal">',
	'</span></span><span style="text-decoration: none"><font face="Liberation Mono, monospace"><span style="font-weight: normal">sgh_dd
	-hh</span></font></span><span style="text-decoration: none"><span style="font-weight: normal">'
	and '</span></span><span style="text-decoration: none"><font face="Liberation Mono, monospace"><span style="font-weight: normal">sgh_dd
	-hhh</span></font></span><span style="text-decoration: none"><span style="font-weight: normal">'
	for more information.</span></span><span style="text-decoration: none">
	</span><span style="text-decoration: none"><span style="font-weight: normal">[C++]</span></span></p>
	<li><p><b>sgs_dd</b><span style="text-decoration: none"><span style="font-weight: normal">:</span></span>
	<span style="font-weight: normal">is</span> yet another <b>dd</b>(1)
	clone. It is an old (resurrected) utility for testing polling, SIGIO
	and RT signal usage with the sg driver.</p>
	<li><p><b>sg_mrq_dd</b>: yes, another dd clone: using share variable
	blocking (svb) <i>mrq</i> for sg to sg copies. It can take
	scatter-gather lists with its skip= and seek= operands (like the
	<b>ddpt</b> utility in a package of the same name)</p>
</ul>
<p>These test utilities are <u>not</u> built by default since they
are not part of the automake setup; instead an <i>old school</i>
Makefile in the testing directory is used. Also <b>sg_tst_async</b><b>,</b>
<b>sgh_dd</b> and <b>sg_mrq_dd</b> are C++ programs and can be built
with '<b>make</b>'  like the C programs in that directory. Prior to
building these test utilities the sg3_utils <u>library </u>needs to
be built. That can be done with '<b>cd</b> &lt;root_of_sg3_utils&gt;
; ./<b>configure</b> ; <b>cd</b> lib ; <b>make</b> ; <b>cd</b>
../testing' . There is a '<b>make</b> install' which will place the C
and C++ test utilities in /usr/local/bin .</p>
<p>The <b>fio</b> utility has an ioengine for the sg driver (e.g.
'<font face="Liberation Mono, monospace">--ioengine=sg
--filename=/dev/sg1</font>'). It supports the sg v3 interface, both
async (via <b>write</b>(2) and <b>read</b>(2)) and sync (i.e.
blocking via <b>ioctl</b>(SG_IO)). A patch was sent to the
linux-block and linux-scsi lists titled: &quot;fio: add sgv4 engine&quot;
on 20190706 to add a new io engine called &quot;sgv4&quot;. It is
modelled on the existing &quot;sg&quot; engine but unlike the sg
engine, the &quot;sgv4&quot; engine uses the sg v4 interface. The
&quot;sgv4&quot; engine can be used with the bsg device nodes
(because the bsg driver uses the sg v4 interface) and sg device nodes
if the patchset described above is applied.</p>
<p>Debug messages may be written to syslog if support for them is
compiled into the sg driver (e.g. by defining SG_DEBUG to be 1 in
sg.c) and when the appropriate run time setting is made. A script in
the scripts directory of the sg3_utils package called
<b>scsi_logging_level</b> can be used to turn on (and off) debug
messages like this:</p>
<pre class="western">scsi_logging_level -s -T 3
</pre><p>
That final number is between 0 and 7 with 7 being the maximum amount
of output and 0 being <font color="#000000">no output. The number
shown: 3 will </font><font color="#000000">output</font><font color="#000000">
any </font><font color="#000000">warnings or </font><font color="#000000">errors
</font><font color="#000000">that are </font><font color="#000000">detected,
so if things a working properly then there should be no output.
Setting the value to more that 3 will cause a lot of output during
normal operation</font>. The '-T' stands for <i>timeout</i> and was
chosen so that the debug output from the sg driver would not
interfere with debug output from the SCSI mid-layer or other upper
level drivers (e.g. the sd driver for disks). A snapshot of the state
of the driver's object tree can be seen with either of these two
commands:</p>
<pre class="western">cat /proc/scsi/sg/debug
cat /sys/kernel/debug/scsi_generic/snapshot</pre><p style="margin-bottom: 0cm">
<br/>

</p>
<p style="margin-bottom: 0.4cm">Since the sg v4 driver may or may not
be present in the kernel that the above utilities are built and run
in, a local copy of the new &lt;kernel_src&gt;/include/uapi/scsi/sg.h
header needed for the sg v4 driver is kept in the testing directory.
It has the name 'uapi_sg.h' so it won't collide with the &quot;real&quot;
header if it is present.</p>
<h2 class="western"><a name="__RefHeading___Toc1580_4294551682"></a>18
Other documents</h2>
<p>The original sg driver documentation is here: <a href="http://www.tldp.org/HOWTO/SCSI-Generic-HOWTO/index.html">SCSI-Generic-HOWTO</a>
and a more recent discussion of <b>ioctl</b>(SG_IO) is here: <a href="sg_io.html">sg_io</a>
.</p>
<h2 class="western"><a name="__RefHeading___Toc1582_4294551682"></a>19
Conclusion</h2>
<p>The sg v4 driver is designed to be backwardly compatible with the
v3 driver. This simplest way for an application to find which driver
version it has is with the <b>ioctl</b>(SG_GET_VERSION_NUM). Removing
a restriction such as 16 outstanding commands per file descriptor can
catch out programs that rely on hitting that limit. If the need
arises, driver parameters to re-impose that limit and any other
differing behaviour can be added. The best way to test backward
compatibility is to place this new driver &quot;under&quot; existing
apps that use sg driver nodes and check their functionality.</p>
<p>Return to <a href="index.html">main</a> page. 
</p>
<p align="center" style="margin-bottom: 0.1cm">Douglas Gilbert</p>
<p align="center" style="margin-bottom: 0.1cm">Last updated: 20
January 2021 21:00</p>
</body>
</html>